;;	 MICROFLOATMC.MU;	 S. MARSHALL;	 November 19, 1980 ###;#AltoConsts23.MU;	DEFINITIONS AND CONSTANTS FOR ALTOS;;	/* REGISTERS;///	RED ALERT....RED ALERT ///;/// BEFORE CHANGING ANY REGISTER ASSIGNMENTS CONSULT;/// THE SACRED TEXTS (SMALL.OPS) SO THAT YE MAY;/// CONTINUE TO SPEAK THE TRUTH AND LIVE IN HARMONY;/// WITH THE VIRTUAL MACHINE (I.E. THE NOVACODE KNOWS;/// THE NUMBERS OF CERTAIN OF THE REGISTERS ALL DULY;/// NOTED IN AN APPROPRIATELY TITLED SECTION OF SMALL.OPS;/// AND CHANGES SHOULD BE REFLECTED THERE);/// RED ALERT....RED ALRET ///$AC3		$R0;$NAMES	$R0;	<LITMSGS,SUBS>$AC2		$R1;$CYCOUT2	$R1;	<SUBS,ALLOC>$AC1		$R2;$AC0		$R3;$ARG1		$R3;	<ALLOC(LITMSGS,INTN)>**ARGUMENT TO OOZE ROUTINES$NWW		$R4;$TEMP1	$R5;	<SUBS,LITMSGS,ALLOC(LITMSGS,INTN)>$CYRET	$R5;$PC		$R6;$XREG		$R7; <PMAP>$RETN0	$R10;	<PMAP,;	 HASH(IVL,ILNG,REF,SUBS,ALLOC(LITMSGS,INTN),LITMSGS)>$COREBASE	$R14;	FIRST CORE LOCATION (MUST BE CLASS CONTEXT)$PCB		$R15;	**BYTE PC IN CODE$MODE		$R16;	MODE MUST BE A R REG BECAUSE OF BUS=0 TIMING PROBLEM;			AT REFX10:;			MODE=0 IN NORMAL EXECUTION;			MODE=1 WHILE DOING SMASH OPERATION$AOOP		$R17;	<LITMSGS,SUBS>OOP OF BASE REGISTER A$CYCOUT	$R35;;	<NEXTBYTE,JMPS,SUBS,LITMSGS,MAPCODE(RETURN),GCLASS(IVAL)>$RHO		$R35;;	<HASH(IVAL,ILONG,REF,SUBS,ALLOC(LITMSGS,INTN),LITMSGS)>$RESIDUE	$R36;;	<HASH(IVAL,ILONG,REF,SUBS,ALLOC(LITMSGS,INTN),LITMSGS)>;---------------	REGS ABOVE ARE VOLATILE W/RESPECT TO NOVA EMULATOR;;---------------   BANK 0 REGISTER ASSIGNMENTS;$LREG		$R40;	RAM'S COPY OF LREG$TEMP2	$R41; <REF,ALLOC(LITMSGS,INTN),LITMSGS,ARITHOPS,SUBS>$TEMP4	$R42;	<SUBS>$TEMP3	$R43;	<ALLOC(LITMSGS,INTN),LITMSGS,ARITHOPS,SUBS,REF>$NAME		$R44; **DOUBLE NAME* <LITMSGS,SUBS>$CNT		$R44; **DOUBLE NAME* <SUBS>$ROTA		$R45;	<HASH(IVAL,ILONG,REF,SUBS,LITMSGS,ALLOC(...,INTN))>$ROT0		$R46;	<HASH(IVAL,ILONG,REF,SUBS,LITMSGS,ALLOC(...,INTN))>$ROT1		$R47;	<HASH(IVAL,ILONG,REF,SUBS,LITMSGS,ALLOC(...,INTN))>$RPC		$R50;	<HASH(IVAL,ILONG,REF,SUBS,LITMSGS,ALLOC(...,INTN))>$RETN1	$R51;	<GCLASS(IVAL(LITMSGS),SUBS),ILONG(SUBS),REF,ALLOC(...,INTN),REGMAP>;---------------	REGS ABOVE ARE VOLATILE W/RESPECT TO BITBLT$ACORE	$R52;	CORE ADDRESS OF BASE REGISTER A$FATHER	$R53;	RAM STATE -  FATHER (NIL WHEN NOT IN RECUF)$MINAT	$R54;	RAM STATE - ATOM BOUND$PMBASE	$R55;	RAM STATE - PMAP CORE ADDR$ROTBASE 	$R56;	RAM STATE - ROT CORE ADDR;---------------	REGS BELOW SAVE STATE ACROSS NOVACALL$SAVR1	$R57;	**DOUBLE NAME* <REF,INTN>$WRAPFL	$R57;	**DOUBLE NAME* <LITMSGS>$AREC		$R60;	ACTIVATION CORE ADDRESS$SAVPC	$R61;$SAVDISP	$R62;$BCORE	$R63;	CORE ADDRESS OF BASE REGISTER B$SAVR0	$R64;	<HASH(IVAL,ILONG,REF,SUBS,ALLOC(LITMSGS,INTN),LITMSGS)>;			SAVE RETN0 ACROSS FAULTS$BOOP		$R65;	OOP OF BASE REGISTER B$LOCFRAME	$R66;	**LITERAL VECTOR CORE ADDRESS$STACKP	$R67;	**INDEX OF TOP OF STACK$TOP		$R70;	OOP ON TOP OF STACK$CADDR	$R71;$TFRAME	$R72;	TEMPORARY FRAME CORE ADDRESS$SELF		$R73;	ACTIVE INSTANCE CORE ADDRESS$SUPMOD	$R74;	-1 EXCEPT WHEN ACCESSING SUPERCLASS$RETN2	$R75;	<IVAL(SUBS,LITMSGS),LITMSGS,INTN>$CTXT		$R76;	OOP OF CURRENT CONTEXT$SAVSP	$R77;	STACK POINTER SAVER$RAMRETURN	$R77;	RETURN ADDRESS FOR OTHER RAM BANK CALLS ###;;	/* CONSTANTS$RCT1BIT	$20;	REFCT 1-BIT$RCT8BIT	$200;	REFCT 8-BIT$RCTM1BIT	$177760;	MINUS REFCT 1-BIT$ROTMSK	$7777;	ROT SIZE MASK ###$ROT0EM	$360;	ROT EMPTY PATTERN$ROT0ND	$L0,12000,100;	CONSTANT 0 IS SUPER-SPECIAL;	ROT0 FOR NEW, NOT CLEAN, REF=1, NOT IMMED (I.E. NO BITS ON)$CLNMSK	$177775;	DIRTY MASK - TURNS OFF CLEAN (=2) BIT$RCTMSK	$360;	REFCT MASK - MORE IMBEDDED IN REFI/REFD$HKRMSK	$174000;	ROT HKR BIT MASK$RPCBIT	$400;	LOW BIT OF ROT RPC FIELD FOR INC-IN-PLACE$IMMBIT	$4;	IMMEDIATE BIT MASK FOR ROT0$MSINT	$174000;$OOP00	$176000;$M2001	$175777;$12		$12;$500		$500;$RESRPC	$177400;	ROT HKR-RPC BIT MASK$ROTABASEM1	$177777;	RAM BASE FOR BASEREG ROTA$OOPBASEM1	$1777;	RAM BASE FOR BASEREG OOP$CPTMSK	$100;		MASK FOR IS-POINTER IN PMAP$ISCMSK	$37;		MASK FOR INSTANCE SIZE IN PMAP$RCIMSK	$177600;		REAL CLASS PART OF PMAP$SENDERF	$L0,12000,100;	CONSTANT 0 IS SUPER-SPECIAL;$INSTF	$1;$CODEF	$3;$TFRAMEF	$4;	***WARNING BEFORE CHANGING SEE PUTX4 IN LITMSGS$PCF		$5;	***WARNING PCF AND STACKPF MUST BE TOGETHER$STACKPF	$6;	***WARNING PCF AND STACKPF MUST BE TOGETHER$PMRETI	$L0,12000,100;	CONSTANT 0 IS SUPER-SPECIAL;$HFRETI	$1;$EIRETI	$2;$IJRETI	$3;$CASCME	$177774;;		(CoreAddressofSmalltalkConstantsMinusEight = 4-8 =-4)$OCTV		$24;			ISC OF FIRST OCTAVE$VARCLS	$600;			OOP WHERE VAR-LEN CLASSES START$NUMCLS	$4;			NUMBER CLASS OOP$OBJCLS	$27;			NIL CLASS OOP$FLOATCLS	$5;		FLOATING-POINT CLASS$TYPEF	$7;			INDEX OF TYPE FIELD$SPRCLSF	$5;			INDEX OF SUPERCLASS FIELD$MDICTF	$3;			INDEX OF MESSAGE DICTIONARY$SIZEF	$2;			INDEX OF INSTANCE SIZE$CLFREE	$10;			OFFSET OF FREELISTHEAD IN CLASSES$CLFREE2	$21;			CLFREE OF SECOND CLASS$CLFREE3MT	$31;			CLFREE OF THIRD CLASS MINUS TWO$STMCLS	$10;$CNTXCLS	$2;			OOP OF CLASS CONTEXT (NOTE: SEE "BYTE:")$INTCLS	$12;$VECCLS	$600;$STRCLS	$601;$FALSEOOP	$2000;$TRUEOOP	$2001;$ERRPRG	$3;			ADDRESS OF OOP OF ERROR METHOD$PRIMTABLOC	$100;$SELFLOC	$101;;$EXPMSK	$177776;$RAMXEVEN	$177776;$RAMXODD	$177777;$177770	$177770;;;	/* GLOBAL LABEL ALLIGNMENTS */;********BASE ADDRESS FOR BANK SWITCHING********!200,1,X200;;;********RETURNS FROM NOVA********;!1767,10,OVRET,FIRET,FLTRET,ALLOCRET,PRIMFAIL,SNDMSG,SUPRET,PRIMRET; ###!1767,10,,,,,PRIMFAIL,,,PRIMRET; ###;  AT TOP OF MEMORY SO RAM1, RAM2 CAN GET TO PRIMFAIL AND PRIMRET ###;;********FIX USEFUL ENTRY POINTS SO RAM1, RAM2 CAN JUMP TO THEM ###;********HASH AND REFLAST MUST BE ODD ###;!1757,10,REFCK,REFCKL,REF,REFLAST,NOVAALLOC,,HASHL,HASH; ###!1757,10,,,REF,,NOVAALLOC,,HASHL,HASH; ###;;********LABELS AND CONSTANTS FOR RAM SWITCHING SUBROUTINE CALLS!607,10,RAMX0,RAMX1,RAMX2,RAMX3,RAMX4,RAMX5,RAMX6,RAMX7;!617,10,RAMX10,RAMX11,RAMX12,,,,,;;$RAMRET0	$600;$RAMRET1	$601;$RAMRET2	$602;$RAMRET3	$603;$RAMRET4	$604;$RAMRET5	$605;$RAMRET6	$606;$RAMRET7	$607;$RAMRET10	$610;$RAMRET12	$612;;;********ENTRY POINTS FOR RAM1 IMPLEMENTED SMALLTALK PRIMITIVES********;********THESE ARE PRIMITIVES -01400 TO -01367********;********WATCH THE X200 DISPATCH IN BYTERP********!717,20,PLUS,MINUS,TIMES,OVER,LT,EQ,GT,LE,NE,GE,NEW,VNEW,,,,;;;********RETURNS FOR PMAP********!1,2,PMAPX0,PMAPX1;;;********RETURNS FOR GCLASS********!1,2,GCLASSX0,GCLASSX1;;;********RETURNS FOR SETUP********!7,10,SETUPX0,SETUPX1,SETUPX2,SETUPX3,SETUPX4,,,;;; Copyright Xerox Corporation 1979;Last bug fix by Lyle Ramshaw, changed low order mantissa compare; in FCM from signed to unsigned -- November 26, 1979;REGISTERS USED BY NOVA EMULATOR$M1	$R10;$N1	$R16;$M2	$R35;$N2	$R36;$Temp		$R42;$CRY		$R43;$ShiftCount	$R45;$ANSADDR		$R46;$ANSOOP		$R41;$SubRet		$R47;$E1X			$R3;$E2X			$R2;$M1A		$R60;$N1A		$R61;$M2A		$R62;$N2A		$R63;$E1		$R64;$E2		$R65;$COMPREG		$R66;;REGISTERS USED IN BANK 0$RTMP1	$R57;;;;;		IVAL- 	ARG1:OOP L:RETN;				L_VALUE OF NUMBER;				PRESERVES ARG1;	!1,2,NOTSI,MBSI;	!1,2,ISSI,NONINT;	!1,2,NOTNMBR,ISNMBR;IVALL:	ARG1_ L, L_ T, TASK;IVAL:		RETN2_ L;				(TASK HAPPENS HERE)		T_ MSINT;		L_ ARG1-T;		L_ ARG1+1, ALUCY;		TEST >= MIN SMALL INTEGER		T_ OOP00, SH=0, :NOTSI;	TEST FOR NIL IF SOMBSI:		L_ ARG1-T,  :ISSI;ISSI:		NOP;		SINK_ RETN2, BUS;		L_ T_ LREG, :IVALX0;NONINT:	L_ ONE, TASK, :GCLASS;NOTSI:	L_ ONE, TASK, :GCLASS;GCLASSX1:	L_ NUMCLS-T;		TEST FOR CLASS = NUMBER		T_ 11, SH=0;		L_ RETN2-T, :NOTNMBR;ISNMBR:	L_ RAMRET10 + 1;		HASH INTO ROT	RAMRETURN _ L, SWMODE, :HASH;	;// HASH LARGE INTEGER. NO DIRTY //RAMX11:	L_ ROT1, TASK, :ISSI;NOTNMBR:	SWMODE, :PRIMFAIL;;;;;		GCLASS- 	ARG1:OOP L:RETN;				L_OOP'S CLASS;				PRESERVES ARG1!1,2,PMAP,GCNIL;GCLASSL:	ARG1_ L, L_ T, TASK;GCLASS:	RETN1_ L;				(TASK HAPPENS HERE)DOGC:		L_ ARG1+1;		T_ ARG1, SH=0;			TEST FOR NIL		L_ ONE, :PMAP;PMAPX1:	T_ RCIMSK;		L_ T_ MD.T;			EXTRACT RCI		CYCOUT_ L MLSH 1;		L_ CYCOUT, TASK;		CYCOUT_ L LCY 8;FIN:		SINK_ RETN1, BUS;		L_ T_ CYCOUT, :GCLASSX0;GCNIL:	L_ OBJCLS, TASK;		CYCOUT_ L, :FIN;;;;		PMAP- 	T:OOP L:RETN;				RETURNS AFTER MAR_ PMAP ENTRY ADDRESS;PMAP:		RETN0_ L, L_ T;		XREG_ L LCY 8;		L_ T_ XREG, TASK;		XREG_ L MLSH 1;		L_ T_ XREG, TASK;		XREG_ L MLSH 1;		T_ 1777-1;				1776		T_ XREG.T, TASK;		L_ PMBASE+T;		SINK_ RETN0, BUS;PMAPX0:		MAR_ LREG, :PMAPX0;		INDEX THE PCLASS MAP (DUMMY LABEL);;;		NOVA ALLOCATE - NEEDS OOP OF CLASS IN AC0 AND LENGTH IN AC1;		L _ NEW OOP;		T _ CORE ADDRESS OF NEW OOP;;;ALLOCL:	RAMRETURN _ L; SAVE RETURN ADDRESS;	L _ 3, SWMODE; 3 IS RAM RETURN ADDRESS FOR ALLOCATE;	NOVAALLOC:	RETN1 _ L, L _ T, :NOVAALLOC; SET RETURN ADDRESS, L _ OOP OF CLASS TO ALLOCATE IN;	!1,2,AOK1,AFAIL1;	!1,2,AOK2,AFAIL2;ALLOCL: RTMP1 _ L, L _ T, TASK; SAVE RETURN	ARG1 _ L; SAVE CLASS	L _ RAMRET3;HASHD:	RAMRETURN _ L, SWMODE; HASH - DIRTY	L _ RAMXODD, TASK, :HASH; DIRTY CALLRAMX3:	MAR _ CLFREE + T; ACCESS FREE LIST POINTER	ACORE _ L; SAVE CORE ADDRESS OF CLASS	L _ ARG1; OOP OF CLASS	AOOP _ L; AND PUT CLASS IN BASE REGISTER	L _ MD + 1; CHECK FOR NIL	L _ LREG - 1, SH=0, TASK;	ARG1 _ L, :AOK1; [AOK1, AFAIL1] OOP OF FREE ELEMENTAFAIL1: L _ RTMP1, TASK, :ALLOCN; HAVE TO CALL THE NOVAAOK1:	L _ RAMRET4, :HASHD; HASH - DIRTY	;// HASH FREE LIST HEAD. DIRTY //RAMX4:	MAR _ T; GET OOP OF NEXT FREE ELEMENT	AC1 _ L; SAVE CORE ADDRESS OF NEW OOP	L _ MD + 1; CHECK FOR NIL	L _ LREG - 1, SH = 0;	T _ ACORE, :AOK2; [AOK2, AFAIL2] CORE ADDRESS OF CLASSAFAIL2: L _ RTMP1, TASK, :ALLOCN; HAVE TO CALL THE NOVAAOK2:	MAR _ CLFREE + T; FREE LIST POINTER		 T_ RESRPC;			T: MASK FOR RES AND REPROBE COUNT		 T_ IMMBIT OR T;		T: MASK FOR IMM BIT, RES AND RPC	MD _ LREG; NEW FREE LIST POINTER		MAR_ ROTA;		 T_ ROT0.T;			T: IMMEDIATE BIT, RES AND RPC		 L_ ROT0ND OR T, TASK;		MD_ LREG;	T _ AC1; CORE ADDRESS OF NEW OOP	SINK _ RTMP1, BUS; RETURNX200:	L _ ARG1, :X200; WITH OOP IN L AND ADDR IN TALLOCN:	RAMRETURN _ L; SAVE RETURN ADDRESS	T _ AOOP; CLASS TO ALLOCATE IN	L _ RAMXODD, SWMODE; SET RETURN FOR ALLOCATENOVAALLOC:	RETN1 _ L, L _ T, :NOVAALLOC; SET RETURN ADDRESS, L _ OOP OF CLASS TO ALLOCATE IN	!1,2,AOK3,AFAIL3;	!1,2,AOK4,AFAIL4;	!1,2,TOOBIG,SIZEOK;	!1,2,NILOUT,NILDONE;	!1,2,WORDS,BYTES;VNEW:	L _ TOP, TASK; CLASS OF OBJECT TO ALLOCATE	ARG1 _ L; ARG FOR HASH	L _ RAMRET12, :HASHD;RAMX12:	T _ STACKP - 1; RELATIVE ADDRESS OF ARGUMENT (LENGTH)	MAR _ TFRAME + T; FETCH INSTANCE SIZE REQUESTED	ACORE _ L; SAVE CORE ADDRESS OF CLASS	L _ ARG1; OOP OF CLASS	AOOP _ L; AND PUT CLASS IN BASE REGISTER	L _ MD; OOP OF SIZE REQUESTED	T _ 0, :IVALL; TURN OOP INTO INTEGERIVALX0:	L _ 10 + T, TASK; GET FREE LIST OFFSET	RETN2 _ L; AND SAVE FREE LIST OFFSET	T _ 21; CANT DO OCTIVE SIZES	L _ RETN2 - T, T _ RETN2; SIZE OF NEW OBJECT + 8 IN T	L _ 177770 + T, SH<0; CONVERT TO INTEGER SIZE REQUESTED	TOP _ L, :TOOBIG; [TOOBIG, SIZEOK]NEW:	L _ CLFREE, TASK; OFFSET OF FREE LIST	RETN2 _ L; SAVE FOR ALLOCATING	L _ TOP, TASK; CLASS OF OBJECT TO ALLOCATE	ARG1 _ L; ARG FOR HASH	L _ RAMRET6, :HASHD;RAMX6:	MAR _ SIZEF + T; FETCH INSTANCE SIZE	ACORE _ L; SAVE CORE ADDRESS OF CLASS	L _ ARG1; OOP OF CLASS	AOOP _ L; AND PUT CLASS IN BASE REGISTER	T _ OOP00;	T _ 23+T+1; CANT DO OCTIVE SIZES	L _ MD - T, T _ MD; SIZE OF NEW OBJECT IN T	L _ 2000 + T, SH<0; CONVERT TO INTEGER	TOP _ L, :TOOBIG; [TOOBIG, SIZEOK]TOOBIG: :AFAIL3;SIZEOK:	T _ ACORE; ADDRESS OF CLASS	MAR _ RETN2 + T; ACCESS FREE LIST POINTER	NOP;	L _ MD + 1; CHECK FOR NIL	L _ LREG - 1, SH=0, TASK;	ARG1 _ L, :AOK3; [AOK3, AFAIL3] OOP OF FREE ELEMENTAFAIL3: :AFAIL4; HAVE TO CALL THE NOVAAOK3:	L _ RAMRET7, :HASHD; HASH - DIRTY	;// HASH FREE LIST HEAD. DIRTY //RAMX7:	MAR _ T, AC1 _ L; GET OOP OF NEXT FREE ELEMENT AND SAVE CORE ADDRESS	NOP;	L _ MD + 1; CHECK FOR NIL	L _ LREG - 1, SH = 0;	T _ ACORE, :AOK4; [AOK4, AFAIL4] CORE ADDRESS OF CLASSAFAIL4: T _ 10;	L _ RETN2 - T, TASK; CORRECT LENGTH TO REQUEST	RETN2 _ L;	L _ RAMRET10, TASK, :ALLOCN; HAVE TO CALL THE NOVAAOK4:	MAR _ RETN2 + T; FREE LIST POINTER		 T_ RESRPC;			T: MASK FOR RES AND REPROBE COUNT		 T_ IMMBIT OR T;		T: MASK FOR IMM BIT, RES AND RPC	MD _ LREG; NEW FREE LIST POINTER		MAR_ ROTA;		 T_ ROT0.T;			T: IMMEDIATE BIT, RES AND RPC		 L_ ROT0ND OR T, TASK;		MD_ LREG; SET REFCT, DIRTY, NEW	T _ ACORE; ADDRESS OF CLASS	MAR _ TYPEF + T; FETCH TYPE FIELD	T _ 20; WBY (WORD/BYTES) MASK	L _ MD AND T; ZERO IF BYTES ELSE WORDS	L _ TOP + 1, SH=0, TASK; GET WORDS * 2 IF BYTES	AC2 _ L RSH 1, :WORDS; [WORDS,BYTES] WORDS IN AC2 IF BYTESBYTES:	L _ AC2, BUS = 0, TASK; MOVE TO TOP	TOP _ L, :NILOUT;WORDS:	SINK _ TOP, BUS = 0, TASK; CHECK IF LENGTH IS ZERO	:NILOUT;NILOUT:	T _ TOP - 1; DECREMENT LENGTH COUNTER	MAR _ AC1 + T; NEXT WORD OF NEW OBJECT TO STORE INTO	L _ T;	TOP _ L, SH = 0, TASK; END CHECK	MD _ ALLONES, :NILOUT; LOOP IF NOT DONENILDONE:	SWMODE; RETURN WITH OOP OF NEW OBJECT IN AC0 = ARG1		:PRIMRET; RETURN WITH OOP OF NEW OBJECT IN AC0 = ARG1RAMX10:	SWMODE, :PRIMRET; RETURN WITH OOP OF NEW OBJECT IN L;;;---------------------------------------------------------------;Floating-point setup routine;checks class of arg and fails if not FP;loads arg into registers;loads self into registers;allocates a new FP number (only done if return is not zero);returns;---------------------------------------------------------------!1,2,ARGFAIL,ARGOK;!1,2,SETUPA,SETUPX;!7,10,LOADX0,LOADX1,LOADX2,LOADX3,LOADX4,LOADX5,,;SETUP:	RETN2 _ L; SAVE RETURN	T _ STACKP-1; GET POINTER TO SECOND FROM TOP OF STACK (ARG)	MAR _ TFRAME + T; FETCH ARG OOP	T _ 0; SET RETURN	L _ MD, :GCLASSL; GET CLASS OF ARGGCLASSX0: L _ FLOATCLS XOR T; COMPARE WITH OOP OF FLOAT CLASS	L _ RAMRET0, SH=0;	RAMRETURN _ L, :ARGFAIL;ARGFAIL: :FAIL;ARGOK:	SWMODE, :HASH; CALL HASH IN RAM0HASH:	L _ RAMXEVEN, TASK, :HASH; HASH - NO DIRTYRAMX0:	AC3 _ L; SAVE CORE ADDRESS	ESRB _ 2; CHANGE S REGISTER BANK	T _ 0, :LOAD; GET EXPONENTLOADX0:	E2 _ L;	T _ ONE, :LOAD; GET HIGH MANTISSALOADX1:	M2A _ L;	T _ 2, :LOAD; GET LOW MANTISSALOADX2: N2A _ L;	ESRB _ 0; SMALLTALK REGISTER BANK	L _ RAMRET1, TASK;	RAMRETURN _ L;	L _ TOP, SWMODE; GET CLASS OF ARGHASHL:	T _ RAMXEVEN, :HASHL; (LABEL USED ONLY IN RAM0)RAMX1: AC3 _ L; SAVE CORE ADDRESS	ESRB _ 2; CHANGE S REGISTER BANK	T _ 3, :LOAD; GET EXPONENTLOADX3:	E1 _ L;	T _ 4, :LOAD; GET HIGH MANTISSALOADX4:	M1A _ L;	T _ 5, :LOAD; GET LOW MANTISSALOADX5: N1A _ L;	ESRB _ 0; SMALLTALK REGISTER BANK	NOP;	WAIT FOR 3K CRAM CARD	SINK _ RETN2,BUS=0, TASK; CHECK IF ALLOCATING FOR RESULT	:SETUPA;SETUPA:	T _ FLOATCLS; ALLOCATE ANSWER FLOATING-POINT NUMBER	L _ RAMRET2, :ALLOCL; DO ALLOCATIONRAMX2:	ESRB _ 2; CHANGE TO FP BANK	NOP; WAIT FOR 3K CRAM CARD;	ANSOOP _ L, L _ T; STORE NEW FLOAT OOP	ANSADDR _ L; SAVE ADDRESS TO STORE ANSWERSETUPX:	ESRB _ 2; CHANGE S REGISTER BANK	NOP;	WAIT FOR 3K CRAM CARD	L _ M1A, TASK; MOVE TO R REGISTERS	M1 _ L; FOR SHIFTING	L _ N1A, TASK; MOVE TO R REGISTERS	N1 _ L; FOR SHIFTING	L _ M2A, TASK; MOVE TO R REGISTERS	M2 _ L; FOR SHIFTING	L _ N2A, TASK; MOVE TO R REGISTERS	N2 _ L; FOR SHIFTING	ESRB _ 0; WHERE RETURN ADDRESS IS STORED	NOP;	WAIT FOR 3K CRAM CARD	L _ RETN2;	ESRB _ 2; CHANGE S REGISTER BANK	SINK _ LREG, BUS, TASK;	:SETUPX0; RETURN TO SPECIFIC ROUTINELOAD:	MAR _ AC3; FETCH WORD FROM MEMORY	L _ AC3 + 1; INCREMENT MEMORY POINTER FOR NEXT TIME	AC3 _ L, L _ T; MOVE RETURN ADDRESS	SINK _ LREG, BUS; DISPATCH ON RETURN NUMBER	L _ MD, TASK, :LOADX0; FETCH WORD TO L AND RETURN ***TASK PENDING***;;---------------------------------------------------------------;multiply subroutine;---------------------------------------------------------------!7,10,MulRet,MulRet1,MulRet2,MulRet3;!1,2,DOMUL,NOMUL;!1,2,MPYL,MPYA;!1,2,NOADDIER,ADDIER;!1,2,NOSPILL,SPILL;!1,2,NOADDX,ADDX;!1,2,NOSPILLX,SPILLX;MUL:	SubRet_L;	L_AC2-1, BUS=0;MPYX:	XREG_L,L_0,:DOMUL;DOMUL:	TASK,L_-10+1;	AC3_L;MPYL:	L_AC1,BUSODD;	T_AC0,:NOADDIER;NOADDIER:	AC1_L MRSH 1,L_T,T_0,:NOSPILL;ADDIER:	L_T_XREG+INCT;	L_AC1,ALUCY,:NOADDIER;SPILL:	T_ONE;NOSPILL:	AC0_L MRSH 1;	L_AC1,BUSODD;	T_AC0,:NOADDX;NOADDX:	AC1_L MRSH 1,L_T,T_0,:NOSPILLX;ADDX:	L_T_XREG+INCT;	L_AC1,ALUCY,:NOADDX;SPILLX:	T_ONE;NOSPILLX:	AC0_L MRSH 1;	L_AC3+1,BUS=0,TASK;	AC3_L,:MPYL;NOMUL:	T_AC0;	AC0_L,L_T,TASK;	AC1_L;MPYA: SINK_SubRet,BUS;	NOP,:MulRet;;---------------------------------------------------------------;divide subroutine;---------------------------------------------------------------!7,10,DivRet,DivRet1,DivRet2;!1,2,DODIV,NODIV;!1,2,DIVL,ENDDIV;!1,2,NOOVF,OVF;!1,2,DX0,DX1;!1,2,NOSUB,DOSUB;DIV:	SubRet_L;	T_AC2;DIVX:	L_AC0-T;	Do the divide only if AC2>AC0	ALUCY,TASK,AC3_L,L_0+1;	:DODIV,AC3_L LSH 1;	AC3_2, count the loop by shiftingNODIV:	SINK_SubRet,BUS;DRET:	NOP,:DivRet;DODIV:	L_AC0,:DIV1;DIVL:	L_AC0;DIV1:	SH<0,T_AC1;	will the left shift of the dividend overflow?	:NOOVF,AC0_L MLSH 1,L_T_0+T;	L_AC1,T_0OVF:	AC1_L LSH 1,L_0+INCT,:NOV1;	L_1: shift overflowedNOOVF:	AC1_L LSH 1,L_T;	L_0: shift okNOV1:	T_AC2,SH=0;	L_AC0-T,:DX0;DX1:	ALUCY;	do the test only if the shift didn't overflow.  If it did, L is still correct	T_AC1,:NOSUB;	but the test would go the wrong wayDX0:	T_AC1,:DOSUB;DOSUB:	AC0_L,L_0+INCT;	do the subtract	AC1_L;	and put a 1 in the quotientNOSUB:	L_AC3,BUS=0,TASK;	AC3_L LSH 1,:DIVL;ENDDIV:	SINK_SubRet,BUS,:DRET;;---------------------------------------------------------------;FLOATING COMPARE RETURNS TRUE OR FALSE (NEVER RETURNS SELF);---------------------------------------------------------------LT:	L _ 4, :COMPARE; <EQ:	L _ 2, :COMPARE; =GT:	L _ ONE, :COMPARE; >LE:	L _ 6, :COMPARE; <=NE:	L _ 5, :COMPARE; #GE:	L _ 3, :COMPARE; >=COMPARE:	ESRB _ 2; SET OUR REGISTER BANK	NOP; WAIT FOR 3K CRAM CARD	COMPREG _ L; SAVE COMPARISON DESIRED	ESRB _ 0, L _ 0; RESET BANK REGISTER AND GO SETUP ARGUMENTS	TASK, :SETUP; WAIT FOR 3K CRAM CARD!1,2,BOTHNZ,ONEZ;!1,2,POS1,NEG1;!1,2,POS1POS2,POS1NEG2;!1,2,NEG1POS2,NEG1NEG2;!1,2,POSNE,POSEQ;!1,2,NEGNE,NEGEQ;!1,2,POSGE,POSLT;!1,2,NEGGE,NEGLT;!1,2,POSMNE,POSMEQ;!1,2,NEGMNE,NEGMEQ;!1,2,POSNNE,POSNEQ;!1,2,NEGNNE,NEGNEQ;!1,2,M1NZ,M1Z;!1,2,M1ZM2NZ,M1ZM2Z;!1,2,TRUERET,FALSERET;!1,1,POSMCOMP;!1,1,NEGMCOMP;!1,1,ENDCOMP;!1,1,ONEZ1;!1,1,M1NZM2X;!1,1,POSMEQ1;!1,1,NEGMEQ1;; NOTE - EXPONENT COMPARE FAILS FOR VERY LARGE DIFFERENCES (NOT TRUE SIGNED COMPARE)SETUPX0:	T _ M1; TEST FOR EITHER ARGUMENT ZERO		L _ M2 AND T; NONZERO RESULT IF BOTH NONZERO		SH=0;		T _ E1, BUSODD, :BOTHNZ; CHECK SIGN OF ARG1BOTHNZ:	L_E2 - T,BUSODD, :POS1; CHECK SIGN OF ARG2POS1:	SH=0, :POS1POS2; COMPARE EXPONENTSNEG1:	SH=0, :NEG1POS2; COMPARE EXPONENTSPOS1NEG2:	T _ ONE, :ENDCOMP; ARG1 (SELF) > ARG2NEG1POS2:	T _ 4, :ENDCOMP; ARG1 (SELF) < ARG2POS1POS2:	T _ M1, SH<0, :POSNE; SEE IF EXPONENTS EQUALNEG1NEG2:	T _ M1, SH<0, :NEGNE; SEE IF EXPONENTS EQUALPOSNE:	:POSGE; ARG1 (SELF) < ARG2NEGNE:	:NEGGE; ARG1 (SELF) > ARG2POSEQ:	L _ M2 - T, :POSMCOMP; COMPARE MNEGEQ:	L _ M2 - T, :NEGMCOMP; COMPARE MPOSMCOMP:	SH=0; SEE IF THE SAME		T _ N1, ALUCY, :POSMNE;POSMNE:	:NEGGE; M NOT EQUAL SO CHECK IF ARGS + OR -POSMEQ:	L _ N2 - T; COMPARE N'SPOSMEQ1:		SH=0; SEE IF THE SAME		ALUCY, :POSNNE;POSNNE:	:NEGGE;POSNEQ:	T _ 2, :ENDCOMP; EQUAL!NEGMCOMP:	SH=0; SEE IF THE SAME		T _ N1, ALUCY, :NEGMNE;NEGMNE:	:POSGE; M NOT EQUAL SO CHECK IF ARGS + OR -NEGMEQ:	L _ N2 - T; COMPARE N'SNEGMEQ1:		SH=0; SEE IF THE SAME		ALUCY, :NEGNNE;NEGNNE:	:POSGE;NEGNEQ:	T _ 2, :ENDCOMP; EQUAL!ONEZ:	SINK _ M1, BUS=0, :ONEZ1; SEE IF FIRST ARG IS ZEROONEZ1:	SINK _ M2, BUS=0, :M1NZ; SEE IF SECOND ARG IS ZEROM1Z:	SINK _ E2, BUSODD, :M1ZM2NZ; HERE IF ARG1 = 0M1NZ:	SINK _ E1, BUSODD, :M1NZM2X; HERE IF ARG1 NOT 0M1ZM2Z:	T _ 2, :ENDCOMP; HERE IF BOTH ZEROM1ZM2NZ:	:POSGE; HERE IF ARG1 = 0, ARG 2 NOT 0M1NZM2X:	:NEGGE; HERE IF ARG1 NOT 0, ARG 2 (ASSUMED) = 0NEGGE:	T _ ONE, :ENDCOMP; ARG1 (SELF) > ARG2NEGLT:	T _ 4, :ENDCOMP; ARG1 (SELF) < ARG2POSGE:	T _ 4, :ENDCOMP; ARG1 (SELF) < ARG2POSLT:	T _ ONE, :ENDCOMP; ARG1 (SELF) > ARG2ENDCOMP: L _ COMPREG AND T; SEE WHAT TO TEST FOR		SH=0, TASK;		:TRUERET;TRUERET: L _ TRUEOOP, SWMODE, :PRIMRET; RETURN TRUEFALSERET: L _ FALSEOOP, SWMODE, :PRIMRET; RETURN FALSE;---------------------------------------------------------------;FMP floating point multiply;---------------------------------------------------------------!1,2,FMPNonZero,FMPZero;!1,2,FMPNonZero1,FMPZero1;!1,2,LowNonZero1,LowZero1;!1,2,MEVEN,MODD;!1,2,MSOV,MSNOV;TIMES: L_3, TASK,:SETUP;	;add exponents, like in any multiplySETUPX3:	T_E1;	L_E2+T, BUSODD, TASK;	E1_L, :MEVEN;MODD:	T _ E1, BUSODD; CHECK IF ADDITION OF SIGNS CARRIED OUT TO EXPONENT	L _ -2 + T, TASK, :MSOV; MULTIPLY SIGN OVERFLOWMSOV:	E1 _ L, :MEVEN; CORRECT EXPONENT FOR SIGN CARRYMSNOV:	NOP;	;first multiply: high*lowMEVEN:	L_M1;	AC1_L,SH=0;	L_N2,:FMPNonZero;FMPZero:	L_0,:LowZero1;	return 0FMPNonZero:	AC2_L,L_0;	AC0_L,:MUL;	L must be 0 for SubRetMulRet: L_AC0,TASK;	Temp_L;	;second multiply: other high*other low	L_M2;	AC1_L,SH=0;	L_N1,:FMPNonZero1;FMPZero1:	L_0,:LowZero1;FMPNonZero1:	AC2_L,L_0;	AC0_L,L_0+1,:MUL;	L must have 1 for Subroutine ReturnMulRet1: T_AC0;	!1,2,NoCarry,Carry;	;add results, set carry if overflow	L_Temp+T;	AC0_L,ALUCY;	L_0,:NoCarry;Carry:	L_ONE;NoCarry:	CRY_L;!1,2,Carry1,NoCarry1;	;last multiply: high*high (plus stuff left in AC0)	L_M1,TASK;	AC1_L;	L_M2;	AC2_L;	L_2,:MUL;MulRet2: SINK_CRY,BUS=0;	L_AC0,:Carry1;	!1,2,Carry1,NoCarry1Carry1:	L_AC0+1;	low+low resulted in a carry, add it nowNoCarry1:	M1_L,SH<0;		now, check normalization!1,2,Normalize,NoNormalize;		T_AC1,:Normalize;		7 instructions since last TASKNormalize:	M1_L MLSH 1;	8		L_AC1;		9		N1_L LSH 1;		10		L_E1-1;	decrement exponent to account for shift		L _ LREG - 1,TASK; -2 TO LEAVE SIGN UNCHANGED		E1_L,:STORE;NoNormalize:	L_AC1,TASK;		N1_L,:STORE;;---------------------------------------------------------------;FDV floating point divide;---------------------------------------------------------------OVER: L_4, TASK,:SETUP;!1,2,DivOK,DivErr;!1,2,DivOK1,DIV0;!1,2,DEVEN,DODD;!1,2,DSNB,DSB;SETUPX4: SINK_M2,BUS=0;	NOP,:DivOK;DivErr:	:DIVFAIL;	;first, subtract exponentsDivOK:	T_E2;	L_E1-T, BUSODD, TASK;	E1_L, :DEVEN;DEVEN:	T _ E1, BUSODD; CHECK IF SUBTRACTION OF SIGNS BORROWED FROM EXPONENT	L _ 2 + T, TASK, :DSNB; DIVIDE SIGN BORROWDSB:	E1 _ L, :DODD; CORRECT EXPONENT FOR BORROWDSNB:	NOP;	;first, (M1,N1)/M2DODD:	L_T_M1,BUS=0;	check for zero dividend	AC0_L,:DivOK1;DIV0:	E1 _ L,TASK,:STORE;	dividend is already 0, just returnDivOK1:	L_ALLONES XOR T,TASK;	NOT AC0	Temp_L;	L_N1,TASK;	AC1_L;	L_T_M2;	AC2_L;	;unsigned test for AC0<AC2: ADCZ# 0,2,SZC	L_Temp+T;	(NOT AC0)+AC2	NOP,ALUCY;!1,2,DivC,D0;	L_T_AC0,:DivC;DivC:	AC0_L RSH 1;	divide dividend by two (rshift)	L_AC1;	AC1_L MRSH 1;	L_E1+1;	bump exponent	L _ LREG + 1; +2 TO LEAVE SIGN UNCHANGED	E1_L;D0:	L_0,:DIV;DivRet:	L_AC1;	M1_L,L_0;	save high order results	AC1_L,L_0+1,:DIV;	now AC0,1 have remainder,0DivRet1:	L_AC1;	N1_L,L_0,TASK;		save low order result	;now, answer is "too big" because low order bits of divisor were not included.	;so, we form correction term (N2/M2)*HighAnswer	AC0_L;	L_N2,TASK;		AC1_L;	low order divisor	L_M1,TASK;	AC2_L;	high order answer so far	L_3,:MUL;	(N2*M1)MulRet3:	T_AC0;	L_ALLONES XOR T;	NOT AC0;	T_M2;				ADCZ# 0,2,SZC	check for divide overflow	L_LREG+T;			JMP D2	divide won't overflow	L_M2,ALUCY;!1,2,DivC2,D2;	AC2_L,:DivC2;DivC2:	L_M1-1,TASK;	decrement high order part of answer (because correction is to low order part)	M1_L;	T_M2;	and subtract "one" from dividend	L_AC0-T,TASK;	AC0_L;D2:	L_2,:DIV;(N2*M1)/M2DivRet2:	T_AC1;	L_N1-T;	(uncorrected low order result)-(second correction)	AC0_L,ALUCY;5		if zero carry, then decrease high order part too!1,2,Dec,NoDec;!1,2,Norm,D1;	L_M1,:Dec;6Dec:	L_M1-1;7	M1_L;8NoDec:	NOP,SH<0;9	get high order part of answer (could be unnormalized from either DSZ above)	T_AC0,:Norm;10	!1,2,Norm,D1;Norm:	M1_L MLSH 1;11	L_E1-1;	decrement exponent to account for shift	L _ LREG - 1,TASK; -2 BECAUSE OF SIGN	E1_L;	L_AC0,TASK;	N1_L LSH 1,:STORE;D1:	L_AC0,TASK;	N1_L,:STORE;;----------------------------------------------------;floating point add and subtract;----------------------------------------------------PLUS:	L_ONE, TASK, :SETUP;MINUS:	L_2, TASK, :SETUP;SETUPX2:	T _ ONE; CHANGE SIGN AND ADD	L _ E2 XOR T, TASK;	E2 _ L;;SETUPX1:	T _ 100000; OFFSET FOR EXPONENTS IN THIS ROUTINE	L _ E1 + T; OFFSET FIRST EXPONENT	E1X _ L RSH 1; GET OFFSET EXPONENT	L _ E2 + T, TASK; OFFSET SECOND EXPONENT	E2X _ L RSH 1; GET OFFSET EXPONENT		;Preshift arguments until they match	T_M1;	mantissa zero check	L_M2 AND T;	SINK_LREG,BUS=0;!1,2,Sh,NoShz;	T_E1X,:Sh;Sh:	L_E2X-T;	if exponents are the same, no shift either	SINK_LREG,BUS=0;!1,2,Sh1,NoSh;!1,2,E1lsE2,E1grE2;	ShiftCount_L,:Sh1;Sh1:	TASK,SH<0;	NOP,:E1lsE2;	E1lsE2:	T _ EXPMSK;	E1 _ E2 WITH SIGN PRESERVED	L _ E2 AND T;	we'll shift until exponent matches E2	T _ 0 + 1; GET A ONE	T _ E1.T; GET SIGN	L _ LREG OR T; PUT E1 SIGN WITH E2 VALUE	E1 _ L; AND STORE	T_ShiftCount;	L_37-T;	TASK,SH<0;	37 is max number of shifts, if SH ge 0 then fix!1,2,NoFix,Fix;!1,2,More,Shifted;	NOP,:NoFix;NoFix:	L_T_M1;More:	M1_L RSH 1;	L_N1,TASK;	N1_L MRSH 1;	NOP;	ALU_SReg after TASK;	L_ShiftCount-1;	ShiftCount_L,SH=0;	L_T_M1,:More;Fix:	L_0;	set both words of mantissa1 to 0	M1_L,TASK;	N1_L,:EndShift;Shifted:	NOP,:EndShift;NoSh:		NOP,:EndShift;!1,2,ExpOK,ExpWrite;NoShz:	SINK_M1,BUS=0;	if first arg is zero, then E1X_E2X	L_E2X,TASK,:ExpOK;ExpWrite:	E1X_L;	L _ E2;	E1 _ L;ExpOK:	NOP,:EndShift;E1grE2:	T_ShiftCount;	actually, negative shift count	L_37+T;	TASK,SH<0;!1,2,NoFix1,Fix1;!1,2,More1,Shifted1;	NOP,:NoFix1;NoFix1:	L_T_M2;More1:	M2_L RSH 1;	L_N2,TASK;	N2_L MRSH 1;	NOP;	ALU_SReg after TASK;	L_ShiftCount+1;	ShiftCount_L,SH=0;	L_T_M2,:More1;Fix1:	L_0;	M2_L,TASK;	N2_L,:EndShift;Shifted1:	NOP,:EndShift;;end of PRESHIFT;now: ADD1 is Add(+ +), Add(- -), Sub(+ -), Sub(- +);and  ADD2 is Add(+ -), Add(- +), Sub(+ +), Sub(- -); so: ADD1 if (S1 XOR S2) EVEN, and ADD2 otherwiseEndShift: T_E1;	L_E2+T;	EVEN if ADD1, ODD if ADD2	SINK _ LREG, BUSODD, TASK;!1,2,ADD1,ADD2;	NOP,:ADD1;ADD1:	T_N2;	L_N1+T;	N1_L,ALUCY;!1,2,A1NoCarry,A1Carry;	T_M1,:A1NoCarry;A1Carry:	L_M2+T+1,:A1Store;A1NoCarry:	L_M2+T;A1Store:	M1_L,ALUCY,TASK;!1,2,A1xNoCarry,A1xCarry;	NOP,:A1xNoCarry;A1xCarry:	T_L_M1;	post shift	M1_L RSH 1;	L_N1,TASK;	N1_L MRSH 1;	T_100000;	L_M1 OR T;	high order bit should have been shifted in	M1_L;	L_E1+1;	L_LREG+1,TASK; BECAUSE EXPONENT SHIFTED LEFT ONE BIT	E1_L,:STORE;A1xNoCarry:	NOP,:STORE;ADD2:	T_N2;	L_N1-T;	N1_L,ALUCY;	low order result!1,2,Add2NoCarry,Add2Carry;	T_M2,:Add2NoCarry;Add2NoCarry:	L_M1-T-1,:Add2C;	no carry, do one's complement subtractAdd2Carry:	L_M1-T;		carry, do two's complement subtractAdd2C:	M1_L,ALUCY;!1,2,Add2Sign,Add2NoSign;!1,2,LowNonZero,LowZero;	L_0,:Add2Sign;	if no carry, sign changed!!!!Add2Sign:	T_N1,BUS=0;	double length negate starts here	L_0-T,:LowNonZero;LowNonZero:N1_L,T_0-1;	L_M1 XOR T,:Add2Cx;	complementLowZero:	T_M1;	L_0-T;	negate (note that N1 is already 0, so no need to update it)Add2Cx:	M1_L,T_0+1;	L_E1 XOR T,TASK;	complement sign	E1_L;	L_0;Add2NoSign:	ShiftCount_L;	L_M1,BUS=0;!1,2,HiNonZero,HiZero;	NOP,:HiNonZero;HiNonZero:	TASK,SH<0;!1,2,Add2Norm,Add2NoNorm;	NOP,:Add2Norm;Add2Norm:	L_N1;	NOP,SH<0;!1,2,Add2NoCarryL,Add2CarryL;	N1_L LSH 1,T_0,:Add2NoCarryL;Add2CarryL:	T_ALLONES;Add2NoCarryL:	L_M1;	M1_L MLSH 1;	L_ShiftCount+1,TASK;	ShiftCount_L;	L_M1,:HiNonZero;Add2NoNorm:T_ShiftCount;	L_E1-T;	E1_L;	L_E1-T,TASK;	E1_L,:STORE;HiZero:	L_N1,BUS=0;;!1,2,LowNonZero1,LowZero1;	defined above	M1_L,L_0,:LowNonZero1;LowNonZero1:	N1_L;	zero out low order	L_20,TASK;	ShiftCount_L;	16 shifts done like wildfire	L_M1,:HiNonZero;LowZero1:E1_L;	M1_L,TASK;	N1_L,:STORE;STORE: MAR _ ANSADDR;	TASK;	MD _ E1;	MAR _ L _ ANSADDR + 1;	ANSADDR _ L, TASK;	MD _ M1;	MAR _ ANSADDR + 1;	TASK;	MD _ N1;	L _ ANSOOP, SWMODE;PRIMRET:	AC0 _ L, ESRB _ 0, :PRIMRET; AND RETURN TO THE INTERPRETER WITH OOP IN AC0 = ARG1FAIL:	ESRB _ 0;	SWMODE, :PRIMFAIL;DIVFAIL:	L _ ANSOOP; GET FLOAT FOR ANSWER	ARG1 _ L, ESRB _ 0; AND SAVE	L _ RAMRET5, TASK;	RAMRETURN _ L, SWMODE; RAM RETURN ADDRESSREF:	L _ RAMXODD, :REF; ODD RETURN FOR REFD - THROW AWAY UNUSED FLOATRAMX5:	SWMODE;PRIMFAIL:	:PRIMFAIL;	LET THE SMALLTALK METHOD DO IT (LABEL USED ONLY IN RAM0)DUMP:	T _ OOP00; ********DEBUG********	L _ LREG OR T, SWMODE, :PRIMRET; ********DEBUG********(500)\f8