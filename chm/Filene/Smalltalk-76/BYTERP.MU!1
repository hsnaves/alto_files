;;		BYTERP.MU;			NOVACALL VERSION I December 13, 1977  4:07 PM;#DEFS20.MU;	DEFINITIONS AND CONSTANTS FOR ALTOS;;	/* REGISTERS;///	RED ALERT....RED ALERT ///;/// BEFORE CHANGING ANY REGISTER ASSIGNMENTS CONSULT;/// THE SACRED TEXTS (SMALL.OPS) SO THAT YE MAY;/// CONTINUE TO SPEAK THE TRUTH AND LIVE IN HARMONY;/// WITH THE VIRTUAL MACHINE (I.E. THE NOVACODE KNOWS;/// THE NUMBERS OF CERTAIN OF THE REGISTERS ALL DULY;/// NOTED IN AN APPROPRIATELY TITLED SECTION OF SMALL.OPS;/// AND CHANGES SHOULD BE REFLECTED THERE);/// RED ALERT....RED ALRET ///$AC3		$R0;$PCB		$R0;	**BYTE PC IN CODE$AC2		$R1;$AC1		$R2;$STACKP	$R2;	**INDEX OF TOP OF STACK$AC0		$R3;$ARG1		$R3;	<ALLOC(LITMSGS,INTN)>**ARGUMENT TO OOZE ROUTINES$NWW		$R4;$TEMP1	$R5;	<SUBS,LITMSGS,ALLOC(LITMSGS,INTN)>$CYRET	$R5;$PC		$R6;$XREG		$R7; <PMAP>$RETN0	$R10;	<PMAP,;	 HASH(IVL,ILNG,REF,SUBS,ALLOC(LITMSGS,INTN),LITMSGS)>$COREBASE	$R14;	FIRST CORE LOCATION (MUST BE CLASS CONTEXT)$CYCOUT2	$R15;	<SUBS,ALLOC>$MODE		$R16;	MODE MUST BE A R REG BECAUSE OF BUS=0 TIMING PROBLEM;			AT REFX10:;			MODE=0 IN NORMAL EXECUTION;			MODE=1 WHILE DOING SMASH OPERATION$AOOP		$R17;	<LITMSGS,SUBS>OOP OF BASE REGISTER A$CYCOUT	$R35;;	<NEXTBYTE,JMPS,SUBS,LITMSGS,MAPCODE(RETURN),GCLASS(IVAL)>$RHO		$R35;;	<HASH(IVAL,ILONG,REF,SUBS,ALLOC(LITMSGS,INTN),LITMSGS)>$RESIDUE	$R36;;	<HASH(IVAL,ILONG,REF,SUBS,ALLOC(LITMSGS,INTN),LITMSGS)>;---------------	REGS ABOVE ARE VOLATILE W/RESPECT TO NOVA EMULATOR$LREG		$R40;	RAM'S COPY OF LREG$TEMP2	$R41; <REF,ALLOC(LITMSGS,INTN),LITMSGS,ARITHOPS,SUBS>$TEMP4	$R42;	<SUBS>$TEMP3	$R43;	<ALLOC(LITMSGS,INTN),LITMSGS,ARITHOPS,SUBS,REF>$NAMES	$R44;	<LITMSGS,SUBS>$ROTA		$R45;	<HASH(IVAL,ILONG,REF,SUBS,LITMSGS,ALLOC(...,INTN))>$ROT0		$R46;	<HASH(IVAL,ILONG,REF,SUBS,LITMSGS,ALLOC(...,INTN))>$ROT1		$R47;	<HASH(IVAL,ILONG,REF,SUBS,LITMSGS,ALLOC(...,INTN))>$RPC		$R50;	<HASH(IVAL,ILONG,REF,SUBS,LITMSGS,ALLOC(...,INTN))>$RETN1	$R51;	<GCLASS(IVAL(LITMSGS),SUBS),ILONG(SUBS),REF,ALLOC(...,INTN),REGMAP>;---------------	REGS ABOVE ARE VOLATILE W/RESPECT TO BITBLT$ACORE	$R52;	CORE ADDRESS OF BASE REGISTER A$FATHER	$R53;	RAM STATE -  FATHER (NIL WHEN NOT IN RECUF)$MINAT	$R54;	RAM STATE - ATOM BOUND$PMBASE	$R55;	RAM STATE - PMAP CORE ADDR$ROTBASE 	$R56;	RAM STATE - ROT CORE ADDR;---------------	REGS BELOW SAVE STATE ACROSS NOVACALL$SAVR1	$R57;	**DOUBLE NAME* <REF,INTN>$WRAPFL	$R57;	**DOUBLE NAME* <LITMSGS>$AREC		$R60;	ACTIVATION CORE ADDRESS$SAVPC	$R61;$SAVDISP	$R62;$BCORE	$R63;	CORE ADDRESS OF BASE REGISTER B$SAVR0	$R64;	<HASH(IVAL,ILONG,REF,SUBS,ALLOC(LITMSGS,INTN),LITMSGS)>;			SAVE RETN0 ACROSS FAULTS$BOOP		$R65;	OOP OF BASE REGISTER B$LOCFRAME	$R66;	**LITERAL VECTOR CORE ADDRESS$NAME		$R67; **DOUBLE NAME* <LITMSGS,SUBS>$CNT		$R67; **DOUBLE NAME* <SUBS>$TOP		$R70;	OOP ON TOP OF STACK$CADDR	$R71;$TFRAME	$R72;	TEMPORARY FRAME CORE ADDRESS$SELF		$R73;	ACTIVE INSTANCE CORE ADDRESS$SUPMOD	$R74;	-1 EXCEPT WHEN ACCESSING SUPERCLASS$RETN2	$R75;	<IVAL(SUBS,LITMSGS),LITMSGS,INTN>$CTXT		$R76;	OOP OF CURRENT CONTEXT$SAVSP	$R77;	STACK POINTER SAVER;;	/* CONSTANTS$RCT1BIT	$20;	REFCT 1-BIT$RCT8BIT	$200;	REFCT 8-BIT$RCTM1BIT	$177760;	MINUS REFCT 1-BIT$ROTMSK	$3777;	ROT SIZE MASK$ROT0EM	$360;	ROT EMPTY PATTERN$ROT0ND	$2;	ROT0 FOR NEW, DIRTY, REF=1, NOT IMMED$RCTMSK	$360;	REFCT MASK - MORE IMBEDDED IN REFI/REFD$HKRMSK	$174000;	ROT HKR BIT MASK$RPCBIT	$400;	LOW BIT OF ROT RPC FIELD FOR INC-IN-PLACE$IMMBIT	$4;	IMMEDIATE BIT MASK FOR ROT0$MSINT	$174000;$OOP00	$176000;$M2001	$175777;$12		$12;$500		$500;$RESRPC	$177400;	ROT HKR-RPC BIT MASK$ROTABASEM1	$177777;	RAM BASE FOR BASEREG ROTA$OOPBASEM1	$1777;	RAM BASE FOR BASEREG OOP$CPTMSK	$100;		MASK FOR IS-POINTER IN PMAP$ISCMSK	$37;		MASK FOR INSTANCE SIZE IN PMAP$RCIMSK	$177400;		REAL CLASS PART OF PMAP$SENDERF	$L0,12000,100;	CONSTANT 0 IS SUPER-SPECIAL;$INSTF	$1;$CODEF	$3;$TFRAMEF	$4;	***WARNING BEFORE CHANGING SEE PUTX4 IN LITMSGS$PCF		$5;	***WARNING PCF AND STACKPF MUST BE TOGETHER$STACKPF	$6;	***WARNING PCF AND STACKPF MUST BE TOGETHER$PMRETI	$L0,12000,100;	CONSTANT 0 IS SUPER-SPECIAL;$HFRETI	$1;$EIRETI	$2;$IJRETI	$3;$CASCME	$177774;;		(CoreAddressofSmalltalkConstantsMinusEight = 4-8 =-4)$OCTV		$24;			ISC OF FIRST OCTAVE$VARCLS	$100000;		OOP WHERE VAR-LEN CLASSES START$NUMCLS	$4;			NUMBER CLASS OOP$OBJCLS	$27;			NIL CLASS OOP$SPRCLSF	$5;			INDEX OF SUPERCLASS FIELD$MDICTF	$3;			INDEX OF MESSAGE DICTIONARY$CLFREE	$10;			OFFSET OF FREELISTHEAD IN CLASSES$CLFREE2	$21;			CLFREE OF SECOND CLASS$CLFREE3MT	$31;			CLFREE OF THIRD CLASS MINUS TWO$STMCLS	$10;$CNTXCLS	$2;			OOP OF CLASS CONTEXT (NOTE: SEE "BYTE:")$INTCLS	$12;$VECCLS	$200;$NEGVECCLS	$177600;		(-200)$NEGSTRCLS	$177577;		(-201)$FALSEOOP	$600;$TRUEOOP	$601;$ERRPRG	$3;			ADDRESS OF OOP OF ERROR METHOD$SVSPLOC	$77;$PRIMTABLOC	$100;$SELFLOC	$101;;;	/* GLOBAL LABEL ALLIGNMENTS */;	SO WE CAN USE CYCLE IN THE ROM!3,4,,HFRET,EIRET,IJRET;	******THIS MUST REMAIN FIRST!7,1,STRT;			******THIS MUST REMAIN SECOND FOR REG WRITER!165,1,L5;!22,1,RAMCYCX;;!637,1,TRAPX10;	FIRST BUILD ONLY!645,1,TRAPX13;	SECOND BUILD ONLY!37,1,TRAPX20;	>= X20!20,1,START;		BOTH BUILDS, THANK GOD!1,1,TRAPOP;		SO THAT OR1 WONT AFFECT :TRAPOP;;********DISPATCH ON BYTE TYPE********%360,377,17,IVARS,TVARS,LVARS,LVARS2,ILVARS,ILVARS2,ILVARS3,AVARS,	PRIMOPS,SJMPS,LJMPS,ATRAPMSGS,OTRAPMSGS,LITMSGS,LITMSGS2,LITMSGS3;;;********RETURNS FROM NOVA********!7,10,OVRET,FIRET,FLTRET,ALLOCRET,PRIMFAIL,SNDMSG,SUPRET,PRIMRET;;;********ENTRIES FOR RMASK********%360,377,17,RMASK,RM1,RM2,RM3,RM4,RM5,RM6,RM7,RM8,RM9,RM10,RM11,RM12,RM13,	RM14,RM15;;;********RETURNS FOR RMASK********!7,10,WHICHOP,,,,,RMX5,,RMX7;;;********RETURNS FOR REF AND REFCK********!17,20,REFX0,REFX1,,REFX3,REFX4,REFX5,REFX6,REFX7,REFX10,	REFX11,REFX12,REFX13,,,,;!17,1,REFA;;	!3,1,ILONG;		BECAUSE OF RETURNS FROM TST IN SUBS	!3,1,HASH;		BECAUSE OF RETURNS FROM TST IN SUBS;;********RETURNS FOR HASH********;CALL 0 CAN FAIL TO HFAIL0!1,2,FAULT,HFAIL0;;!37,40,HSHX0,HSHX1,HSHX2,HSHX3,,HSHX5,HSHX6,,	HSHX10,HSHX11,HSHX12,HSHX13,HSHX14,HSHX15,HSHX16,HSHX17,	HSHX20,HSHX21,HSHX22,,,HSHX25,,HSHX27,	HSHX30,HSHX31,HSHX32,,HSHX34,HSHX35,,;;;********RETURNS FOR IVAL********!17,20,IVALX0,IVALX1,IVALX2,IVALX3,IVALX4,IVALX5,IVALX6,IVALX7,IVALX10,,,,,,,;;;********RETURNS FOR INTN********!3,4,INTNX0,INTNX1,INTNX2,;;	!1,2,PMAP,GCNIL;;********RETURNS FOR GCLASS********!7,10,GCLASSX0,GCLASSX1,GCLASSX2,GCLASSX3,GCLASSX4,GCLASSX5,,;!1,1,GCLASS;;;********RETURNS FOR PMAP********!3,4,PMAPX0,PMAPX1,PMAPX2,PMAPX3;;	[ILONG,GCLASS,REF,QFINST];;********RETURNS FOR ILONG********!3,4,ILONGX0,ILONGX1,ILONGX2,ILONGX3;;;********RETURNS FOR ALLOC********!3,4,ALLOCX0,ALLOCX1,ALLOCX2,;;;********RETURNS FOR PTNXT********!7,10,PUTX0,PUTX1,PUTX2,PUTX3,PUTX4,,,;;;********RETURNS FOR POPTOP********!7,10,POPTX0,POPTX1,POPTX2,POPTX3,POPTX4,,,;;;********RETURNS FOR TST********!7,10,TSTX0,TSTX1,TSTX2,TSTX3,TSTX4,,,;;;********RETURNS FOR STASH********!1,2,STASHX0,STASHX1;;;********RETURNS FOR MAPCODE********!1,2,MCX0,MCX1;;;********MISC. DECLARATIONS********!1,2,NOTNIL,NOTIND;!1,2,APPLY,HIT2;;;;;	***********************************;	*  BYTECODE INTERPRETER MICROCODE *;	***********************************;;	/* ENTER RAM */;TRAPX10: T_ 17, :TRPX;TRAPX13: T_ 17, :TRPX;	(IR_LREG FASTER??)	(NEW ALTOS)TRAPX20: T_ 17, :TRPX;	(IR_LREG FASTER??)	(NEW ALTOS)TRPX:		L_ XREG.T;		SINK_ LREG, TASK, BUS, :WHICHOP;!17,20,EXTRACT,INJECT,REFCT,NOVATRPS,SUNDRY,,,,,,BYTERP,RETVAL,,,NOVARET,;WHICHOP:	:EXTRACT;	DISPATCH ON 16 OP CODESNOVATRPS:	:TRAPOP;;!17,20,LROTB,HASHT,,,SNAT,,,,,,,,,,,;SUNDRY:	SINK_ DISP, BUS, TASK;		:LROTB;		72000 OPS DISPATCH HERE;;		BYTERP-	START BYTECODE INTERPRETATION;RETVAL:	L_ ONE, :SPC;BYTERP:	L_ ALLONES;		SUPMOD_ L;		AOOP_ L, TASK;		BOOP_ L;		L_ 0;		MODE_ L, :NEXTBYTE;;;		NEXTBYTE-	INTERPRET NEXT BYTECODE;;	!1,2,DOINT,NOINT;	!1,2,OUTANDIN,NOINT1;	!1,1,OAI1;	!1,2,LBYT,RBYT;NEXTBYTE:	L_ NWW, BUS=0;				CHECK FOR INTERRUPTS		T_ MAR_ CADDR, SH<0, :DOINT;		FETCH INSTR WORDDOINT:	 L_ PCB+1, BUSODD, :OUTANDIN;OUTANDIN:	SINK_ MD, :OAI1;OAI1:		L_ 2, :SPC;;NOINT:	 L_ PCB+1, BUSODD, :NOINT1;		TEST WHICH BYTENOINT1:	 PCB_ L, L_ 0+T+1, :LBYT;;LBYT:		 T_ 177400;				LEFT BYTE		L_ MD.T, TASK;			MASK		CYCOUT_ L LCY 8, :DOSYL;	(TASK HAPPENS HERE) SWAP;RBYT:		 T_ 377;				RIGHT BYTE		T_ MD.T;				MASK		CADDR_ L, L_ T, TASK;		STEP WORD ADDR		CYCOUT_ L, :DOSYL;		(TASK HAPPENS HERE) ;;	/* DISPATCH ON HIGH 4 BITS */	!1,2,DISPATCH,NOMSG;DOSYL:	IR_ CYCOUT;DISPATCH:	SINK_ DISP, SINK_ disp.377, BUS;	DISPATCH ON HIGH 4 BITS		L_ T_ DISP, SINK_ X17, :IVARS;	L_ T_ LOW 4 BITS;;;	/* LOAD DATA FOR STACK */	!1,2,LCONST,LMEM;IVARS:	L_ SELF+T, :LMEM;			LOAD REL TO SELF;TVARS:	L_ TFRAME+T, :LMEM;			LOAD REL TO TEMPFRAME;LVARS:	L_ LOCFRAME+T, :LMEM;			LOAD REL TO LOCALFRAMELVARS2:	T_ 17+T+1, :LVARS;;ILVARS:	MAR_ LOCFRAME+T;				LOAD INDIRECT REL TO LOCALFRAME		 T_ 5;		L_ MD, :HSH30L;	;// HASH INDIRECT LITERAL OBJECT REFERENCE. DIRTY //HSHX35:	:LMEM;ILVARS2:	T_ 17+T+1, :ILVARS;ILVARS3:	T_ 37+T+1, :ILVARS;;AVARS:	SINK_ DISP, SINK_ lgm10, BUS=0;	LOAD REL TO AREC		L_ AREC+T, :LCONST;			OR LOAD CONSTANTS;LCONST:	L_ CASCME+T, :LMEM;			;(CoreAddressofSmalltalkConstantsMinusEight = 3-8 =-5);	!1,2,PULL,PUSH;					Data TO Stack or Stack TO DataLMEM:		SINK_ MODE, BUS=0, TASK;		:PULL;PUSH:		MAR_ LREG;		 L_ STACKP+1, :STSTAK;;;	SHOVE-	REPLACE TOP OF STACK WITH L (SAME AS POP AND PUSH);SHOVE:	TOP_ L;		T_ 4, :REFCKL;;;	STSTAK-	MEMORY PENDING: NEW OOP TO BE STORED ON STACK;			L: INDEX ON STACK TO STORE;;//SPEED UP//	!1,2,DOREFI,NOREFI;;//SPEED UP//STSTAK:	 STACKP_ L;;//SPEED UP//		 T_ MINAT;;//SPEED UP//		L_ MD-T, T_ MD;;//SPEED UP//		L_ T, ALUCY;;//SPEED UP//		TOP_ L, TASK, :DOREFI;;//SPEED UP//DOREFI:	ARG1_ L;;//SPEED UP//		L_ 4, TASK, :REF;;//SPEED UP//REFX4:	T_ STACKP, :STOR;;//SPEED UP//NOREFI:	:REFX4;STSTAK:	 STACKP_ L;		L_ MD;		TOP_ L;		T_ 4, :REFCKL;REFX4:	T_ STACKP, :STOR;;;	STOR-		T: NEW STACK POINTER;			TOP: NEW OOP;			TEMPFRAME[STACKP_T]_TOP;;//SPEED UP//	!1,2,DOREFD,NOREFD;;//SPEED UP//STOR:		L_ MAR_ TFRAME+T;;//SPEED UP//		 ARG1_ L, L_ T;;//SPEED UP//		 STACKP_ L;;//SPEED UP//		 T_ MINAT;;//SPEED UP//		L_ MD-T, T_ MD;;//SPEED UP//		MAR_ ARG1;;//SPEED UP//		 L_ T, ALUCY;			CHECK FOR NEED TO REFD;//SPEED UP//		 ARG1_ L, :DOREFD, TASK;;//SPEED UP//;;//SPEED UP//;	/* REFD AFTER STORING;//SPEED UP//DOREFD:	MD_ TOP;				(TASK HAPPENS HERE);//SPEED UP//		L_ 3, TASK, :REF;;//SPEED UP//REFX3:	L_ 0, TASK;;//SPEED UP//		SUPMOD_ L, :NEXTBYTE;;//SPEED UP//NOREFD:	MD_ TOP, :REFX3;STOR:		L_ MAR_ TFRAME+T;		 ARG1_ L, L_ T;		 STACKP_ L;		L_ MD;		MAR_ ARG1;		 T_ 3;		MD_ TOP, :REFCKL;REFX3:	:BYTERP;;;	BOXSTOR-		L_ VALUE;				STORE TOP_ BOXED VALUE;BOXSTOR:	T_ 0, :INTNL;INTNX0:	TOP_ L, :REFX4;;;;	**** THE PRIMITIVE OPERATIONS;!17,20,SMASHPOP,SMASH,POP,RETURN,REND,CURRENT,SUPER,SENDAGAIN,,,,,,,,;;/////***** ATTENTION!!! RETURN AND END MUST REMAIN ODD AND EVEN*****/////;/////***** BECAUSE OF DISPATCH OUT OF DORETURN. RED ALERT      *****/////PRIMOPS:	SINK_ DISP, SINK_ X17, BUS, TASK;		:SMASHPOP;;;	SMSHPOP:	TOP: DATA TO BE STORED;			STORE L INTO LOCATION DESCRIBED BY NEXT BYTE;			AND POP STACK;SMASHPOP:	L_ STACKP-1;		STACKP_ L, :SMASH;;;	SMASH:	TOP: DATA TO BE STORED;			STORE L INTO LOCATION DESCRIBED BY NEXT BYTE;SMASH:	L_ ONE;		MODE_ L;		T_ MAR_ CADDR, :NOINT;		FETCH INSTR WORD;;	PULL(Stack TO Data):;			LREG: ADDRESS OF DATA;			TOP: NEW OOP TO BE STORED IN DATA;	!1,2,GOON,RISUBEND;PULL:		MAR_ L_ LREG;			ADDRESS LOC TO BE SMASHED		 TEMP3_ L;				TEMP3_ ADDRESS OF LOC TO BE SMASHED		L_ MD;				L_ OOP BEING DESTROYED		MAR_ TEMP3;				ADDRESS LOC TO BE SMASHED		 T_ 11;		MD_ TOP, :REFCKL;			STORE NEW OOP & REFD OLD OOPREFX11:	L_ TOP;		T_ 10, :REFCKL;			REFI NEW OOPREFX10:	SINK_ MODE, BUS=0;		L_ 0, :GOON;GOON:		MODE_ L, :NEXTBYTE;		(JUMPED TO FROM NOOP:);;	POP-		POP TOP VALUE OFF STACK;POP:		L_ STACKP-1, TASK;		STACKP_ L, :NEXTBYTE;;;	RETURN-	RETURN CONTROL TO SENDER;	!1,2,ENDEND,RETURNEND;	!1,2,LP1,LP2;	!1,2,DOHASH,NOHASH;RETURN:	T_ SENDERF;		MAR_ L_ AREC+T, :DORETURN;	ADDRESS SENDERRETURNEND:	L_ CTXT;		T_ 5, :HASHL;			L_ CORE ADD OF CURRENT AREC	;// HASH CURRENT CONTEXT. DIRTY //HSHX5:	AREC_ L;				AREC_ CORE ADD OF CURR AREC		T_ PCF;DOSP:		MAR_ L_ AREC+T;			ADDRESS PC/SP FIELD OF AREC		 L_ PCF-T;				TEST IF IT WAS PC OR SP		 T_ OOP00;		L_ MD-T, SH<0;			IVAL PC/SP		TASK, :LP1;				[LP1,LP2]LP1:		PCB_ L;				PCB_ IVAL[AREC[PC]]		T_ STACKPF, :DOSP;LP2:		STACKP_ L;				STACKP_ IVAL[AREC[SP]]		MAR_ AREC+1;		 T_ MINAT;		L_ MD-T, T_ MD;		L_ T, ALUCY;		ARG1_ L, :DOHASH;		[DOHASH,NOHASH]DOHASH:	L_ ONE, TASK, :HASH;		L_ C.A.[AREC[INST]]NOHASH:	L_ ALLONES, TASK, :HSHX1;	;// HASH INSTANCE. DIRTY //HSHX1:	SELF_ L;				SELF_ C.A.[INST],		T_ 2, :GETTPO;			L_ T_ C.A.[AREC[METHOD]]	;// HASH METHOD. NO DIRTY //HSHX2:	L_ 0, :MAPCODE;			GENERATE LOCFRAME AND CADDRMCX0:		T_ 3, :GETTPO;			L_ C.A.[AREC[TFRAME]]	;// HASH TEMPFRAME. DIRTY //HSHX3:	TFRAME_ L;				TFRAME_ C.A.[AREC[TFRAME]]		L_ NAME;		T_ 7, :REFCKL;			ZAP MEREFX7:	T_ STACKP+1, :STOR;		AND PUSH TOP OF OLD STACK ON NEW;;		GETTPO		L_ COREADD OF FIELD #(T+1) IN AREC;GETTPO:		MAR_ AREC+T+1;		 NOP;		L_ MD, :HASHL;;;	REND-		RETURN CONTROL TO CALLER (I.E. RETURN FROM EVAL);REND:		T_ STACKP-1;		MAR_ L_ TFRAME+T, :DORETURN;	ADDRESS CALLERENDEND:	L_ 4, TASK;		TEMP2_ L;		T_ ONE;		L_ STACKP-T-1;		STACKP_ L, L_ T, TASK, :STASH;STASHX1:	:RETURNEND;;;	DORETURN	PERFORM AN ACTUAL CONTROL RETURN;			L and MEMORY PENDING= ADDRESS OF CONTEXT TO RETURN TO;DORETURN:	 TEMP1_ L;		 L_ CTXT;		 NAME_ L; 				NAME_ CURRENT CONTEXT		L_ MD;		MAR_ TEMP1;		 CTXT_ L, TASK;			CTXT_ MY SENDER		MD_ ALLONES;			NIL MY SENDER		T_ STACKP;		MAR_ TFRAME+T;			ADDRESS VALUE ON STACK		 SINK_ DISP, BUSODD;		MD_ ALLONES, :ENDEND;		NIL REF TO VALUE (REFI);;	CURRENT-	PUSH CURRENT CONTEXT;CURRENT:	L_ STACKP+1, TASK;		STACKP_ L;		L_ CTXT, :SHOVE;;;	SUPER;SUPER:	T_ 26, :NCPF;			NOVACALL 33, CALLFLT HAS NCPFSUPRET:	T_ MAR_ CADDR, :NOINT;		FETCH INSTR WORD;;	SENDAGAIN;SENDAGAIN:	:SNDMSG;;;	STOP;;STOP:		L_ 0, :SPC;;	!1,2,BFP,DOJMP;	!1,2,EVENPCB,ODDPCB;	!1,2,EVENINC,ODDINC;	!1,2,PJMP,NJMP;	!1,2,NOTFALSE,ISFALSE;	!1,1,INCADDR;	!1,2,LBYTB,RBYTB;;;	SJMPS-	CONTROL TRANSFER OPERATIONS OF ONE TO EIGHT;SJMPS:	L_ DISP+1, SINK_ M7, TASK, :JMPCMN;;;	LJMPS-	CONTROL TRANSFER OPERATIONS OF -1024 TO 1023;LJMPS:	MAR_ T_ CADDR;			FETCH NEXT BYTE		 L_ PCB+1, BUSODD;		TEST WHICH BYTE		 PCB_ L, L_ 0+T+1, :LBYTB;;LBYTB:	 T_ 177400;				LEFT BYTE		L_ MD.T, TASK;			MASK		CYCOUT_ L LCY 8, :CJMP;	SWAP, CYCOUT: OFFSET;RBYTB:	 T_ 377;				RIGHT BYTE		T_ MD.T;				MASK		CADDR_ L, L_ T, TASK;		STEP WORD ADDR		CYCOUT_ L, :CJMP;		CYCOUT: OFFSET;CJMP:		T_ CYCOUT;				T: OFFSET		L_ DISP, SINK_ M7;		L: BIAS INDEX		CYCOUT_ L LCY 8;			L: HI-BIAS(256*B.I.=TRUE BIAS+02000)		T_ CYCOUT+T+1;			T: HI-BIAS+OFFSET+1		L_ M2001+T, TASK;		L: TRUE BIAS+OFFSETJMPCMN:	ARG1_ L;				ARG1: NUMBER OF BYTES TO BE SKIPPED		L_ DISP, SINK_ lgm10, BUS=0;		T_ FALSEOOP, :BFP;DOJMP:	T_ ARG1;		L_ PCB+T;					L_ NEW PCB		PCB_ L, L_ T;				PCB_ NEW PCB, L_ BYTES SKIPED		ARG1_ L, SH<0;				ARG1_ BYTES SKIPED, TEST NEG		T_ 0, :PJMP;NJMP:		T_ ONE, :PJMP;				NEG JUMP, SET SIGN FOR RSHIFTPJMP:		SINK_ PCB, BUSODD;			TEST NEW PCB IS LEFT/RIGHT		SINK_ LREG, BUSODD, TASK, :EVENPCB;TEST BYTES SKIPED IS ODD/EVENEVENPCB:	CYCOUT_ L MRSH 1, :EVENINC;		CYCOUT_ WORDS SKIPEDODDPCB:	CYCOUT_ L MRSH 1, :INCADDR;		CYCOUT_ WORDS SKIPEDEVENINC:	:INCADDR;					LEFT BYTE & EVEN SKIP, NO INCODDINC:	T_ CYCOUT+1, :INCADDR1;		LEFT BYTE & ODD SKIP, INC CADDRINCADDR:	T_ CYCOUT;					RIGHT BYTE, NO INCINCADDR1:	L_ CADDR+T, TASK;		CADDR_ L, :NEXTBYTE;			CADDR_ CORE ADDRESS OF NEXT BYTE;BFP:		L_ TOP-T;		L_ STACKP-1, SH=0, TASK;		TEST TOP OF STACK IS FALSE		STACKP_ L, :NOTFALSE;			POP STACKISFALSE:	:DOJMP;NOTFALSE:	:NEXTBYTE;;;;	**** THE 16 TRAPPED ARITHMETIC MESSAGES;	!17,20,ADD,SUB,LES,GTR,LEQ,GEQ,EQL,NEQ,,,,,,,,;	!1,2,AUNIMP,AIMP;	!1,2,YESISFLS,YESISTRU;	!1,2,FALS,YTRUE;	!1,2,TRUE,YFALS;	!1,2,MBTRUA,TRULE;	!1,2,MBTRUB,TRUGE;ATRAPMSGS:	SINK_ DISP, SINK_ lgm10, BUS=0;		L_ STACKP, :AUNIMP;AUNIMP:	SAVSP_ L, :APPLY;			STASH STACKP IN REGAIMP:		SAVSP_ L;				STASH STACKP IN REG		T_ 0;		L_ TOP, :IVALL;IVALX0:	TEMP3_ L;		L_ 4, TASK, :POPTOP;POPTX4:	T_ ONE, :IVALL;			L_ T_ VALUE OF ARGIVALX1:	TEMP2_ L;		T_ TEMP2;		SINK_ DISP, SINK_ X17, BUS;		L_ TEMP3 XOR T, :ADD;;ADD:		L_ TEMP3+T, :BOXSTOR;SUB:		L_ TEMP3-T, :BOXSTOR;LES:		L_ TEMP3-T, SH<0, :OCOM;GTR:		T_ TEMP3;		L_ TEMP2-T, SH<0, :OCOM;EQL:		SH=0, :YESISTRU;NEQ:		SH=0, :YESISFLS;LEQ:		SH=0;		:MBTRUA;MBTRUA:	:LES;TRULE:	:SHVSELF;;GEQ:		SH=0;		:MBTRUB;MBTRUB:	:GTR;TRUGE:	:SHVSELF;;OCOM:		ALUCY, TASK, :YESISFLS;YESISFLS:	:TRUE;TRUE:		:SHVSELF;YFALS:	:SHVFALS;YESISTRU:	:FALS;FALS:		:SHVFALS;YTRUE:	:SHVSELF;SHVFALS:	L_ FALSEOOP, :SHOVE;SHVSELF:	L_ TOP, :SHOVE;;;;	**** OTHER MESSAGES TRAPPED BY THE MICROCODE INTERPRETER;	!17,20,LBKT,RBKT,NEXT,LARO,LEN,EQ,,,,,,,,,,;	!1,2,OUNIMP,OIMP;OTRAPMSGS:	SINK_ DISP, SINK_ lgm10, BUS=0;		L_ STACKP, :OUNIMP;OIMP:		SINK_ DISP, SINK_ X17, BUS;		SAVSP_ L, :LBKT;				STASH STACKP IN REGOUNIMP:	SAVSP_ L, :APPLY;			STASH STACKP IN REG;;	SUBS	[LBKT,RBKT,NEXT,LARO];		MESSAGES WHICH REFER TO THE PARTS OF COLLECTION OBJECTS;		([] and []_ FOR STRINGS AND VECTORS, next and _ FOR STREAMS);	!1,2,TST,HIT0;	!1,2,ILTL,ITOBG;	!1,2,IPOS,INEG;	!3,4,INT,VEC,STR,;	!1,2,STST,STLD;	!1,2,VCLD,VCST;	!1,2,STLDEV,STLDOD;	!1,2,STSTEV,STSTOD;LBKT:		L_ 0, TASK, :GTOPCLS;RBKT:		L_ ONE, TASK, :POPTOP;		FETCH NEW VAL FOR DOT_POPTX1:	SAVR1_ L, :LBKT;;GCLASSX0:	NAME_ L;		L_ NEGVECCLS+T, :DBLTST;TSTX0:	L_ 3, TASK, :ILONG;ILONGX3:	TEMP4_ L;		L_ ALLONES, TASK;		AOOP_ L;		L_ 0, :POPTOP;			FETCH INDEX FOR DOT AND DOT_POPTX0:	T_ 3, :IVALL;			SEE BELOW FOR IVALX3;NEXT:		L_ 2, TASK, :GTOPCLS;LARO:		L_ 2, TASK, :POPTOP;		FETCH NEW VAL FOR NEXT_POPTX2:	SAVR1_ L, :NEXT;;GCLASSX2:	L_ STMCLS-T, :TST;TSTX2:	L_ 6, TASK, :HASH;		L_ CORE ADD OF STREAM	;// HASH STREAM ON TOP OF STACK. NO DIRTY //HSHX6:	MAR_ LREG+1;			ADDRESS STREAM INDEX		 ACORE_ L;				ACORE_ CORE ADD OF STREAM		 L_ TOP;		 AOOP_ L;		L_ MD, TASK;		TEMP3_ L;				TEMP3_ STREAM INDEX		MAR_ ACORE;				ADDRESS STREAM CONTENTS (STRECTOR)		 T_ 2;		L_ MD;		MAR_ ACORE+T;			ADDRESS STREAM LENGTH		 TOP_ L;				TOP_ STREAM CONTENTS (STRECTOR)		L_ MD, :IVALL;IVALX2:	TEMP4_ L;				TEMP4_ VALUE OF STREAM LENGTH		L_ TOP;		T_ ONE, :GCLASSL;GCLASSX1:	NAME_ L;		L_ TEMP3;				L_ STREAM INDEX		T_ 7, :IVALL;IVALX7:	T_ 0+T+1, :IVALX3;;IVALX3:	L_ TEMP4-T;				L_ VALUE OF LENGTH-VALUE OF INDEX		L_ ALLONES+T, SH<0;		CHECK INDEX LESS THAN LENGTH		TEMP2_ L, SH<0, :ILTL;		TEMP2_ OFFSET(INDEX-1) & CHECK POSILTL:		L_ TOP, :IPOS;			L_ OOP OF STRECTORIPOS:		BOOP_ L;		T_ 25, :HASHL;			L_ CORE ADD OF STRECTOR	;// HASH STRECTOR BEING INDEXED. DIRTY //HSHX25:	BCORE_ L;				BCORE_ CORE ADD OF STRECTOR		L_ ONE, TASK;		RETN1_ L;		L_ T_ NAME;				L_ T_ CLASS OF STRECTOR		L_ INTCLS-T, :TRITST;		DISTINGUISH STR, VEC AND INTTSTX1:	L_ TEMP2, TASK, :INT;		L_ VALUE OF OFFSET;	!1,2,NOADD,DOADD;	!1,2,MULLP,INTNSTOR;;	!1,2,GTI,INTLARO;INT:		CYCOUT2_ L;				CYCOUT2_ INDEX OF INTERVAL;		SINK_ DISP, BUSODD;		CHECK FOR next OR _		T_ 2, :GTI;				L_ T_ VALUE OF INT STEPIVALX10:	TEMP4_ L;				TEMP4_ VALUE OF INT STEP		T_ 0, :GTI;;							L_ T_ VALUE OF INT STARTIVALX6:	ARG1_ L;				ARG1_ VALUE OF INT START		L_ TEMP4, TASK;		TEMP1_ L;MULLP:	L_ TEMP1, BUSODD;			TEST LO BIT OF MULTIPLIER		TEMP1_ L RSH 1, :NOADD;		HALVE MULTIPLIERNOADD:	L_ CYCOUT2, SH=0, TASK;		L_ MULTIPLICAND, TEST DONEDBL:		CYCOUT2_ L LSH 1, :MULLP;	DOUBLE MULTIPLICANDDOADD:	T_ CYCOUT2;				T_ MULTIPLICAND		L_ ARG1+T;				L_ SUM+NEW TERM		ARG1_ L, L_ T, TASK, :DBL;	ARG1_NEW SUM, L_ MULTIPLICANDINTNSTOR:	L_ 2, TASK, :INTN;		ARG1_INTRNED SUMINTNX2:	TOP_ L, :REFX12;;;INTLARO:	:APPLY;;GTI:		MAR_ BCORE+T;			ADDRESS ELEMENT T OF INTERVAL		 T_ 5+T+1;				MAP T FOR IVAL RETURN;		L_ MD, :IVALL;;STR:		CYCOUT2_ L RSH 1;		CYCOUT2_ WORD INDEX IN STRING		T_ CYCOUT2;		MAR_ L_ BCORE+T;			ADDRESS WORD WITH BYTE		 L_ DISP, SINK_ lgm1;		L_ MD, SH=0, TASK;		TEST LOAD OR STORE?		CNT_ L, :STST;			CNT_ WORD WITH BYTE;STLD:		SINK _TEMP2, BUSODD;		TEST WHICH BYTE		L_ T_ CNT, :STLDEV;		L_ T_ WORD WITH BYTE;STLDEV:	CYCOUT_ L LCY 8;			SWAP WORD WITH BYTE		T_ CYCOUT, :STLDOD;		T_ SWAPPED WORD WITH BYTE;STLDOD:	L_ 377 AND T;		ARG1_ L, :INTNSTOR;		STORE INTRNED BYTE ON STACK;STST:		L_ SAVR1;				L_ NEW BYTE		TOP_ L;				TOP_ NEW BYTE		T_ 5, :IVALL;			L_ T_ VALUE OF NEW BYTEIVALX5:	SINK_ TEMP2, BUSODD;		TEST WHICH BYTE		L_ 377.T, TASK, :STSTEV;	L_ MASKED VALUE OF NEW BYTE;STSTEV:	CYCOUT_ L LCY 8;			CYCOUT_ NEW BYTE IN LEFT BYTE		T_ 377, :STSTCM;			T_ RIGHT BYTE MASK;STSTOD:	CYCOUT_ L;				CYCOUT_ NEW BYTE IN RIGHT BYTE		T_ 177400, :STSTCM;		T_ LEFT BYTE MASK;STSTCM:	L_ CNT.T;				L_ REMAINING BYTE FROM WORD		T_ CYCOUT2;		MAR_ BCORE+T;			ADDRESS WORD WITH BYTE		 T_ LREG;				T_ REMAINING BYTE FROM WORD		 L_ CYCOUT+T;			L_ NEW BYTE AND REMAINING BYTE		MD_ LREG, :RISUBEND;		STORE NEW BYTE AND REMAINING BYTE;VEC:		NOP;		SINK_ DISP, BUSODD;		TEST LOAD OR STORE?		T_ TEMP2, :VCLD;			T_ OFFSET IN VECTOR;VCLD:		MAR_ L_ BCORE+T;			ADDRESS OOP IN VECTOR		 NOP;		L_ MD, TASK;		TOP_ L, :RISUBEND;;VCST:		L_ SAVR1;				L_ NEW OOP		TOP_ L, TASK;			TOP_ OOP IN VEC		L_ BCORE+T, :PULL;		L_ OOP IN VECTOR;				NOTE: PULL RETURNS TO RISUBEND IF MODE IS 0	!1,2,POSTSTM,IMDONE;RISUBEND:	L_ TOP;		T_ 12, :REFCKL;REFX12:	L_ AOOP+1;		MAR_ ACORE+1, SH=0;		ADDRESS STREAM INDEX		 T_ 4, :POSTSTM;POSTSTM:	L_ MD;		NAME_ L, :IVALL;IVALX4:	L_ ONE+T, T_ ONE, :INTNL;INTNX1:	MAR_ ACORE+1;			ADDRESS STREAM INDEX		 T_ 13;		MD_ LREG;		L_ NAME, :REFCKL;REFX13:	:REFX4;IMDONE:	SINK_ MD, TASK, :REFX13;;ITOBG:	:INEG;				INDEX OUT OF RANGEINEG:		:APPLY;				OFFSET NEGATIVE;;	!1,2,TST,HIT0;	(APPEARS ABOVE)	!1,2,TST1,HIT1;;	!1,2,APPLY,HIT2;	(APPEARS ABOVE)	!1,1,TXIT;TRITST:	L_ NEGVECCLS+T, SH=0, :DBLTST;	FIRST TESTDBLTST:	L_ NEGSTRCLS+T, SH=0, :TST;		(SECOND) TEST, (FIRST BRANCH)TST:		L_ ONE, SH=0, :TST1;			(THIRD) TEST, (SECOND BRANCH)TST1:		L_ 2, :APPLY;				(THIRD) BRANCHHIT0:		L_ 0;						WAS FIRST CLASSHIT1:		SINK_ RETN1, BUS, :TXIT;		WAS (SECOND) CLASSHIT2:		SINK_ RETN1, BUS, :TXIT;		WAS (THIRD) CLASSTXIT:		SINK_ LREG, BUS, :TSTX0;;;	APPLY		-DO IT THE SLOW GENERAL WAY;APPLY:	L_ T_ SAVSP;		MAR_ TFRAME+T;			ADDRESS TOP OF STACK		 STACKP_ L;		L_ MD, TASK;		TOP_ L;				RESTORE TOP REGISTER FROM STACK		T_ 177034-1;			(T_ -744-1)		T_ 500+T+1;				(L_ -244 I.E. DIFFERENCE BETWEEN						;	 PLUS BYTE CODE AND ADDRESS OF						;	 PLUS ATOM)		MAR_ DISP+T;		 :OPSA;;POPTOP:	RETN0_ L;		L_ T_ STACKP-1;			DECREMENT STACK POINTER		MAR_ TFRAME+T;			ADDRESS ELEMENT ON TOP OF STACK		 STACKP_ L;				RESTORE STACK POINTER		 SINK_ RETN0, BUS;		RETURN DISPATCH		L_ T_ MD, :POPTX0;		L_ ELEMENT ON TOP OF STACK;;	****	LENGTHLEN:		L_ 4, TASK, :GTOPCLS;GCLASSX4:	L_ NEGVECCLS+T, :DBLTST;TSTX4:	L_ 0, TASK, :ILONG;ILONGX0:	:BOXSTOR;;;	****	EQ	TOP OF STACK=NEXT ON STACK?;	!1,2,NTEQ,ISEQ;EQ:		L_ 3, TASK, :POPTOP;POPTX3:	L_ TOP-T;		SH=0, TASK;		:NTEQ;NTEQ:		L_ FALSEOOP, :SHOVE;ISEQ:		L_ TRUEOOP, :SHOVE;;;;***		LITMSGS-		NON TRAPPED MESSAGES;	!1,2,DICTOK,DICTNIL;	!1,2,SIZOK,SIZE0;	!1,2,DLULP,GOTIT;	!1,2,STNIL,STARGS;	!1,2,STORIT,DONEIT;LITMSGS:	MAR_ LOCFRAME+T;			ADDRESS LITERAL OPERATOROPSA:		 NOP;		L_ MD;				L_ LITERAL OPERATOR		NAME_ L;SNDMSG:	L_ 5, TASK, :GTOPCLS;		L_ CLASS OF TOP OF STACKGCLASSX5:	SUPMOD_ L;		T_ 16, :HASHL;			L_ CORADD OF CLASS OF T.O.S.	;// HASH CLASS OF TARGET. NO DIRTY //HSHX16:	MAR_ MDICTF+T;			ADDRESS MDICT OF C.O.T.O.S.		 NOP;		L_ MD+1;		L_ LREG-1, SH=0;			L_ OOP OF DICT, TEST NULL		BOOP_ L, :DICTOK;DICTOK:	T_ 12, :HASHL;	;// HASH MESSAGE DICTIONARY OF TARGET. NO DIRTY //HSHX12:	MAR_ L_ LREG;		 BCORE_ L;		 T_ 20;		L_ MD, :HASHL;	;// HASH LEFT SIDE OF DICTIONARY. NO DIRTY //HSHX20:	NAMES_ L;				NAMES: CORE ADD OF NAMEVEC		L_ ONE;		WRAPFL_ L, TASK, :ILONG;	WRAPFL COUNTS WRAPSILONGX1:	TEMP2_ L, SH=0;			TEMP2: LENGTH		T_ TEMP2-1, :SIZOK;SIZOK:	L_ NAME.T, TASK;		TEMP1_ L;				INITIAL HASH=NAME AND LEN-1	!1,2,INCIX,WRAP;	!1,2,DLUL1,WRAP2;;	!1,2,NOTNIL,NOTIND;	(APPEARS ABOVE)DLULP:	T_ TEMP1;				/* LOOKUP LOOP		L_ TEMP2-T-1;		MAR_ NAMES +T, SH=0;		LOOK AT NAMES[INDEX]		 L_ WRAPFL-1, :INCIX;INCIX:	 L_ 0+T+1, :NEWIX;		INDEX _ INDEX + 1WRAP:		 WRAPFL_ L, SH<0, :NEWIX;	FIRST WRAP LEAVES 0 IN L!NEWIX:	 TEMP1_ L, T_ 0+1, :DLUL1;	SECOND WRAP GOES TO WRAP2DLUL1:	L_ MD+T, T_ MD;		L_ NAME-T, SH=0;			TEST FOR EMPTY SLOT		:NOTNIL, SH=0, TASK;		TEST FOR HITNOTNIL:	:DLULP;				LOOP IF NEITHER;	!1,2,PRIM,BYTES;	!1,2,IXOK,UNWRAP;GOTIT:	L_ TEMP1-1, BUS=0;		UN-INC HASHI		:IXOK;UNWRAP:	L_ TEMP2-1;				UN-WRAP IF WAS ZEROIXOK:		MAR _ BCORE+1;		 TEMP2_ L;		 T_ 22;		L_ MD, :HASHL;			/* FOUND NAME - GET VALUE	;// HASH RIGHT SIDE OF DICTIONARY. NO DIRTY //HSHX22:	MAR_ TEMP2+T;RPROG:	 T_ 2;		L_ MD;		BOOP_ L, :HSH30L;		BOOP_ MDICT[LITERAL OPERATOR]	;// HASH METHOD. NO DIRTY //HSHX32:	MAR_ LREG;		 BCORE_ L;				INSTALL CORE ADDR OF B BASE REG		L_ MD-1, BUS=0;			(L_ MD-1, T_ MD)		L_ LREG+1, SH=0, :PRIM;	[PRIM,BYTES];	!1,2,DO,NOOP;	!1,2,NCSTOR,NCDONE;	!1,1,REFLAST;PRIM:		TEMP3_ L, :DO;			[DO,NOOP]NOOP:		:BYTERP;DO:		MAR_ SVSPLOC-1;		 TASK;		MD_ PCB;		MAR_ SVSPLOC;		 T_ 7;		MD_ L_ STACKP;		MAR_ BCORE+1;		 TEMP2_ L;		L_ MD AND T, TASK;		TEMP1_ L;		T_ ALLONES;		L_ TOP;NCLOOP:	MAR_ SELFLOC+T+1;		 SINK_ TEMP1, BUS=0, TASK;		MD_ LREG, :NCSTOR;		[NCSTOR,NCDONE]NCSTOR:	L_ T_ TEMP2-1;		MAR_ TFRAME+T;		 TEMP2_ L;		 L_ T_ TEMP1-1;		 TEMP1_ L;		L_ MD, :NCLOOP;NCDONE:	MAR_ PRIMTABLOC;		 T_ TEMP3;		L_ MD;		MAR_ LREG+T;		 TASK;		L_ MD;		MAR_ LREG, :MEMPC;;PRIMRET:	MAR_ SVSPLOC-1;		 L_ ARG1;		 TOP_ L;		L_ MD;		MAR_ SVSPLOC;		 PCB_ L, TASK;		L_ MD;		MAR_ BCORE+1;		 T_ 7;		T_ MD.T;		L_ LREG-T;		T_ LREG, :STOR;;PRIMFAIL:	L_ BOOP;		T_ 6, :REFCKL;;BYTES:	L_ 6, :REFLAST;REFX6:	L_ 0, :ACTXT;;	NOTE: THE RETURN FOR THE CONTEXT ALLOCATOR MUST BE 0;		L_ OOP[NEW AREC];		T_ CORADD[SAME]ALLOCX0:	AOOP_ L, L_ T, TASK;		AOOP_ OOP[NEW AREC]		ACORE_ L;				ACORE_ CORE ADD OF NEW AREC		L_ CTXT;				L_ OOP OF RETIRING AREC		ARG1_ L, L_ T_ 0, :PTATT;	NEW AR[SENDER]_ RETIRING ARECPUTX0:	L_ TOP, :PTNXT;			NEW AR[INST]_TOP OF OLD STACKPUTX1:	L_ ALLONES, :PTNXT;		NEW AR[CLASS]_ NILPUTX2:	L_ BOOP, :PTNXT;			NEW AR[CODE]_ MDICT[LIT OP]PUTX3:	MAR_ BCORE+1;			ADDRESS SECOND WORD OF CODE		 T_ 177400;				T_ LEFT BYTE MASK		L_ MD AND T, T_ MD;		L_ LEFT BYTE		ARG1_ L LCY 8;			ARG1_ TSIZE (BYTE #2 OF CODE)		L_ T_ 377.T;			T_ L_ RIGHT BYTE		NAME_ L;				NAME_ NARGS (BYTE #3 OF CODE)		L_ STACKP-T-1, TASK;		STACKP_ L;				POP THE OBJECT AND ITS ARGS		L_ T_ ARG1;		RETN2_ L, :AVEC;			RETN2_ TSIZE;	NOTE: THE RETURN FOR THE VECTOR ALLOCATOR IS 2 (SET INTERNALLY);		ARG1_ VECTOR TSIZE;		TEMP1_ COREADDALLOCX2:	L_ T_ 4, :PTATT;			NEW AREC[TFRAME]_ NEW VECTOR;;	LOOP TO STORE ARGS AND NIL STACK AND TEMP PART OF TFRAME;	RETN2 IS THE OFFSET IN TFRAME WHICH POINTS AT THE LAST;	SLOT FILLED, STARTS OUT AS SIZE OF TFRAME;PUTX4:	T_ NAME;				T_ NARGS		L_ RETN2-T;		L_ T_ RETN2-1, SH=0;		L_ T_ OFFSET OF NEXT ELEMENT,;							TEST IF REST ARE ARGS		RETN2_ L, :STNIL;		RETN2_ OFFSET OF CURR ELEMENTSTNIL:	MAR_ TEMP1+T;			ADDRESS CURRENT ELEMENT		 TASK;				(IN STACK OR TEMPS)		MD_ ALLONES, :PUTX4;		NIL CURRENT ELEMENT;;	THE REST OF THE TFRAME IS TAKEN UP BY ARGS;STARGS:	T_ STACKP;				T_ OLD STACKP		L_ T_ TFRAME+T+1;		L_ ADD OF LOWEST ARG IN OLD STACK		MAR_ NAME+T;			ADDRESS OF REF TO TARGET		 TFRAME_ L, :NILTOP;		TFRAME_ ADD OF LOW ARG IN;							O.S., AND NIL REF TO TARGETSTORIT:	T_ NAME-1;				T_ OFFSET IN NEW STACK-1		MAR_ TEMP1+T+1;			ADDRESS ARG ON NEW STACK		 T_ TFRAME+T+1;			T_ ADD OF ARG ON OLD STACK		MD_ LREG, L_ T;			STORE ARG ON NEW STACK		MAR_ LREG;				ADDRESS ARG ON OLD STACKNILTOP:	 TASK;		MD_ ALLONES;			NIL ARG ON O.S.(FOR REFCT)		L_ T_ NAME-1;			L_ T_ OFFSET OF NEXT ARG		MAR_ TFRAME+T;			ADDRESS NEXT ARG ON OLD STACK		 NAME_ L, TASK, SH<0;		NAME_ OFF OF NEXT ARG		L_ MD, :STORIT;			L_ NEXT ARG FROM OLD STACKDONEIT:	L_ 0, TASK, :STASH;STASHX0:	T_ 2;		MAR_ BCORE+T;			ADDRESS THIRD WORD OF CODE		 T_ 177400;				T_ LEFT BYTE MASK		L_ MD AND T, T_ MD;		L_ LEFT BYTE		CYCOUT_ L LCY 8;			CYCOUT_ OFF OF 1ST STACK LOC;							(INITIAL STACKP+1, BYTE #4)		L_ 377.T, TASK;			L_ INITIAL PCB (BYTE #5)		PCB_ L;				PCB_ INITIAL PCB		L_ CYCOUT-1;		STACKP_ L;				STACKP_ INITIAL STACKP		L_ AOOP;		CTXT_ L;		L_ ACORE;		AREC_ L;		L_ TEMP1, TASK;		TFRAME_ L;		T_ BCORE;				T_ CORE ADDRESS OF CODE		L_ ONE, :MAPCODE;		GENERATE LOCFRAME AND CADDR	!1,2,HASHSELF,NILSELF;MCX1:		T_ MINAT;		L_ TOP-T;		ALUCY;		L_ TOP, :HASHSELF;		[HASHSELF,NILSELF]HASHSELF:	T_ 27, :HASHL;			L_ CORE ADDRESS OF NEW SELFNILSELF:	L_ ALLONES, :HSHX27;	;// HASH NEW SELF. DIRTY //HSHX27:	SELF_ L, :BYTERP;		;HEIGH HO SILVER, AWAY!!!;				"WHO WAS THAT MASKED MAN?";	!1,1,NID1;SIZE0:	:NID1;				ZERO MDICT SIZE FAILSDICTNIL:	:NID1;				NULL MDICT FAILSWRAP2:	SINK_ MD, :NID1;			2ND WRAP-AROUND FAILSNOTIND:	:NID1;NID1:		L_ SUPMOD;		T_ 4, :HSH30L;	;// HASH CURRENT MCLASS. NO DIRTY //HSHX34:	MAR_ SPRCLSF+T;		 NOP;		L_ MD+1;		L_ LREG-1, SH=0;		SUPMOD_ L, :DISPATCH;		[DISPATCH,NOMSG]NOMSG:	MAR_ ERRPRG, :RPROG;;;***		PTNXT-	PUT OOP IN L INTO NEXT LOC WITHOUT REFI-ING IT;PTNXT:	ARG1_ L;		L_ T_ TEMP2+1;			L_ INCREMENTED INDEXPTATT:	MAR_ ACORE+T;			ADDRESS NEXT LOC		 TEMP2_ L;				CURRENT INDEX_ INC-ED INDEX		 SINK_ TEMP2, BUS, TASK;	RETURN IS INDEX		MD_ ARG1, :PUTX0;		STORE OOP;;	//SUBROUTINE TO STASH PC AND STACKP IN AREC//;STASH:	RETN0_ L;		T_ OOP00;		L_ STACKP+T;		STACKP_ L;		L_ PCB+T;		T_ PCF;		MAR_ AREC+T;		 T_ STACKPF;		MD_ LREG;		MAR_ AREC+T;		 SINK_ RETN0, BUS, TASK;		MD_ STACKP, :STASHX0;;;		MAP CODE	GENERATE LOCFRAME AND CADDR;MAPCODE:	RETN0_ L;		L_ 3+T;				L_ C.A. OF 3RD WORD OF CODE		LOCFRAME_ L	;		L_ PCB;				L_ PTR TO NEXT BYTE IN CODE		CYCOUT_ L RSH 1;			CYCOUT_ WORD IDX OF THAT BYTE		L_ CYCOUT+T;			L_ C.A.[NEXT BYTE]		SINK_ RETN0, BUS, TASK;		CADDR_ L, :MCX0;			CADDR_ C.A.[NEXT BYTE];;	SECOND AND THIRD SET OF NON TRAPPED MESSAGES;LITMSGS2:	T_ 17+T+1, :LITMSGS;		ADDRESS LITERAL OPERATORLITMSGS3:	T_ 37+T+1, :LITMSGS;		ADDRESS LITERAL OPERATOR;;;;	************************************;	*  BYTE-INTERPRETER/OOZE MICROCODE *;	************************************;;;		IVAL- 	ARG1:OOP L:RETN;				L_VALUE OF NUMBER;				PRESERVES ARG1;	!1,2,NOTSI,MBSI;	!1,2,ISSI,NONINT;IVALL:	ARG1_ L, L_ T, TASK;IVAL:		RETN2_ L;				(TASK HAPPENS HERE)		T_ MSINT;		L_ ARG1-T;		L_ ARG1+1, ALUCY;		TEST >= MIN SMALL INTEGER		T_ OOP00, SH=0, :NOTSI;	TEST FOR NIL IF SOMBSI:		L_ ARG1-T, TASK, :ISSI;ISSI:		NOP;		SINK_ RETN2, BUS;		L_ T_ LREG, :IVALX0;NONINT:	L_ 3, TASK, :GCLASS;NOTSI:	L_ 3, TASK, :GCLASS;GCLASSX3:	L_ NUMCLS-T, :TST;		TEST FOR CLASS = NUMBERTSTX3:	L_ 10, TASK, :HASH;		HASH INTO ROT	;// HASH LARGE INTEGER. NO DIRTY //HSHX10:	L_ ROT1, TASK, :ISSI;;;		INTN- 	ARG1:VALUE L:RETN;				L_T_NUMBERS OOP;	!1,2,OUTOFRANGE,INRANGE;	!1,2,NTNL,OOR1;INTNL:	ARG1_ L, L_ T, TASK;INTN:		RETN2_ L;		T_ OOP00;		L_ ARG1+T;				L: OOP IF IT IS SMALL INT		T_ MSINT;		L_ LREG-T;		L_ LREG+T+1, ALUCY;		IS IT > THAN MIN SMALL INT?		T_ LREG-1, SH=0, :OUTOFRANGE;	IS IT NIL?;INRANGE:	L_ ARG1, TASK, :NTNL;NTNL:		L_ T;IRT:		SINK_ RETN2, BUS;		L_ T_ LREG, :INTNX0;;OUTOFRANGE:	L_ ARG1, TASK, :OOR1;OOR1:		SAVR1_ L;		L_ ONE, :AINT;;	NOTE: THE RETURN FOR THE INTEGER ALLOCATOR MUST BE 1;		ARG1_ OOP OF NEW INTEGER;		TEMP1_ CORE ADDRESS OF NEW INTEGERALLOCX1:	MAR_ TEMP1;		 TASK;		MD_ SAVR1, :IRT;;;;		ILONG- 	ARG1:OOP L:RETN;				L_OOP'S LENGTH;				PRESERVES ARG1;;	/* ILONG */	AC0 _ LENGTH (OOP IN AC0)	!1,2,GOTSIZ,ISOCT;ILONGL:	ARG1_ L, L_ T, TASK;ILONG:	RETN1_ L;			(TASK HAPPENS HERE)		T_ ARG1;		L_ 0, :PMAP;PMAPX0:	T_ ISCMSK;		T_ MD.T;			EXTRACT INST SIZE		L_ OCTV-T-1;		L_ T, SH<0, TASK;	TEST FOR OCTAVE SIZE;		:GOTSIZ;GOTSIZ:	SINK_ RETN1, BUS;		L_ T_ LREG, :ILONGX0;	RETURN WITH SIZE IN L;ISOCT:	L_ 14, TASK, :HASH;	CALL HASH TO FIND OBJ	;// HASH OBJECT. NO DIRTY //HSHX14:	MAR_ ROT1-1;		TASK;		L_ MD, :GOTSIZ;		REAL LENGTH IN FIELD -1;;;;;		GTOPCLS- 	L:RETN;				L_TOP'S CLASS;				PRESERVES ARG1;	!1,2,GTRN,DOGC;GTOPCLS:	RETN1_ L;		L_ SUPMOD+1;		L_ TOP, SH=0, TASK;		ARG1_ L, :GTRN;GTRN:		SINK_ RETN1, BUS;		L_ T_ SUPMOD, :GCLASSX0;;;;;		GCLASS- 	ARG1:OOP L:RETN;				L_OOP'S CLASS;				PRESERVES ARG1;GCLASSL:	ARG1_ L, L_ T, TASK;GCLASS:	RETN1_ L;				(TASK HAPPENS HERE)DOGC:		L_ ARG1+1;		T_ ARG1, SH=0;			TEST FOR NIL		L_ ONE, :PMAP;PMAPX1:	T_ RCIMSK;		L_ MD.T, TASK;			EXTRACT RCI		CYCOUT_ L LCY 8;FIN:		SINK_ RETN1, BUS;		L_ T_ CYCOUT, :GCLASSX0;GCNIL:	L_ OBJCLS, TASK;		CYCOUT_ L, :FIN;;;;		PMAP- 	T:OOP L:RETN;				RETURNS AFTER MAR_ PMAP ENTRY ADDRESS;PMAP:		RETN0_ L, L_ T;		XREG_ L LCY 8;		L_ T_ XREG, TASK;		XREG_ L MLSH 1;		L_ T_ XREG, TASK;		XREG_ L MLSH 1;		T_ 1777-1;				1776		T_ XREG.T, TASK;		L_ PMBASE+T;		SINK_ RETN0, BUS;		MAR_ LREG, :PMAPX0;		INDEX THE PCLASS MAP;;		ALLOCATORS FOR CONTEXT, INTEGER AND VECTOR;				ARG1_ L_ NEW OOP;				TEMP1_ T_ CORE ADDRESS OF NEW OOP;	!1,2,SZOK,TOOLONG;	!1,2,GOTONE,NILFL;	!1,2,LINKUP,NXNIL;	!3,4,CTXTF,INTF,VECF,;ACTXT:	T_ CLFREE, :ALLOC;AINT:		T_ CLFREE2, :ALLOC;AVEC:		L_ 10-T;		T_ CLFREE3MT+T+1, SH<0;		L_ 2, :SZOK;		[SZOK,TOOLONG]SZOK:		T_ 0+T+1, :ALLOC;TOOLONG:	RETN1_ L, :VECF;;;	AT THIS POINT, T CONTAINS THE OFFSET FROM THE BASE OF CORE;	OF THE RELEVENT FREELIST;ALLOC:	RETN1_ L;		MAR_ L_ COREBASE+T;		 TEMP2_ L;		L_ MD+1;		L_ LREG-1, SH=0;			TEST NULL FREELIST		ARG1_ L, :GOTONE;		[GOTONE,NILFL]NILFL:	SINK_ RETN1, BUS, :ALLOCFAIL;GOTONE:	L_ 31, TASK, :HASH;	;// HASH FREE LIST HEAD. DIRTY //HSHX31:	MAR_ L_ LREG;		 TEMP1_ L;				TEMP1_ CORE LOC OF NEW OBJECT		L_ MD+1;		L_ LREG-1, SH=0, TASK;		:LINKUP;				[LINKUP,NXNIL]NXNIL:	SINK_ RETN1, BUS, :ALLOCFAIL;LINKUP:	MAR_ TEMP2;		 T_ RESRPC;			T: MASK FOR RES AND REPROBE COUNT		 T_ IMMBIT OR T;		T: MASK FOR IMM BIT, RES AND RPC		MD_ LREG;		MAR_ ROTA;		 T_ ROT0.T;			T: IMMEDIATE BIT, RES AND RPC		 L_ ROT0ND OR T, TASK;		MD_ LREG;ALRT:		L_ ARG1;		SINK_ RETN1, BUS;		T_ TEMP1, :ALLOCX0;		[ALLOCX0,ALLOCX1,ALLOCX2,];ALLOCFAIL:	:CTXTF;				[CTXT,INT,VEC,]CTXTF:	L_ CNTXCLS, :NOVAALLOC;INTF:		L_ NUMCLS, :NOVAALLOC;VECF:		L_ VECCLS, :NOVAALLOC;;NOVAALLOC:	ARG1_ L;		L_ AC1;		TEMP3_ L;		L_ RETN2;		AC1_ L;		L_ 30, :NOVACALL;;	...ALLOCRET:	L_ ARG1, TASK;		TEMP1_ L;		L_ TEMP3;		AC1_ L;		L_ TEMP1;		T_ 21, :HASHL;	;// HASH NEW INSTANCE. DIRTY //HSHX21:	TEMP1_ L, :ALRT;;;		REFLAST-	L:RETN;				REFERENCE COUNT LAST OBJECT HASHED;REFLAST:	RETN1_ L, :HSHX30;;;		REFCK-	ARG1:OOP L:RETN;				SMASHES ARG1;;	!17,1,REFA;	!1,2,RNAT,RISAT;	!1,2,REFI,REFD;REFCKL:	ARG1_ L, L_ T, TASK;REFCK:	RETN1_ L;				EVEN CALLS TO REFI, ODD TO REFD!		T_ MINAT;				CHECK FOR SPECIAL		L_ ARG1-T;		L_ LREG+T, ALUCY;		(RESTORE L)		SINK_ RETN1, BUS, :RNAT, TASK;RISAT:	:REFX0;				IF SPECIAL, THEN DONERNAT:		:REFA;;;		REF-		ARG1:OOP L:RETN;				SMASHES ARG1;REF:		RETN1_ L;				EVEN CALLS TO REFI, ODD TO REFD!REFA:		L_ 30, TASK, :HASH;			HASH INTO ROT	;// HASH OBJECT BEING REFERENCE COUNTED. NO DIRTY //HSHX30:	T_ ROT0;		SINK_ RETN1, BUSODD, TASK;	TEST REFI OR REFD		L_ 2 OR T, :REFI;		SLIP IN A DIRTY (=2) BIT!;	!1,2,DECIT,DEALOC;	!1,2,DCKOV,DNOV;REFD:		T_ LREG;				/* REFD		L_ RCTMSK.T;		MAR_ ROTA, SH=0;			TEST IF DEC ZERO		L_ RCT8BIT.T, :DECIT;		CHECK IF COUNT>7DECIT:	L_ RCTM1BIT+T, SH=0;		HERE IS THE DECREMENT		MD_ LREG, :DCKOV;		AND STORE-BACKDNOV:		SINK_ RETN1, BUS, :RISAT, TASK;	DONEDCKOV:	L_ ROT0, :CKOV, TASK;		GO TEST FOR 14 (BEFORE DEC);	!1,2,ICKOV,INOV;REFI:		T_ LREG;				/* REFI		MAR_ ROTA;		L_ RCT8BIT.T;			CHECK IF COUNT>7		L_ RCT1BIT+T, SH=0;		HERE IS THE INCREMENT		MD_ LREG, :ICKOV;		AND STORE-BACKINOV:		SINK_ RETN1, BUS, :RISAT, TASK;	DONEICKOV:	:CKOV, TASK;			GO TEST FOR 14 OR 15 (AFTER INC);	!1,2,WASOV,NOTOV;CKOV:		NOP;					/* CHECK FOR OV		T_ LREG;		T_ RCTMSK.T;		T_ 177400+T+1;		L_ 37+T;				L _ RCT - 14 (340)		SH<0;		SINK_ RETN1, BUSODD, :WASOV;NOTOV:	SINK_ RETN1, BUS, :RISAT, TASK;	DONE (!1,1,RISAT!);	!1,2,INCOV,DECOV;	!1,2,OLDINC,NEWINC;	!1,1,OLDDEC;WASOV:	L_ AC1, SH=0, :INCOV;		/* PREPARE TO CALL NOVAINCOV:	TEMP3_ L, :OLDINC;NEWINC:	L_ 2, :OVCALL, TASK;		AC1=2 - INC NEEDS NEW OV ENTRYOLDINC:	L_ ONE, :OVCALL, TASK;		AC1=1 - INC OLD OV ENTRYDECOV:	TEMP3_ L, :OLDDEC;OLDDEC:	L_ 0, :OVCALL, TASK;		AC1=0 - INC OLD OV ENTRY;OVCALL:	AC1_ L;		MAR_ ROTA;				HAVE TO RESTORE ROT		TASK;		MD_ ROT0;		L_ 37-1, :NOVACALL;		THEN CALL OVREF (OOP, CODE);	...OVRET:	L_ TEMP3;		AC1_ L, :NOTOV;			AND RETURN;DEALOC:	L_ RCT1BIT+T, TASK;		BUMP REFCT TO 1 FOR FREER		MD_ LREG, :RECUF;		AND CALL THE RECURSIVE FREER;;	/* RECURSIVE FREER */	ENTER WITH REFCT=1	!1,2,NOSAV,SAVRS;	!1,2,HERE,RTOP;RECUF:	L_ FATHER+1;			FATHER = -1 <==> TOP-LEVEL ENTRY		L_ RETN1, SH=0;		:NOSAV, TASK;SAVRS:	SAVR1_ L, :GPCL;			TOP LEVEL ENTRY HAS TO SAVENOSAV:	:GPCL;				NO SAVE FOR RECURSIVE ENTRY;	!1,2,ISPT,NOTPT;	!1,2,DOFLD0,QFINST;GPCL:		L_ T_ ARG1;		TEMP3_ L;		L_ 2, :PMAP;			INDEX INTO PCLASS MAPPMAPX2:	T_ CPTMSK;		L_ MD AND T, T_ MD;		EXTRACT CPT		L_ ISCMSK.T, SH=0;		EXTRACT ISC		:ISPT, SH=0, TASK;		BRANCH ON WHETHER POINTERSISPT:		:DOFLD0;				BRANCH IF SIZE ZERONOTPT:	:QFINST;				(TASK,OR-1);DOFLD0:	L_ 11, TASK, :HASH;	;// HASH OBJECT BEING FREED. NO DIRTY //HSHX11:	MAR_ L_ LREG;		 TEMP3_ L;				(CORE ADDR OF FIELD 0)		L_ MD;		MAR_ TEMP3;		 T_ ARG1;		 ARG1_ L, L_ T;			ARG1 _ FIELD 0		MD_ FATHER, TASK;		FIELD 0 _ FATHER		FATHER_ L;				FATHER _ OOP		MAR_ ROTA;		 T_ RCT1BIT;		 L_ROT0+T, TASK;		MD_ LREG;				BUMP REFCT TO 2, FLAG FIRST TIME;FFF:		L_ 5, TASK, :REFCK;		/* HERE'S THE RECURSIVE REFD;	!1,2,DONXT,FTIME;REFX5:	L_ FATHER;				/* RESUME (INSTANCE IN FATHER)HERE:		ARG1_ L;		L_ 15, TASK, :HASH;	;// HASH OBJECT BEING FREED. DIRTY //HSHX15:	MAR_ L_ LREG+1;		 TEMP3_ L;				(CORE ADDR OF FIELD 1)		 T_ ROT0;		 L_ RCT1BIT.T;		L_ MD, SH=0, TASK;		TEST EVEN RCT (MEANS FIRST TIME)		TEMP2_ L, :DONXT;		FIELD 1 HOLDS FIELD OFFSET;	!1,2,GTFLD,OUT1;	!1,2,SAVST,QLOOP;DONXT:	L_ T_ TEMP2-1;			/* LOOK AT THE NEXT FIELDDONX1:	TEMP2_ L, SH=0;			TEST IF DONE		L_ TEMP3+T, :GTFLD;GTFLD:	MAR_ LREG;		 T_ MINAT;		L_ MD-T, T_ MD;GTF1:		L_ T, ALUCY, TASK;		TEST IF SPECIAL (NO NEED TO REFD)		ARG1_ L, :SAVST;QLOOP:	L_ T_ TEMP2-1, :DONX1;		QUICK LOOP TO GET NEXT FIELD;SAVST:	MAR_ TEMP3;				/* SAVE STATE AND REFD IT		 NOP;					STORE NEW OFFSET BACK		MD_ TEMP2;				INTO FIELD 1		L_5, TASK, :REF;			(NOTE RETURN IS SAME AS ABOVE!);	!1,2,NOTONE,OUT2;FTIME:	MAR_ ROTA;				/* DONE FIELD 0		 T_ RCT1BIT;		 L_ROT0-T, TASK;		MD_ LREG;				UNBUMP REFCT TO 1, NOT FIRST TIME	;(NOTE ARG1_FATHER AT HERE:)		L_ 2, TASK, :ILONG;		GET LENGTH OF THIS OBJECTILONGX2:	L_ LREG-1;		T_ TEMP2, SH=0;			TEST IF HAD ONLY 1 FIELD		TEMP2_ L, L_T, :NOTONE;NOTONE:	T_ MINAT;		L_ LREG-T, T_ LREG, :GTF1;		JUMP INTO INNER LOOP;				/* FREE THE INSTANCEOUT2:		:OUT1;OUT1:		MAR_ TEMP3-1;			LOAD FATHER STACHED IN FIELD 0		 L_ FATHER;		 TEMP3_ L;		L_ MD, TASK;O2A:		FATHER_ L, :QFINST;		AND FREE THE INSTANCE;;;	/* QUICK FINST FOR EXACT-SIZE OBJECTS */	!1,2,NOTVAR,VAROOP;	!1,2,EXACT,OCTL;QFINST:	T_ TEMP3;		L_ 3, :PMAP;PMAPX3:	TASK;		L_ MD;		T_ VARCLS;		L_ LREG-T, T_ LREG;		COMPARE TO VARLEN CLASS		L_ RCIMSK.T, ALUCY;		ARG1_ L LCY 8, :NOTVAR;	ARG1 _ REFOOP'S CLASS;VAROOP:	T_ ISCMSK.T;		L_ 10-T;		L_ CLFREE+T, SH<0, :CHK;;NOTVAR:	T_ ISCMSK.T;			EXTRACT INST SIZE		L_ OCTV -T-1;		L_ CLFREE, SH<0;CHK:		TEMP2_ L, :EXACT;;EXACT:	L_ 17, TASK, :HASH;	;// HASH CLASS OF OBJECT BEING FREED. DIRTY //HSHX17:	T_ TEMP2;				(MIGHT CAUSE A PURGE)		MAR_ L_ LREG+T;		 TEMP2_ L;		 L_ TEMP3;		 ARG1_ L;		L_ MD;		MAR_ TEMP2;		 TEMP2_ L;				TEMP2 _ CLASS[FREELISTHEAD]		MD_ TEMP3;				CLASS[FREE] _ REFOOP		L_ 13, TASK, :HASH;	;// HASH OBJECT BEING FREED. DIRTY //HSHX13:	MAR_ LREG;		 TASK;		MD_ TEMP2, :FIRET;		REFOOP[0] _ TEMPX1;;	/* HAVE TO CALL REAL FINST IN NOVA OTHERWISEOCTL:		L_ TEMP3;				CALL FINST WITH REFOOP IN AC0		ARG1_ L;		T_ 27;		L_ 5+T+1, :NOVACALL;		35 TRAPS TO 76400;	...FIRET:	L_ FATHER+1;			/* FINST RETURNS HERE VIA TRAP		L_ FATHER, SH=0;		:HERE;				IF FATHER NOT NIL, THEN MORE RECUFRTOP:		L_ SAVR1, BUS, TASK;		IS NIL - RESTORE RETN1		RETN1_ L, :REFX0;		AND RETURN TO ORIGINAL CALLER!;;		HASH- 	ARG1:OOP L:RETN;				ROTA_ROT ADDRESS OF OOP;				<ROT0,ROT1>_ROT ENTRY OF OOP;				L_CORE LOCATION OF OBJECT REFERRED TO BY OOP;	!1,2,PROBX,EMP;	!1,2,AGAIN,HASX;	!1,2,HASXX,ZOTP;	!1,2,IMMDAT,REMDAT;	!1,2,NODIRT,SETDIRT;HSH30L:	T_ 27+T+1;HASHL:	ARG1_ L, L_ T, TASK;HASH:		RETN0_ L;				(TASK HAPPENS HERE)		T_ ARG1;		L_ 377.T;		RHO_ L LCY 8;		L_ RHO XOR T, TASK;		FORM ROOT HASH = (LO,0) XOR (HI,LO)		RHO_ L;		T_ RHO;		L_ HKRMSK.T;		RESIDUE_ L;				SAVE <RESIDUE,RPC>		L_ 0, :PROBS0, TASK;		PROBE THE ROT;PROBX:	T_ RESIDUE;				OCCUPIED MEANS HIT OR TRY AGAIN		L_ LREG-T;				COMPARE <RESIDUE,RPC>		L_ RPCBIT+T, SH=0;		RESIDUE_ L, :AGAIN;		STEP <RESIDUE,RPC>!AGAIN:	L_ RPC+1, :PROBS, BUS, TASK;	STEP RPC, AND LOOP;HASX:		L_ ROT0, BUSODD;			HAVE A HIT, TEST OTP!		RESIDUE_ L, :HASXX;HASXX:	SINK_ RETN0, BUSODD;		SHOULD WE DIRTY		T_ 2, :NODIRT;			THE DIRTY BITSETDIRT:	MAR_ ROTA;				DO THE DIRTY		 L _ ROT0 OR T;			OR IN THE DIRTY BIT		MD_ LREG;				AND PUT IT BACK IN THE ROTNODIRT:	T_ 4;		L_ ROT0.T;		TASK, SH=0;				TEST IMMEDIATE BIT		L_ ROT1, :IMMDAT;IMMDAT:	L_ ROTA+1;REMDAT:	SINK_ RETN0, BUS;		L_ T_ LREG, :HSHX0;	(NOTE: THE FIRST INSTRUCTION AFTER A HASH WILL BE THE THIRD;	IN A TASK FOR REMOTE DATA AND THE FOURTH FOR IMMEDIATE DATA);ZOTP:		MAR_ ROTA;					IF IT WAS SET,		 L_ ROT0-1;					CLEAR OTP 		 ROT0_ L, TASK;		MD_ ROT0, :HASXX;;;;	/* HASH PROBE ROUTINE	!7,10,DEL1,DEL2,DEL3,DEL4,DEL5,DEL6,DEL7,DEL8;PROBS0:	RPC_ L, :DEL0;			CALL HERE FOR RPC=0PROBS:	RPC_ L, :DEL1;			OTHERWISE HERE WITH L_RPC+1, BUS;DEL1:		T_ 15, :DELX;	13		GET DELTA FOR THIS REPROBEDEL2:		T_ 21, :DELX;	17DEL3:		T_ 23, :DELX;	19DEL4:		T_ 27, :DELX;	23DEL5:		T_ 27;		T_ 5+T+1, :DELX;	29DEL6:		T_ 37, :DELX;	31DEL7:		T_ 37;		T_ 5+T+1, :DELX;	37DEL8:		T_ RPCBIT;				HAVE TO UN-INC RPC (WHICH HAS OV'ED)		L_ RESIDUE-T, TASK;		RESIDUE_ L, :EMP;		AND FAIL EXIT DUE TO OV REPROBE;DELX:		L_ RHO+T, TASK;		RHO_ L;				ADD TO RHODEL0:		T_ ROTMSK;		L_ T_ RHO.T, TASK;		L_ LREG+T;				(A LSH 1 WITHOUT AN R-REG)		T_ LREG;		MAR_ L_ ROTBASE+T;		 ROTA_ L;				ROTA _ ROT ADDRESS		T_ MD;		L_ MD;		ROT1_ L, L_ T;			ROT0,ROT1 _ ENTRY		ROT0_ L;		L_ ROT0EM-T;			TEST ROT0EM		SH=0, TASK;				**LEAVE <RESIDUE,RPC> IN LREG		L_ RESRPC.T, :PROBX;		RETN TO HASH IF OCCUPIED;EMP:		SINK_ RETN0, BUS=0;		FAIL EXIT		:FAULT;			CALL 0 CAN FAIL;;	/* HASH FAULT SAVES STATE THEN CALLS NOVA */FAULT:	L_ RETN0;		SAVR0_ L;				DO WE NEED THIS?????		T_ 27;NCPF:		L_ 4+T+1, :NOVACALL;		34 TRAPS TO 76000;	...FLTRET:	L_ SAVR0, TASK, :HASH;		BLITHELY RESUME HASHING...;;	NOVACALL;	/* CALL TO NOVA AND RETURN */;NOVACALL:	XREG_ L;				LOAD TRAP OP FROM L		L_ AREC;		AC2_ L;		L_ DISP, SINK_ disp.377, TASK;		SAVDISP_ L, :TRAPOP;		SAVE DISP;NOVARET:	SINK_ DISP, BUS, TASK;		RETURN DEPENDS ON THIS DISP		IR_ SAVDISP, :OVRET;		RESTORE PREVIOUS DISP;;;	/* RETURN TO NOVA IN ROMTRAPOP:	MAR_ TRAPPC;		 T_ 37;			COPY OF TRAP'S CODE IN ROM		 T_ XREG.T;			SINCE WE DON'T KNOW WHERE IT IS		MD_ PC;		MAR_ TRAPPC+T+1;MEMPC:	 NOP;		L_ MD, TASK;SPC:		PC_ L;STRT:		SWMODE;JSTART:	:START;			(AT LEAST WE KNOW WHERE START IS)RSPC:		L_ SAVPC, :SPC;;START:	L_ ONE, :SPC;		ONLY USED IN ROM;;;	*****************************;	*  NOVA OOZE TRAP MICROCODE *;	*****************************;;;	/* NOVA HASH TRAP */HASHT:	L_ PC;		SAVPC_ L;		L_ 0, TASK, :HASH;	THIS IS CALLER 0 OF HASH, CYCLE;	;// HASH OBJECT. NO DIRTY //HSHX0:	L_ SAVPC+1, TASK;		HASH HIT DOES NOVA SKIP-RETN		SAVPC_ L;		L_ RESIDUE, TASK;	AC3_ OLD ROT0 FOR HITSLACS:		AC3_ L;		L_ RPC, TASK;		AC1_ L;		L_ ROTA, TASK;		AC2_ L, :RSPC;;HFAIL0:	L_ HFRETI, :RAMCYCX;RAMCYCX:	PC_ L, L_ 0+1;L5:		CYRET_ L, SWMODE;		LABEL USED ONLY IN JMP TO ROM		L_ T_ RESIDUE, :L5;		ACTUALLY JUMP TO L5 IN ROMHFRET:	T_ 37;				RETURN FROM L5 IN ROM		L_ XREG.T, TASK, :LACS;	AC3_ RES FOR MISS (INSERT);;	/* NOVA REFCT TRAP */REFCT:	L_ PC;		SAVSP_ L;		L_ DISP, TASK, :REFCK;REFX0:	L_ SAVSP, :SPC;REFX1:	L_ SAVSP, :SPC;;;;	/* SKIP IF AC0 IS NOT SPECIAL (IE, IS REFCT'ED)	!1,2,NAT,ISAT;SNAT:		T_ MINAT;		L_ AC0-T;ISAT1:	ALUCY;		L_ PC+1, TASK, :NAT;NAT:		PC_ L, :STRT;ISAT:		:STRT;;;	/* LOAD ROT BASELROTB:	L_ ONE, :SPC;;;	/* EXTRACT */	(70000) DISP=<WIDTH><SHIFT>EXTRACT:	L_ 7;INJEXT:	RETN0_ L;	(INJECT SHARES THIS CODE WITH RETN0=5)		L_ PC, TASK;		RPC_ L;		L_ EIRETI;		PC_ L;		T_ DISP, SINK_ X17;		L_ 20-T, SWMODE;		T_ AC0, :RAMCYCX;			CYCLE AC0 RIGHTEIRET:	SINK_ DISP, SINK_ disp.377, BUS;TMSK:		SINK_ RETN0, BUS, :RMASK;		T_ WIDTH MASKRMX7:		L_ XREG.T, TASK;			(INJECT EXITED TO RMX2)		AC1_ L;RESTPC:	L_ RPC, :SPC;;;;	/* INJECT */	(70400) DISP=<WIDTH><SHIFT>INJECT:	L_ 5, :INJEXT;			ROTATE AC0 AND GET MASK IN TRMX5:		L_ AC1.T;				MASK OFF BITS TO INSERT		RESIDUE_ L, L_ 0-T-1;		T_ LREG;				COMPLEM MASK		T_ XREG.T;			ZERO THE SLOT		L_ RESIDUE OR T;			OR IN THE BITS		RESIDUE_ L;		L_ IJRETI;		PC_ L;		L_ DISP, SINK_ X17, SWMODE;		T_ RESIDUE, :RAMCYCX;		UNROTATEIJRET:	L_ XREG, TASK;		AC0_ L, :RESTPC;			AND STORE BACK IN AC0;;	/* RIGHT MASK TABLE */  SINK_RETN, BUS, :RMASKRMASK:	T_ 0, :WHICHOP;		*************************RM1:		T_ ONE, :WHICHOP;		*************************RM2:		T_ 3, :WHICHOP;		****                 ****RM3:		T_ 7, :WHICHOP;		*** NOTE:WHICHOP=RMX0 ***RM4:		T_ 17, :WHICHOP;		****                 ****RM5:		T_ 37, :WHICHOP;		*************************RM6:		T_ 77, :WHICHOP;		*************************RM7:		T_ 177, :WHICHOP;RM8:		T_ 377, :WHICHOP;RM9:		T_ 777, :WHICHOP;RM10:		T_ 1777, :WHICHOP;RM11:		T_ 3777, :WHICHOP;RM12:		T_ 7777, :WHICHOP;RM13:		T_ 17777, :WHICHOP;RM14:		T_ 37777, :WHICHOP;RM15:		T_ 77777, :WHICHOP;