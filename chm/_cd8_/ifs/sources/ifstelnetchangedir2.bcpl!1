// IfsTelnetChangeDir2.bcpl -- Change Directory-Parameters command// Copyright Xerox Corporation 1979, 1980, 1981// Last modified November 15, 1981  2:04 PM by Taftget "Ifs.decl"get "IfsFiles.decl"get "IfsDirs.decl"get "IfsRS.decl"get "CmdScan.decl"get "Pup0.decl"external[// outgoing proceduresChangeDirSubcommand// incoming proceduresGetString; GetNumber; SelectKeyword; GetGroupMask; DefaultPhraseDefaultTemplateEnumeratePupAddresses; PasswordSysFree; FreePointer; Zero; SetBlock; MoveBlock; CopyStringWss; Puts; Errors// incoming staticsdsp; CtxRunning]//---------------------------------------------------------------------------let ChangeDirSubcommand(cs, entry, lvName) be//---------------------------------------------------------------------------[let dif = lvName!1let new = lvName!2let yes = truelet whichProt = nilswitchon entry!0 into   [   case 1:  // Read      whichProt = offset DIF.readProt/16; endcase   case 2:  // Write      whichProt = offset DIF.writeProt/16; endcase   case 3:  // Append      whichProt = offset DIF.appendProt/16; endcase   case 4:  // Create      whichProt = offset DIF.createProt/16; endcase   case 5:  // Connect      whichProt = offset DIF.connectProt/16; endcase   case 6:  // No      yes = false      docase SelectKeyword(cs, "Read", "Write", "Append", "Create", "Connect",       0, 0, "Printing-Server", 0,       (CtxRunning>>RSCtx.userInfo>>UserInfo.capabilities.wheel? "Group", 0))   case 7:  // Reset      whichProt = selecton SelectKeyword(cs, "Default-File-Protection",       "Create-Protection", "Connect-Protection",        (CtxRunning>>RSCtx.userInfo>>UserInfo.capabilities.wheel? "Group", 0))       into         [         case 1: offset DIF.fileProt/16         case 2: offset DIF.createProt/16         case 3: offset DIF.connectProt/16         case 4: SelectKeyword(cs, "Membership", "Ownership") eq 1?             offset DIF.userGroups/16, offset DIF.ownedGroups/16         ]      Zero(dif+whichProt,       (whichProt eq offset DIF.fileProt/16? lenFileProt, lenProtection))      return   case 8:  // Printing-Server      [      unless yes do [ dif>>DIF.defaultPrinter.length = 0; return ]      Puts(dsp, $*s)      if dif>>DIF.defaultPrinter.length ne 0 then         DefaultPhrase(cs, lv dif>>DIF.defaultPrinter)      let host = GetString(cs, 0, Wss, "host name or net#host#")      let port = vec lenPort      if host>>String.length ne 0 &       (EnumeratePupAddresses(host, 0, port, true) ne 0 %        port>>Port.host eq 0) then         [ SysFree(host); Errors(cs, 0) ]      MoveBlock(lv dif>>DIF.defaultPrinter, host, lenDirName)      SysFree(host)      return      ]// ChangeDirSubcommand (cont'd)   case 9:  // Not      yes = false      docase 12+SelectKeyword(cs, "Files-only", "Wheel", "Mail")   case 10:  // Group      whichProt = SelectKeyword(cs, "Membership", "Ownership") eq 1?       offset DIF.userGroups/16, offset DIF.ownedGroups/16      endcase   case 11:  // Password      [      Puts(cs, $*s)      let password = GetString(cs, 0, Wss, "password")      test password>>String.length eq 0         ifso SetBlock(lv dif>>DIF.password, -1, size DIF.password/16)         ifnot Password(password, lv dif>>DIF.password, true)      SysFree(password)      return      ]   case 12:  // Disk-limit      [      Puts(cs, $*s)      DefaultTemplate(cs, "$UED", lv dif>>DIF.diskPageLimit)      let limit = vec 1      GetNumber(cs, 10, limit)      MoveBlock(lv dif>>DIF.diskPageLimit, limit, 2)      return      ]   case 13:  // Files-only      if yes then         [         Wss(cs, " (owner) ")         let owner = GetString(cs, 0, Wss, "directory owner")         CopyString(lv dif>>DIF.owner, owner)         SysFree(owner)         // New files-only directories should not be given mailboxes         // no matter what <Default-User> says.         if new then dif>>DIF.capabilities.mail = false	 ]      dif>>DIF.filesOnly = yes      return   case 14:  // Wheel      dif>>DIF.capabilities.wheel = yes      return   case 15:  // Mail      dif>>DIF.capabilities.mail = yes      return   ]// Here only for [No] Read|Write|Append|Create|Connect|Grouplet protection = vec lenProtection; Zero(protection, lenProtection)Wss(cs, (whichProt eq offset DIF.userGroups/16? " (in groups) ", whichProt eq offset DIF.ownedGroups/16? " (of groups) ", " (access to groups) "))let value = dif+whichProtif GetGroupMask(cs, protection, yes) then   Zero(value, lenProtection)for i = 0 to lenProtection-1 do   value!i = yes? value!i % protection!i, value!i & not protection!i]