-- ALEOut.mesa --    Edited by Sweet, September 5, 1980  5:19 PMDIRECTORY  ALEFormat,  ALEOps,  AltoDefs,  Ascii,  StreamDefs,  Table;ALEOut: PROGRAM IMPORTS ALEOps, StreamDefs, Table   EXPORTS ALEOps =  BEGIN OPEN ALEOps;-- tables defining the current symbol table  ptb, ltb: Table.Base; -- used for writing out the file  htb: Table.Base;  ssb: STRING;  lbb: Table.Base;  UpdateBases: Table.Notifier =     BEGIN    htb _ base[htType];    ssb _ LOOPHOLE[base[ssType], STRING];    lbb _ base[lbType];    ptb _ base[ptType];    ltb _ base[ltType];    END;  EveryPoint: PUBLIC PROC [action: PointScan] =    BEGIN    p: PTIndex;    limit: CARDINAL = Table.Bounds[ptType].size;    FOR p _ FIRST[PTIndex], p + SIZE[Point] WHILE 	LOOPHOLE[p, CARDINAL] < limit DO      [] _ action[p, @ptb[p]];      ENDLOOP;    END;  WritePicture: PUBLIC PROC [file: STRING] =    BEGIN OPEN StreamDefs;    sth: DiskHandle;    outHeader: ALEFormat.Header _ [];    CountPoints: PointScan =      BEGIN      outHeader.points.length _ 	outHeader.points.length + SIZE[ALEFormat.Point];      RETURN[FALSE];      END;    CountLines: LineScan =      BEGIN      outHeader.lines.length _ 	outHeader.lines.length + SIZE[ALEFormat.Line];      RETURN[FALSE];      END;    CountLabels: LabelScan =      BEGIN      outHeader.labels.length _ 	outHeader.labels.length + SIZE[ALEFormat.Label];      RETURN[FALSE];      END;    WritePoint: PointScan =      BEGIN      op: ALEFormat.Point _ [pos: pth.pos];      [] _ WriteBlock[sth, @op, SIZE[ALEFormat.Point]];      RETURN[FALSE];      END;    WriteLine: LineScan =      BEGIN      p1: ALEFormat.PointIndex = LOOPHOLE [	(LOOPHOLE[lth.p1, CARDINAL]/SIZE[ALEOps.Point]) *	SIZE[ALEFormat.Point]];      p2: ALEFormat.PointIndex = LOOPHOLE [	(LOOPHOLE[lth.p2, CARDINAL]/SIZE[ALEOps.Point]) *	SIZE[ALEFormat.Point]];      ol: ALEFormat.Line _	[width: lth.width, texture: lth.texture, p1: p1, p2: p2];      [] _ WriteBlock[sth, @ol, SIZE[ALEFormat.Line]];      RETURN[FALSE];      END;    WriteLabel: LabelScan =      BEGIN      olb: ALEFormat.Label _ [font: lbh.font, hti: lbh.hti, pos: lbh.pos, mode: lbh.mode];      [] _ WriteBlock[sth, @olb, SIZE[ALEFormat.Label]];      RETURN[FALSE];      END;          Table.AddNotify[UpdateBases];    outHeader.hash.length _ Table.Bounds[htType].size;    outHeader.string.length _ Table.Bounds[ssType].size;    EveryPoint[CountPoints];    [] _ AllLines[CountLines];    [] _ AllLabels[CountLabels];    outHeader.hash.offset _ LOOPHOLE[SIZE[ALEFormat.Header]];    outHeader.string.offset _ outHeader.hash.offset + outHeader.hash.length;    outHeader.points.offset _      outHeader.string.offset + outHeader.string.length;    outHeader.lines.offset _      outHeader.points.offset + outHeader.points.length;    outHeader.labels.offset _ outHeader.lines.offset + outHeader.lines.length;    sth _ NewWordStream[file, Write+Append];    [] _ WriteBlock[sth, @outHeader, SIZE[ALEFormat.Header]];    [] _ WriteBlock[sth, htb, outHeader.hash.length];    [] _ WriteBlock[sth, ssb, outHeader.string.length];    EveryPoint[WritePoint];    [] _ AllLines[WriteLine];    [] _ AllLabels[WriteLabel];    pictureChanged _ FALSE;    Table.DropNotify[UpdateBases];    sth.destroy[sth];    END;  END.