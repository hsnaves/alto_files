-- ALELinesB.mesa--   Edited by Sweet, 20-Jan-81 10:36:11DIRECTORY  ALEOps,  Inline,  Storage,  Table,  UserTerminal,  Window;ALELinesB: PROGRAM  IMPORTS ALEOps, Inline, Storage, Table, UserTerminal, Window  EXPORTS ALEOps =  BEGIN OPEN ALEOps;  ptb, ltb, lbb: Table.Base;  ALELinesBNotify: PUBLIC Table.Notifier =    BEGIN    ptb _ base[ptType];    ltb _ base[ltType];    lbb _ base[lbType];    END;  AddHoriz: PROCEDURE [l: LTIndex] =    BEGIN    x1: ADistance = ptb[ltb[l].p1].pos.x;    x2: ADistance = ptb[ltb[l].p2].pos.x;    y: ADistance = ptb[ltb[l].p1].pos.y;    hi: INTEGER = FindHList[y, TRUE];    prev: LTIndex _ LTNull;    m: LTIndex _ hArray[hi].lines;    WHILE m # LTNull AND ptb[ltb[m].p1].pos.x < x1 DO      prev _ m; m _ ltb[m].thread;      ENDLOOP;    IF prev = LTNull THEN {hArray[hi].lines _ l; hArray[hi].l.min _ x1}    ELSE ltb[prev].thread _ l;    ltb[l].thread _ m;    hArray[hi].l.max _ MAX[hArray[hi].l.max, x2];    hArray[hi].maxW _ MAX[hArray[hi].maxW, ltb[l].width];    END;  AddVert: PROCEDURE [l: LTIndex] =    BEGIN    y1: ADistance = ptb[ltb[l].p1].pos.y;    y2: ADistance = ptb[ltb[l].p2].pos.y;    x: ADistance = ptb[ltb[l].p1].pos.x;    vi: INTEGER = FindVList[x, TRUE];    prev: LTIndex _ LTNull;    m: LTIndex _ vArray[vi].lines;    WHILE m # LTNull AND ptb[ltb[m].p1].pos.y < y1 DO      prev _ m; m _ ltb[m].thread;      ENDLOOP;    IF prev = LTNull THEN {vArray[vi].lines _ l; vArray[vi].l.min _ y1}    ELSE ltb[prev].thread _ l;    ltb[l].thread _ m;    vArray[vi].l.max _ MAX[vArray[vi].l.max, y2];    vArray[vi].maxW _ MAX[vArray[vi].maxW, ltb[l].width];    END;  ShouldLengthen: PUBLIC PROC [l: LTIndex] RETURNS [extra: [0..4]] =    BEGIN    CheckThis: LineScan =      BEGIN      IF lth.class = vert AND lth.p2 = endP THEN 	extra _ MAX[extra, lth.width];      RETURN[FALSE];      END;    endP: PTIndex = ltb[l].p2;    extra _ 0;    IF ltb[l].class = horiz THEN [] _ LinesThru[endP, CheckThis];    END;  MaybeDisplayLine: PUBLIC PROC [l: LTIndex] =    BEGIN    lBox: Window.Box _ BoxForLine[l];    vBox: Window.Box _ [      [x: -pictureWindow.box.place.x, y: -pictureWindow.box.place.y],      FrameBox.dims];    IF ~Disjoint[@lBox, @vBox] THEN DisplayLine[l, lBox]; -- conservative    END;  RedrawSelections: PUBLIC PROC =    BEGIN    CheckLine: LineScan  =      BEGIN      IF lth.width # state.currentWidth OR lth.texture # state.currentTexture THEN	BEGIN        Window.InvalidateBox[pictureWindow, BoxForLine[l]];        lth.width _ state.currentWidth;        lth.texture _ state.currentTexture;	END;      RETURN[FALSE];      END;    CheckLabel: LabelScan =      BEGIN      IF lbh.font # state.currentFont THEN	BEGIN	Window.InvalidateBox[pictureWindow, BoxForLabel[lb]];	lbh.font _ state.currentFont;	END;      RETURN[FALSE];      END;    [] _ SelectedLines[CheckLine];    [] _ SelectedLabels[CheckLabel];    END;  DrawLine: PUBLIC PROC [pos1, pos2: APosition, selected: BOOLEAN _ TRUE] =    BEGIN    l: LTIndex;    IF pos1 = pos2 THEN RETURN;    IF selected THEN ClearSelections[];    l _ InsertLine[      InsertPoint[pos1],      InsertPoint[pos2],      state.currentWidth,      state.currentTexture];    ltb[l].selected _ selected;    IF selected THEN header.selectedLines _ l;    MaybeDisplayLine[l];    END;  InsertLine: PROC [p1, p2: PTIndex, width: LineWidth, texture: LineTexture]       RETURNS [newL: LTIndex] =    BEGIN    pos1: APosition;    pos2: APosition;    pTemp: PTIndex;    FindP2: LineScan =      BEGIN      p: PTIndex = IF ltb[l].p1 = p1 THEN ltb[l].p2 ELSE ltb[l].p1;      RETURN [p = p2];      END;    newL _ LinesThru[p1, FindP2];    IF newL # LTNull THEN      BEGIN      Window.InvalidateBox[pictureWindow, BoxForLine[newL]];      ltb[newL].width _ width;      ltb[newL].texture _ texture;      ltb[newL].selected _ TRUE;      RETURN      END;    pos1 _ ptb[p1].pos;    pos2 _ ptb[p2].pos;    SELECT pos1.x FROM      < pos2.x => NULL;      > pos2.x => {pTemp _ p1; p1 _ p2; p2 _ pTemp};      ENDCASE => IF pos1.y > pos2.y THEN	{pTemp _ p1; p1 _ p2; p2 _ pTemp};    newL _ AllocateLine[];    ltb[newL] _ [      p1: p1, p1Chain: ptb[p1].lines,      p2: p2, p2Chain: ptb[p2].lines,      width: width, texture: texture, class: NULL];    ptb[p1].lines _ newL;    ptb[p2].lines _ newL;    ltb[newL].class _ SELECT TRUE FROM      pos1.x = pos2.x => vert,      pos1.y = pos2.y => horiz,      ABS[pos1.x-pos2.x] <= ABS[pos1.y-pos2.y] => steep,      ENDCASE => shallow;    SELECT ltb[newL].class FROM      horiz => AddHoriz[newL];      vert => AddVert[newL];      ENDCASE =>	{ltb[newL].thread _ header.diagLines; header.diagLines _ newL};    END;  AllocateLine: PROC RETURNS [l: LTIndex] =    BEGIN    IF (l _ header.freeLine) # LTNull THEN      BEGIN      header.freeLine _ ltb[LOOPHOLE[header.freeLine, FNIndex]].next;      RETURN      END;    l _ Table.Allocate[ltType, SIZE[Line]];    END;  InsertPoint: PROC [pos: APosition] RETURNS [newP: PTIndex] =    BEGIN    hi: INTEGER = FindHList[pos.y, TRUE];    follows: PTIndex _ PTNull;    next: PTIndex;    newP _ hArray[hi].points;    WHILE newP # PTNull DO      SELECT ptb[newP].pos.x FROM	< pos.x => NULL;	> pos.x => EXIT;	ENDCASE => RETURN;      follows _ newP;      newP _ ptb[follows].thread;      ENDLOOP;    next _ IF follows = PTNull THEN hArray[hi].points      ELSE ptb[follows].thread;    newP _ AllocatePoint[];    ptb[newP] _ [pos: pos, thread: next];    IF follows = PTNull THEN hArray[hi].points _ newP    ELSE ptb[follows].thread _ newP;    hArray[hi].p.max _ MAX[hArray[hi].p.max, pos.x];    hArray[hi].p.min _ MIN[hArray[hi].p.min, pos.x];    END;  AllocatePoint: PROC RETURNS [p: PTIndex] =    BEGIN    IF (p _ header.freePoint) # PTNull THEN      BEGIN      header.freePoint _ ptb[LOOPHOLE[header.freePoint, FNIndex]].next;      RETURN      END;    p _ Table.Allocate[ptType, SIZE[Point]];    END;  DrawnWidth: ARRAY [-3..4] OF CARDINAL = [1, 1, 1, 1, 1, 2, 4, 4];  BoxForLine: PUBLIC PROC [l: LTIndex] RETURNS [box: Window.Box] =    BEGIN    pos1: APosition = ptb[ltb[l].p1].pos;    pos2: APosition = ptb[ltb[l].p2].pos;    x1: ADistance = MIN[pos1.x, pos2.x];    y1: ADistance = MIN[pos1.y, pos2.y];    width: CARDINAL = ltb[l].width * DrawnWidth[state.magnify];    w: CARDINAL _ MAX[DotsForADistance[ABS[pos1.x-pos2.x]], 1];    h: CARDINAL _ MAX[DotsForADistance[ABS[pos1.y-pos2.y]], 1];    IF ltb[l].class >= steep THEN w _ w + width    ELSE h _ h + width;    IF ltb[l].class = horiz THEN      w _ w + ShouldLengthen[l] * DrawnWidth[state.magnify];    RETURN [[PicturePlace[[x: x1, y: y1]], [w: w, h: h]]];    END;  DisplayLine: PUBLIC PROC [l: LTIndex, box: Window.Box] =    BEGIN    aBox: ABox _ ABoxForBox[box];    ChopUpLine[l, @aBox, DisplaySolidLine];    END;  Hypot: PUBLIC PROC [a,b: LONG INTEGER] RETURNS [LONG INTEGER] =    BEGIN    factor: LONG INTEGER _ 1;    c: LONG INTEGER;    a _ ABS[a]; b _ ABS[b];    WHILE a > LAST[INTEGER]/2 OR b > LAST[INTEGER]/2 DO      a _ a/2; b _ b/2; factor _ factor * 2;      ENDLOOP;    c _ Sqrt[a*a+b*b];    RETURN [c*factor];    END;  ChopUpLine: PUBLIC PROC [l: LTIndex, box: POINTER TO ABox, pproc: PROC [      pos1, pos2: APosition,       class: LineClass,       color: LineColor,       lWidth: LineWidth,       lengthen: [0..4],       box: POINTER TO ABox]] =    BEGIN    marksRemoved: BOOLEAN _ FALSE;    inch: ADistance = 16;    tex: LineTexture = ltb[l].texture;    dash: ADistance _ SELECT tex FROM      d2 => 2*inch,      d4 => 4*inch,      ENDCASE => 6*inch; -- solid will ignore this value    gap: ADistance _ inch;    class: LineClass = ltb[l].class;    width: LineWidth = ltb[l].width;    pos1: APosition _ ptb[ltb[l].p1].pos;    pos2: APosition _ ptb[ltb[l].p2].pos;    segstart: APosition;    solidColor: LineColor = IF ltb[l].selected THEN grey ELSE black;    length, ends: ADistance;    lengthen: [0..4] _ 0;    SELECT class FROM      horiz => {length _ pos2.x - pos1.x; lengthen _ ShouldLengthen[l]};      vert => length _ pos2.y - pos1.y;      ENDCASE =>	BEGIN        MarksOut[]; marksRemoved _ TRUE;        length _ Hypot[pos2.x - pos1.x, pos2.y - pos1.y];	END;    IF tex = solid OR length < dash+2*gap THEN       {pproc[pos1, pos2, class, solidColor, width, lengthen, box];      IF marksRemoved THEN MarksIn[];      RETURN};    SELECT class FROM      horiz => 	BEGIN	DoSeg: PROC [sl: ADistance, sc: LineColor, lengthen: [0..4] _ 0] =          BEGIN	  segstop: APosition _ [x: segstart.x + sl, y: segstart.y];	  pproc[	    pos1: segstart, 	    pos2: segstop, 	    class: class, 	    color: sc, 	    lWidth: width, 	    lengthen: lengthen, 	    box: box];	  segstart _ segstop;	  END;	ends _ (dash + (length - dash - gap) MOD (dash+gap))/2;	segstart _ pos1;	DoSeg[ends, solidColor];	DoSeg[gap, white];	WHILE segstart.x + dash + gap < pos2.x DO	  DoSeg[dash, solidColor];	  DoSeg[gap, white];	  ENDLOOP;	DoSeg[pos2.x - segstart.x, solidColor, lengthen];	END;      vert => 	BEGIN	DoSeg: PROC [sl: ADistance, sc: LineColor] =          BEGIN	  segstop: APosition _ [x: segstart.x, y: segstart.y + sl];	  pproc[	    pos1: segstart, 	    pos2: segstop, 	    class: class, 	    color: sc, 	    lWidth: width, 	    lengthen: 0, 	    box: box];	  segstart _ segstop;	  END;	ends _ (dash + (length - dash - gap) MOD (dash+gap))/2;	segstart _ pos1;	DoSeg[ends, solidColor];	DoSeg[gap, white];	WHILE segstart.y + dash + gap < pos2.y DO	  DoSeg[dash, solidColor];	  DoSeg[gap, white];	  ENDLOOP;	DoSeg[pos2.y - segstart.y, solidColor];	END;      steep =>	BEGIN        deltaY: ADistance = pos2.y - pos1.y;	deltaX: ADistance = pos2.x - pos1.x;	dir: INTEGER = IF deltaY < 0 THEN -1 ELSE 1;	G: PROC [y: ADistance] RETURNS [x: ADistance] =	  BEGIN	  x _ pos1.x +  MulDiv[(y - pos1.y), deltaX, deltaY];	  END;	DoSeg: PROC [sl: ADistance, sc: LineColor] =          BEGIN	  segstop: APosition;	  segstop.y _ segstart.y + sl*dir;	  segstop.x _ G[segstop.y];	  pproc[	    pos1: segstart, 	    pos2: segstop, 	    class: class, 	    color: sc, 	    lWidth: width, 	    lengthen: 0, 	    box: box];	  segstart _ segstop;	  END;	dash _ MulDiv[dash, ABS[deltaY], length];	gap _ MulDiv[gap, ABS[deltaY], length];	gap _ MAX [gap, ADistanceForDots[1]];	ends _ (dash + (ABS[pos1.y-pos2.y] - dash - gap) MOD (dash+gap))/2;	segstart _ pos1;	DoSeg[ends, solidColor];	DoSeg[gap, white];	WHILE (segstart.y + dir*(dash + gap) - pos2.y)*dir < 0 DO	  DoSeg[dash, solidColor];	  DoSeg[gap, white];	  ENDLOOP;	DoSeg[ABS[pos2.y - segstart.y], solidColor];	END;      ENDCASE => -- shallow	BEGIN        deltaY: ADistance = pos2.y - pos1.y;	deltaX: ADistance = pos2.x - pos1.x;	F: PROC [x: ADistance] RETURNS [y: ADistance] =	  BEGIN	  y _ pos1.y + MulDiv[(x - pos1.x), deltaY, deltaX];	  END;	DoSeg: PROC [sl: ADistance, sc: LineColor] =          BEGIN	  segstop: APosition;	  segstop.x _ segstart.x + sl;	  segstop.y _ F[segstop.x];	  pproc[	    pos1: segstart, 	    pos2: segstop, 	    class: class, 	    color: sc, 	    lWidth: width, 	    lengthen: 0, 	    box: box];	  segstart _ segstop;	  END;	dash _ MulDiv[dash, deltaX, length];	gap _ MulDiv[gap, deltaX, length];	gap _ MAX [gap, ADistanceForDots[1]];	ends _ (dash + (pos2.x - pos1.x - dash - gap) MOD (dash+gap))/2;	segstart _ pos1;	DoSeg[ends, solidColor];	DoSeg[gap, white];	WHILE segstart.x + dash + gap < pos2.x DO	  DoSeg[dash, solidColor];	  DoSeg[gap, white];	  ENDLOOP;	DoSeg[pos2.x - segstart.x, solidColor];	END;    IF marksRemoved THEN MarksIn[];    END;  DisplaySolidLine: PROC [pos1, pos2: APosition, class: LineClass, color: LineColor, lWidth: LineWidth, lengthen: [0..4], box: POINTER TO ABox] =    BEGIN    deltaY, deltaX: LONG INTEGER;    start, stop, current, leftCorner, rightCorner: Window.Place;    width: CARDINAL = lWidth * DrawnWidth[state.magnify];    drawn: BOOLEAN _ FALSE;    chunkBox: Window.Box;    F: PROC [x: INTEGER] RETURNS [y: INTEGER] =      BEGIN      y _ start.y + Inline.LowHalf[ MulDiv[(x - start.x), deltaY, deltaX]]      END;    G: PROC [y: INTEGER] RETURNS [x: INTEGER] =      BEGIN      x _ start.x + Inline.LowHalf[ MulDiv[(y - start.y), deltaX, deltaY]]      END;    IF color = white THEN RETURN; -- try not painting white part    leftCorner _ PicturePlace[[box.x1, box.y1]];    rightCorner _ PicturePlace[[box.x2, box.y2]];    start _ PicturePlace[pos1];    stop _ PicturePlace[pos2];    SELECT class FROM      horiz => 	BEGIN	start.x _ MAX[start.x, leftCorner.x];	stop.x _ MIN[stop.x, rightCorner.x];        IF start.x < stop.x THEN Window.DisplayShade[	  pictureWindow,	  [start, 	    [w: stop.x - start.x + lengthen*DrawnWidth[state.magnify], h: width]],	  GreyColor[color]];	RETURN	END;      vert => 	BEGIN	start.y _ MAX[start.y, leftCorner.y];	stop.y _ MIN[stop.y, rightCorner.y];        IF start.y < stop.y THEN Window.DisplayShade[	  pictureWindow,	  [start, [w: width, h: stop.y - start.y]],	  GreyColor[color]];	RETURN	END;      ENDCASE;    deltaY _ stop.y - start.y;    deltaX _ stop.x - start.x;    IF class = steep THEN      BEGIN      negSlope: BOOLEAN _ FALSE;      limitY: INTEGER;      PaintChunk: PROC [Window.Handle] RETURNS [Window.Box, INTEGER] =        BEGIN        h: INTEGER;        DO          IF negSlope THEN {IF current.y <= limitY THEN EXIT}          ELSE IF current.y >= limitY THEN EXIT;	  h _ MAX [ABS[current.y - F[current.x+1]], 1];          h _ MIN [ABS[limitY - current.y], h];          IF negSlope THEN            chunkBox _ [[current.x, current.y-h], [w: width, h: h]]          ELSE chunkBox _ [current, [w: width, h: h]];          current.x _ current.x + 1;          current.y _ current.y + (IF negSlope THEN -h ELSE h);          RETURN [chunkBox, 0];          ENDLOOP;        RETURN [Window.NullBox, 0];        END;      IF deltaY < 0 THEN	{limitY _ MAX[stop.y, leftCorner.y];	current.y _ MIN[start.y, rightCorner.y];	negSlope _ TRUE}      ELSE	{limitY _ MIN[stop.y, rightCorner.y];	current.y _ MAX[start.y, leftCorner.y]};      current.x _ G[current.y];      Window.Trajectory[        window: pictureWindow,        box: WindowBox[box],        proc: PaintChunk,	bbop: replace,        bbsource: gray, -- why can't they agree on spelling?        grey: GreyColor[color]];      END    ELSE -- shallow      BEGIN      negSlope: BOOLEAN _ FALSE;      dy: INTEGER;      limitX: INTEGER = MIN[stop.x, rightCorner.x];      PaintChunk: PROC [Window.Handle] RETURNS [Window.Box, INTEGER] =        BEGIN        w: INTEGER;        DO          IF current.x >= limitX THEN EXIT;          w _ MAX[G[current.y+dy] - current.x, 1];          w _ MIN[stop.x - current.x, w];          IF negSlope THEN            chunkBox _ [[current.x, current.y-1], [w: w, h: width]]          ELSE chunkBox _ [current, [w: w, h: width]];          current.x _ current.x + w;          current.y _ current.y + dy;          RETURN [chunkBox, 0];          ENDLOOP;        RETURN [Window.NullBox, 0];        END;      IF deltaY < 0 THEN {dy _ -1; negSlope _ TRUE} ELSE dy _ 1;      current.x _ MAX[start.x, leftCorner.x];      current.y _ F[current.x];      Window.Trajectory[        window: pictureWindow,        box: WindowBox[box],        proc: PaintChunk,	bbop: replace,        bbsource: gray,        grey: GreyColor[color]];      END;    END;  WindowBox: PROC [box: POINTER TO ABox] RETURNS [Window.Box] =    BEGIN    place: Window.Place _ PicturePlace[[box.x1, box.y1]];    RETURN [[place,      [w: MAX[DotsForADistance[box.x2-box.x1], 1],      h: MAX[DotsForADistance[box.y2 - box.y1], 1]]]];    END;  pending: Redraw _ NIL;  CopySelections: PUBLIC PROC [delta: APosition] =    BEGIN    originalSource: APosition = Absolute[GetSourcePos[FALSE]];    CopyLine: LineScan =      BEGIN      IF lth.selected THEN	BEGIN	new: Redraw = Storage.Node[SIZE[line RedrawObject]];	pos1: APosition = ptb[lth.p1].pos;	pos2: APosition = ptb[lth.p2].pos;	new^ _ [next: pending, var: line[	  pos1: [pos1.x + delta.x, pos1.y + delta.y],	  pos2: [pos2.x + delta.x, pos2.y + delta.y],	  width: lth.width,	  texture: lth.texture]];        lth.selected _ FALSE;	MaybeDisplayLine[l];	pending _ new;	END;      RETURN[FALSE];      END;    CopyLabel: LabelScan =      BEGIN      IF lbh.selected THEN	BEGIN	new: Redraw = Storage.Node[SIZE[label RedrawObject]];	pos: APosition = lbh.pos;	new^ _ [next: pending, var: label[	  font: lbh.font, mode: lbh.mode,	  pos: [pos.x + delta.x, pos.y + delta.y],	  hti: lbh.hti]];	pending _ new;        lbh.selected _ FALSE;	PaintLabel[lb];	END;      RETURN[FALSE];      END;    IF BadMove[delta] THEN RETURN;    [] _ SelectedLines[CopyLine];    [] _ SelectedLabels[CopyLabel];    header.selectedLines _ LTNull;    header.selectedLabels _ LBNull;    RedrawItems[pending];    pending _ NIL;    ASetSourcePos[[x: originalSource.x + delta.x,      y: originalSource.y + delta.y]];    ASetDestPos[[x: originalSource.x + 2*delta.x,      y: originalSource.y + 2*delta.y]];    END;  BadMove: PROC [delta: APosition] RETURNS [BOOLEAN] =    BEGIN    BadPoint: PointScan =      BEGIN      RETURN [pth.selected AND 	(pth.pos.x + delta.x < 0 OR pth.pos.y + delta.y < 0)];      END;    BadLine: LineScan =      BEGIN      p1: PTIndex = lth.p1;      p2: PTIndex = lth.p2;      RETURN [lth.selected AND	(ptb[p1].pos.x + delta.x < 0 OR ptb[p1].pos.y + delta.y < 0 OR	 ptb[p2].pos.x + delta.x < 0 OR ptb[p2].pos.y + delta.y < 0)]      END;    BadLabel: LabelScan =      BEGIN      RETURN [lbh.selected AND 	(lbh.pos.x + delta.x < 0 OR lbh.pos.y + delta.y < 0)];      END;    IF delta.x > 0 AND delta.y > 0 THEN RETURN[FALSE];    IF AllPoints[BadPoint] # PTNull THEN GO TO bad;    IF AllLines[BadLine] # LTNull THEN GO TO bad;    IF AllLabels[BadLabel] # LBNull THEN GO TO bad;    RETURN[FALSE];    EXITS      bad => {UserTerminal.BlinkDisplay[]; RETURN[TRUE]};    END;  MoveSelections: PUBLIC PROC [delta: APosition] =    BEGIN    originalSource: APosition = Absolute[GetSourcePos[FALSE]];    MoveLine: LineScan =      BEGIN      IF lth.selected THEN	BEGIN	new: Redraw = Storage.Node[SIZE[line RedrawObject]];	pos1: APosition = ptb[lth.p1].pos;	pos2: APosition = ptb[lth.p2].pos;	new^ _ [next: pending, var: line[	  pos1: [pos1.x + delta.x, pos1.y + delta.y],	  pos2: [pos2.x + delta.x, pos2.y + delta.y],	  width: lth.width,	  texture: lth.texture]];	pending _ new;	DeleteLine[l];	END;      RETURN[FALSE];      END;    MoveLabel: LabelScan =      BEGIN      IF lbh.selected THEN	BEGIN	new: Redraw = Storage.Node[SIZE[label RedrawObject]];	pos: APosition = lbh.pos;	new^ _ [next: pending, var: label[	  font: lbh.font, mode: lbh.mode,	  pos: [pos.x + delta.x, pos.y + delta.y],	  hti: lbh.hti]];	pending _ new;	DeleteLabel[lb];	END;      RETURN[FALSE];      END;    MovePoint: PointScan =      BEGIN      IF pth.selected THEN	BEGIN	pos1: APosition = [x: pth.pos.x + delta.x, y: pth.pos.y + delta.y];	pBox: Window.Box = BoxForPoint[p];        StretchLine: LineScan =	  BEGIN	  other: PTIndex = IF lth.p1 = p THEN lth.p2 ELSE lth.p1;	  pos2: APosition _ ptb[other].pos;          new: Redraw = Storage.Node[SIZE[line RedrawObject]];	  IF ptb[other].selected THEN	    {pos2.x _ pos2.x + delta.x; pos2.y _ pos2.y + delta.y};	  new^ _ [next: pending, var: line[	    pos1: pos1, pos2: pos2, width: lth.width, texture: lth.texture]];	  pending _ new;	  DeleteLine[l];	  RETURN[FALSE];	  END;	Window.InvalidateBox[pictureWindow, pBox];	[] _ LinesThru[p, StretchLine];	END;      RETURN[FALSE];      END;    IF BadMove[delta] THEN RETURN;    [] _ SelectedLines[MoveLine];    [] _ SelectedLabels[MoveLabel];    [] _ SelectedPoints[MovePoint];    header.selectedLines _ LTNull;    header.selectedPoints _ PTNull;    header.selectedLabels _ LBNull;    Window.ValidateTree[];    RedrawItems[pending];    pending _ NIL;    ASetSourcePos[[x: originalSource.x + delta.x,      y: originalSource.y + delta.y]];    ASetDestPos[originalSource];    END;  BadRotate: PROC [source, dest: APosition] RETURNS [BOOLEAN] =    BEGIN    BadLine: LineScan =      BEGIN      p1: PTIndex = lth.p1;      p2: PTIndex = lth.p2;      RETURN [lth.selected AND	(dest.x - (ptb[p1].pos.y - source.y) < 0 OR          dest.y + (ptb[p1].pos.x - source.x) < 0 OR	 dest.x - (ptb[p2].pos.y - source.y) < 0 OR          dest.y + (ptb[p2].pos.x - source.x) < 0)]      END;    BadLabel: LabelScan =      BEGIN      RETURN [lbh.selected AND 	(dest.x - (lbh.pos.y - source.y) < 0 OR          dest.y + (lbh.pos.x - source.x) < 0)];      END;    IF SelectedLines[BadLine] # LTNull THEN GO TO bad;    IF SelectedLabels[BadLabel] # LBNull THEN GO TO bad;    RETURN[FALSE];    EXITS      bad => {UserTerminal.BlinkDisplay[]; RETURN[TRUE]};    END;  MoveAndRotate: PUBLIC PROC [source, dest: APosition] =    BEGIN    originalSource: APosition = Absolute[GetSourcePos[FALSE]];    MoveLine: LineScan =      BEGIN      IF lth.selected THEN	BEGIN	new: Redraw = Storage.Node[SIZE[line RedrawObject]];	pos1: APosition = ptb[lth.p1].pos;	pos2: APosition = ptb[lth.p2].pos;	new^ _ [next: pending, var: line[	  pos1: [dest.x - (pos1.y - source.y), dest.y + (pos1.x - source.x)],	  pos2: [dest.x - (pos2.y - source.y), dest.y + (pos2.x - source.x)],	  width: lth.width,	  texture: lth.texture]];	pending _ new;	DeleteLine[l];	END;      RETURN[FALSE];      END;    MoveLabel: LabelScan =      BEGIN      IF lbh.selected THEN	BEGIN	new: Redraw = Storage.Node[SIZE[label RedrawObject]];	pos: APosition = lbh.pos;	new^ _ [next: pending, var: label[	  font: lbh.font, mode: lbh.mode,	  pos: [dest.x - (pos.y - source.y), dest.y + (pos.x - source.x)],	  hti: lbh.hti]];	pending _ new;	DeleteLabel[lb];	END;      RETURN[FALSE];      END;    IF BadRotate[source, dest] THEN RETURN;    [] _ SelectedLines[MoveLine];    [] _ SelectedLabels[MoveLabel];    header.selectedLines _ LTNull;    header.selectedLabels _ LBNull;    ClearSelections[];    Window.ValidateTree[];    RedrawItems[pending];    pending _ NIL;    END;  RedrawItems: PUBLIC PROC [rd: Redraw] =    BEGIN    WHILE rd # NIL DO      this: Redraw = rd;      WITH this SELECT FROM	line => 	  BEGIN	  l: LTIndex = InsertLine[	    InsertPoint[pos1], InsertPoint[pos2], width, texture];	  ltb[l].selNext _ header.selectedLines;	  header.selectedLines _ l;	  MaybeDisplayLine[l];	  END;	label => 	  BEGIN	  lb: LBIndex = 	    InsertLabel[pos: pos, hti: hti, font: font, mode: mode];	  lbb[lb].selNext _ header.selectedLabels;	  header.selectedLabels _ lb;	  PaintLabel[lb];	  END;        ENDCASE;      rd _ this.next;      ENDLOOP;    END;  END.