-- ALEIn.mesa--   Edited by Sweet,  9-Oct-80 23:31:58DIRECTORY  ALEFormat,  ALEOps,  AltoDefs,  SegmentDefs,  String,  Table;ALEIn: PROGRAM  IMPORTS ALEOps, SegmentDefs  EXPORTS ALEOps =  BEGIN  htb: Table.Base;  ssb: STRING;  ht: DESCRIPTOR FOR ARRAY ALEOps.HTIndex OF ALEOps.HTRecord;  lineBase, pointBase, labelBase: ALEFormat.SubTableBase;  header: ALEFormat.PictureBase;  LineEnum: TYPE = PROCEDURE [l: POINTER TO ALEFormat.Line];  LabelEnum: TYPE = PROCEDURE [lb: POINTER TO ALEFormat.Label];  AllMyLines: PROC [action: LineEnum] =    BEGIN OPEN ALEFormat;    l: LineIndex;    FOR l _ FIRST[LineIndex], l + SIZE[Line] WHILE	 LOOPHOLE[l, CARDINAL] < header.lines.length DO      action[@lineBase[l]];      ENDLOOP;    END;  AllMyLabels: PROC [action: LabelEnum] =    BEGIN OPEN ALEFormat;    lb: LabelIndex;    FOR lb _ FIRST[LabelIndex], lb + SIZE[Label] WHILE 	LOOPHOLE[lb, CARDINAL] < header.labels.length DO      action[@labelBase[lb]];      ENDLOOP;    END;  seg: SegmentDefs.FileSegmentHandle;   ReadPicture: PUBLIC PROC [file: STRING] =    BEGIN OPEN SegmentDefs;    fh: FileHandle = NewFile[file, Read! FileNameError => GO TO cant];    saveState: ALEOps.State _ ALEOps.state;    AddThisLine: LineEnum =      BEGIN      pos1: ALEOps.APosition = [        x: pointBase[l.p1].pos.x,	y: pointBase[l.p1].pos.y];      pos2: ALEOps.APosition = [        x: pointBase[l.p2].pos.x,	y: pointBase[l.p2].pos.y];      ALEOps.state.currentWidth _ l.width;      ALEOps.state.currentTexture _ l.texture;      ALEOps.DrawLine[pos1, pos2, FALSE];      END;    AddThisLabel: LabelEnum =      BEGIN      desc: String.SubStringDescriptor;      pos: ALEOps.APosition = [        x: lb.pos.x,	y: lb.pos.y];      SubStringForHash[@desc, lb.hti];      ALEOps.SSDrawLabel[@desc, pos, lb.font, lb.mode];      END;    seg _ NewFileSegment[fh, DefaultBase, DefaultPages, Read];    SwapIn[seg];    header _ FileSegmentAddress[seg];    IF header.password # ALEFormat.Password THEN GO TO badFormat;    htb _ LOOPHOLE[@header[header.hash.offset]];    ht _ DESCRIPTOR[htb, header.hash.length/SIZE[ALEOps.HTRecord]];    ssb _ LOOPHOLE[@header[header.string.offset]];    pointBase _ @header[header.points.offset];    lineBase _ @header[header.lines.offset];    labelBase _ @header[header.labels.offset];    AllMyLines[AddThisLine];    AllMyLabels[AddThisLabel];    ALEOps.ClearText[];    Unlock[seg];    DeleteFileSegment[seg];    ALEOps.state _ saveState;    EXITS      cant => ALEOps.OutString[" not found"L];      badFormat => 	BEGIN	ALEOps.OutString[" - bad format"L];	Unlock[seg];	DeleteFileSegment[seg];	END;    END;  SubString: TYPE = String.SubString;  SubStringForHash: PROC [s: SubString, hti: ALEOps.HTIndex] = {    s.base _ ssb;    IF hti = ALEOps.HTNull      THEN s.offset _ s.length _ 0      ELSE s.length _ ht[hti].ssIndex - (s.offset _ ht[hti-1].ssIndex)};  END.