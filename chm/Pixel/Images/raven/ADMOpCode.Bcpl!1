//	BASIC CROSS ASSEMBLER//	Extra Opcode Routines - for the Xerox LCC processor//	Q[uit] X will time stamp and compile.//	//	//	last modified (8 Sept. 1982 12:07 pm PDT (Wednesday))get "bcastruct.bcpl"let OpcodeDefRtn() be	[ NoParClass(0)	PgZClass(0)	ImmClass(0)	I40DClass(0)	I40DAClass(0)	I40DDClass(0)	I40AClass(0)	LccIOClass(0)	LccCompareAndJumpClass(0)	LccNoOp2Class(0)	Lcc3BitOpClass(0)	ADMmpmOp(0)	]//We whimsically decided to add another op class here for the ADM// --G&D enterprisesand ADMmpmOp(pass, value) = valof    //this is a special op to generate the mpm instruction	[ switchon pass into		[		case 0:AddOpcodeClass("@ADMmpmOp", ADMmpmOp)			endcase		case 1: resultis 2		case 2:			[ let Expr = vec size E/WORDSIZE			MustHaveKExpressions(1,1, Expr)			ValueGen(255)			ValueGen(value+FORCEFIELD(Expr, -16, 15, 12, 15))			]			endcase		default:		]	resultis 0	]and NoParClass(pass, value) = valof	[ switchon pass into		[		case 0: AddOpcodeClass("@noparclass", NoParClass)			endcase		case 1:	resultis 1	//Total bytes of code generated this line.		case 2: ValueGen(value)			endcase		default:		]	resultis 0	]and PgZClass(pass, value) = valof	[ switchon pass into		[		case 0: AddOpcodeClass("@pgzclass", PgZClass)			endcase		case 1:	resultis 2		case 2:			[ ValueGen(value)			let Expr = vec size E/WORDSIZE			MustHaveKExpressions(1, 1, Expr)			ExprGen(Expr, EntireAddr)			]			endcase		default:		]	resultis 0	]and ImmClass(pass, value) = valof	[ switchon pass into		[		case 0: AddOpcodeClass("@immclass", ImmClass)			endcase		case 1:	resultis 2		case 2:			[ ValueGen(value)			let Expr = vec size E/WORDSIZE			let Expr2 = vec size E/WORDSIZE			let k = MustHaveKExpressions(2, 1, Expr, Expr2)			let relocation = AnyByte			if k gr 1 then			 relocation = selecton FORCEFIELD(Expr2, 0, 2, 0, 15) into					[					case 0: EntireAddr					case 1: HighByte					case 2: LowByte				]			ExprGen(Expr, relocation)			]			endcase		default:		]	resultis 0	]and Lcc3BitOpClass(pass, value) = valof	[ switchon pass into		[		case 0:AddOpcodeClass("@lcc3bitopclass", Lcc3BitOpClass)			endcase		case 1: resultis 1		case 2:			[ let Expr = vec size E/WORDSIZE			MustHaveKExpressions(1,1, Expr)			ValueGen(value+FORCEFIELD(Expr, 0, 7, 13, 15))			]			endcase		default:		]	resultis 0	]and LccIOClass(pass, value) = valof	[ switchon pass into		[		case 0:AddOpcodeClass("@lccioopclass", LccIOClass)			endcase		case 1: resultis 2		case 2:			[ let Expr = vec size E/WORDSIZE			let Expr2 = vec size E/WORDSIZE			MustHaveKExpressions(2,2, Expr, Expr2)			ValueGen(value+FORCEFIELD(Expr, -16, 15, 12, 15))			ExprGen(Expr2, EntireAddr)			]			endcase		default:		]	resultis 0	]and I40DClass(pass, value) = valof	[ switchon pass into		[		case 0:AddOpcodeClass("@40dclass", I40DClass)			endcase		case 1: resultis 1		case 2:			[ let Expr = vec size E/WORDSIZE			MustHaveKExpressions(1,1, Expr)			ValueGen(value+FORCEFIELD(Expr, -16, 15, 12, 15))			]			endcase		default:		]	resultis 0	]and I40DAClass(pass, value) = valof	[ switchon pass into		[ case 0:AddOpcodeClass("@40daclass", I40DAClass)			endcase		case 1: resultis 2		case 2:			[ let Expr = vec size E/WORDSIZE			let Expr2 = vec size E/WORDSIZE			MustHaveKExpressions(2,2, Expr, Expr2)			ValueGen(value+FORCEFIELD(Expr, -16, 15, 12, 15))			let DestPC = FORCEFIELD(Expr2, 0, 4095, 0, 15)			ValueGen(FORCEVALUE(DestPC xor				((PCAtBegin+1)&#7400), 0, 255, 8, 15))			]			endcase		default:		]	resultis 0	]and I40DDClass(pass, value) = valof	[ switchon pass into		[ case 0:AddOpcodeClass("@40ddclass", I40DDClass)			endcase		case 1: resultis 2		case 2:			[ let Expr = vec size E/WORDSIZE			let Expr2 = vec size E/WORDSIZE			MustHaveKExpressions(2,2, Expr, Expr2)			ValueGen(value+FORCEFIELD(Expr, -16, 15, 12, 15))			ExprGen(Expr2, AnyByte)			]			endcase		default:		]	resultis 0	]and I40AClass(pass, value) = valof	[ switchon pass into		[		case 0:AddOpcodeClass("@40aclass", I40AClass)			endcase		case 1: resultis 2		case 2:			[ let Expr = vec size E/WORDSIZE			MustHaveKExpressions(1,1, Expr)			Expr>>E.value = Expr>>E.value+(value lshift 8)			ExprGen(Expr, HighByte)			ExprGen(Expr, LowByte)			]			endcase		default:		]	resultis 0	]and LccCompareAndJumpClass(pass, value) = valof	[ switchon pass into		[		case 0:AddOpcodeClass("@lcccompareandjumpclass",				LccCompareAndJumpClass)			endcase		case 1: resultis 3		case 2:			[ let Expr = vec size E/WORDSIZE			let Expr2 = vec size E/WORDSIZE			let Expr3 = vec size E/WORDSIZE			MustHaveKExpressions(3,3, Expr, Expr2, Expr3)			ValueGen(value+FORCEFIELD(Expr, 0, 15, 12, 15))			ValueGen(FORCEFIELD(Expr2, -128, 255, 8, 15))			let DestPC = FORCEFIELD(Expr3, 0, 4095, 0, 15)			ValueGen(FORCEVALUE(DestPC xor				((PCAtBegin+2)&#7400), 0, 255, 8, 15))			]			endcase		default:		]	resultis 0	]and LccNoOp2Class(pass, value) = valof	[ switchon pass into		[		case 0:AddOpcodeClass("@lccnoop2class", LccNoOp2Class)			endcase		case 1: resultis 3		case 2: ValueGen(value)					ValueGen(0)					ValueGen(0)			endcase		default:		]	resultis 0	](635)