; ***************************************************;   6801 slot control;6 April 1982 2:51 pm PST (Tuesday);****************************************************;ram equates;****************************************************.getnolist "m6801predefs.sr".getnolist "lsepdefs.bca"datadir1 = 00000 ;  data direction register 1datadir2 = 00001 ;  data direction register 2ipoprt1  = 00002 ;  ipo port 1 ipoprt2  = 00003 ;  ipo port 2datadir3 = 00004 ;  data direction register 3(not used)datadir4 = 00005 ;  data direction register 4(not used)ipoprt3  = 00006 ;  ipo port 3(not used) ipoprt4  = 00007 ;  ipo port 4(not used)tcsr     = 00008 ; timer control status registercntrhi   = 00009 ; counter high bytecntrlo   = 0000a ; counter low byteoutcmphi = 0000b ; output compare high byteoutcmplo = 0000c ; output compare low byteinpcaphi = 0000d ; input capture high byteinpcaplo = 0000e ; input capture low byteipoprt3cs= 0000f ; ipo port 3 control,status registerserate   = 00010 ; serial rate and mode register sercon   = 00011 ; serial control and status registerserrx    = 00012 ; serial receiver data registersertx    = 00013 ; serial transmit data registerramcon   = 00014 ; rampeprom control register; ***************************************************; 15 to 1f hex reserved (don't ask); ***************************************************; interupt vector equates; ***************************************************restrtms = 0ffferestrtls = 0ffff ; restart vectornmims    = 0fffc nmils    = 0fffd ; nonmaskable interuptswims    = 0fffaswils    = 0fffb ; software interuptirq1ms   = 0fff8 irq1ls   = 0fff9 ; irq1 interupttcapms   = 0fff6tcapls   = 0fff7 ; timer input capture or irq 2 interupttcompms  = 0fff4 tcompls  = 0fff5 ; timer output compare or irq 2 interupttovms    = 0fff2 tovls    = 0fff3 ; timer overflow or irq 2 interupt serinms  = 0fff0 serinls  = 0fff1 ; serial ipo interupt;****************************************************; INIT the machine;****************************************************outchar  = 00080 ; output char addresswait     = 00500 ; counter wait time.loc 0f800;****************************************************; start ;****************************************************start :	ldaai 009 ; 	staae serate ;     set rate to 9600 baud CC1 1 CC0 0 S1 0 S0 1  	ldaai 00a ; 	staae sercon ;     set tx and rx enableInit1 :	ldaai 0a0 ;	staae outchar ;start1 :	ldaae outchar ;	subai 0c8 ;	beq Init1 ;	ldaae outchar ;	addai 01;	staae outchar ;;for debugging, show we started here	ldaai $S	jsr OutPutChar;	ldaai $t	jsr OutPutChar	ldaai $a	jsr OutPutChar;	ldaai $r	jsr OutPutChar	ldaai $t	jsr OutPutChar;	ldaai $*N			;a carriage-ret	jsr OutPutChar;	ldxi  Lit1;	jsr OutString;;test the dispatch table hack: given a letter between a0 and c8,;dispatch into table and have routine dispatched to return that letter	ldabe outchar	jsr lookupChar;this should return the same character in ACa as it went in with	output1 :	ldabe sercon ; 	staae sertx ;        send letter ;	; 	TIMER ROUTINE		lddi wait			; load D with wait count		addde cntrhi		; add D to counter		clre tcsr			; clear timer control status reg		stde outcmphi	; set output compare		ldaai 040 ; ;		time1 :			bitae tcsr	; now wait for output compare flag			beq time1		; not yet; 	END TIMER;jmp start1; back to send the next charterlookupChar:	subbi 0a0;		subtract lowest value from acb	ldxi  PSTable;	put the base address into the index register	abx;				and add in the contents of AC b	ldxx 00;			load the memory location pointed to by IX reg.;now have the address of the routine we want to dispatch to in IX	jsrx 00;			call the procedure pointed to by the index register;should have ACa loaded with the proper result here	rts;PSTable:	.ADR PSkey0Proc;			--"a0"	.ADR PSkey1Proc;	.ADR PSkey2Proc;	.ADR PSkey3Proc;	.ADR PSkey4Proc;	.ADR PSkey5Proc;	.ADR PSkey6Proc;	.ADR PSkey7Proc;			--"a7"	.ADR PSkey8Proc;			--"a8" 	.ADR PSkey9Proc;	.ADR PSclearKeyProc;	.ADR PStestKeyProc;	.ADR PSonLineKeyProc;	.ADR PSoffLineKeyProc;	.ADR noopProc;	.ADR PSwaitProc;			--"AF"	.ADR PSstandbyProc;		B0	.ADR PSfeederFaultProc;	.ADR noopProc1;		.ADR PShardStop1Proc;	.ADR PShardStop2Proc;	.ADR PShardStop3Proc;	B5	.ADR PSsorterJamProc;	.ADR PSinterlockOpenProc;	.ADR PSfuserUnderTempProc;	.ADR PSrunFeedingProc;	.ADR PSrunReadyProc;	.ADR PSstatusDisplayedProc;	.ADR PScmdRejParityProc;	.ADR PScmdRejUnrecogProc;	.ADR PScmdRejIllSeqProc;	.ADR PScmdRejSorterDownProc;	BF	.ADR PSnoFeedTrayProc;			C0	.ADR PSpageSyncProc;	.ADR PSpageDeliveredProc;	.ADR PSpageDelveredSorterProc;	.ADR PScycleOffLIneProc;	.ADR PSoffLineProc;	.ADR PSonLineProc;	.ADR PSoutTrayFullProc;	.ADR PSstackerFullProc;		C8;the procs that are dispatched to:PSkey0Proc:	ldaai 0a0;	rts;							--"a0"PSkey1Proc:	ldaai 0a1;	rts;PSkey2Proc:	ldaai 0a2;	rts;PSkey3Proc:	ldaai 0a3;	rts;PSkey4Proc:	ldaai 0a4;	rts;PSkey5Proc:	ldaai 0a5;	rts;PSkey6Proc:	ldaai 0a6;	rts;PSkey7Proc:	ldaai 0a7;	rts;			--"a7"PSkey8Proc:	ldaai 0a8;	rts;			--"a8" PSkey9Proc:	ldaai 0a9;	rts;PSclearKeyProc:	ldaai 0aa;	rts;PStestKeyProc:	ldaai 0ab;	rts;PSonLineKeyProc:	ldaai 0ac;	rts;PSoffLineKeyProc:	ldaai 0ad;	rts;noopProc:	ldaai 0ae;	rts;PSwaitProc:	ldaai 0af;	rts;			--"AF"PSstandbyProc:	ldaai 0b0;	rts;		B0PSfeederFaultProc:	ldaai 0b1;	rts;noopProc1:	ldaai 0b2;	rts;PShardStop1Proc:	ldaai 0b3;	rts;PShardStop2Proc:	ldaai 0b4;	rts;PShardStop3Proc:	ldaai 0b5;	rts;		B5PSsorterJamProc:	ldaai 0b6;	rts;PSinterlockOpenProc:	ldaai 0b7;	rts;PSfuserUnderTempProc:	ldaai 0b8;	rts;PSrunFeedingProc:	ldaai 0b9;	rts;PSrunReadyProc:	ldaai 0ba;	rts;PSstatusDisplayedProc:	ldaai 0bb;	rts;PScmdRejParityProc:	ldaai 0bc;	rts;PScmdRejUnrecogProc:	ldaai 0bd;	rts;PScmdRejIllSeqProc:	ldaai 0be;	rts;PScmdRejSorterDownProc:	ldaai 0bf;	rts;	BFPSnoFeedTrayProc:	ldaai 0c0;	rts;			C0PSpageSyncProc:	ldaai 0c1;	rts;PSpageDeliveredProc:	ldaai 0c2;	rts;PSpageDelveredSorterProc:	ldaai 0c3;	rts;PScycleOffLIneProc:	ldaai 0c4;	rts;PSoffLineProc:	ldaai 0c5;	rts;PSonLineProc:	ldaai 0c6;	rts;PSoutTrayFullProc:	ldaai 0c7;	rts;PSstackerFullProc:	ldaai 0c8;	rts;			C8;call OutString by putting the address of the string into IXOutString:	ldabx 00;			pick up the length into bAnotherChar:	inx;				increment IX to point to first char of string	ldaax 00;			pick up char using index reg as addressor	pshb;				save b	jsr OutPutChar	pulb;	decb;	bgt AnotherChar;	branch if gt zero, i.e., more characters there	rts;OutPutChar:			;doesn't destroy a	psha;	jsr TimerWait;	pula;	ldabe sercon;   read serial controller reg into b	staae sertx;		send arg	rts;TimerWait:	lddi wait			; load D with wait count	addde cntrhi		; add D to counter	clre tcsr			; clear timer control status reg	stde outcmphi	; set output compare	ldaai 040 ; TimerWait1:	bitae tcsr		; now wait for output compare flag	beq TimerWait1	; not yet	rts;;Literals hereLit1: .TXT "Demo of the String Output routine*N";;; 	END PROGRAM;; 	INTERRUPT VECTORS;.loc 0fffe0f800;