-- File:  PrintSlot.mesa.z20496e1(1792)\i--edit history at bottom of file-- Last Edited:  October 28, 1981  11:34 AM  By:  GWilliams z20496e1\i--a 4K buffer load is dropped sporatically, added one line in inner loop to zero status on dequeing (@inline PrintBuffer code).DIRECTORYz20496e1\i128IAltoDefs USING [PageSize],z20496l4269d3634e1k72(635)FSPDefs USING[ZoneTooLarge],z20496l4269d3634e1k72InlineDefs USING[BITAND, BITNOT, BITOR, BITSHIFT, BITXOR],IODefs USING[CR, ReadChar, WriteChar, WriteDecimal, WriteLine, WriteString],z20496l3634e1k72MiscDefs USING [Zero],z20496l4269d3634e1k72PressDefs USING [abortFile, invertMode, PageG, PageGptr, SLOTScanLength, SLOTScanMarginAdjust, SLOTBitMarginAdjust, SLOTDouble, SLOTTimeOut],z20496l4269d3634e1k72RamDefs USING[StartIO],z20496l4269d3634e1k72SegmentDefs USING[DataSegmentAddress, DataSegmentHandle, DefaultBase, DeleteDataSegment, InsufficientVM, NewDataSegment],z20496l4269d3634e1k72StringDefs USING [UpperCase],Storage USING[FreeWords, Words],	z20496l3634e1k72SystemDefs USING [Even],z20496l3634e1k72TridentDefs USING[DA, diskCheck, diskRead, dlPtr, dstDone, dstZeroStatus, FP, kcbPtr, lKCB, Mstatus, PAGE, ptr, statusptr, Status, tfsdskPtr, TfsRealDA, TFSwordsPerPage, track];z20496l4269d3634e1k72\151i1Iz20496e1(1792)\bPrintSlot: PROGRAMz20496e1\b9BIMPORTS InlineDefs, IODefs, MiscDefs, PressDefs, RamDefs, SegmentDefs, Storage, StringDefs, SystemDefs, TridentDefs, FSPDefsz20496l4904d3634e1k72(635)EXPORTS PressDefs=z20496l3633e1(1792)BEGIN OPEN AltoDefs, FSPDefs, InlineDefs, IODefs, MiscDefs, PressDefs, RamDefs, SegmentDefs, StringDefs, Storage, SystemDefs, TridentDefs;z20496l3633d2998e1-- Typesz20496e1\iPError: TYPE = {noPaper, jam, firstFillFailed, firstFillTimeOut, pageTimeOut, overRan, readError, notSure};SlotCommand: TYPE = {setDensity, beamOn, reset, stopPrint, beamOff};z20496e1SCB: TYPE = MACHINE DEPENDENT RECORD	[	blank:	[0..37777B],	--14 bits worth	com:	[0..3],	--Beam On =0, Status = 1, Reset = 2, Print = 3	blowup:	[0..1),	--True: make one bit into 4	lastPage:	[0..1),	--Marks this command as the last page if true	invert:	[0..1),	--invert this page	bitsPerLine:	[0..17777B],	--servo count for number of bits per line	bitMargin:	CARDINAL,	--bottom margin in bits	scanLineWc:	CARDINAL,	--double of the word count	scanMargin:	CARDINAL,	--left margin (bits before print in portrait)	scansPerPage:	CARDINAL,	--total number of scan lines per page	bufferPtr:	POINTER,	--print buffer base address (first loc.)	scanLineWcInc:	CARDINAL,	--print buffer scan line increment	scansPerBuff:	CARDINAL,	--print-mode buffer length	currentBuf:	POINTER,	--current buffer address	currentLine:	CARDINAL,	--current scan address	status:	ReturnStatus,	--return status	filler:	CARDINAL];	--in case SetSCB adds one to base addressReturnStatus: TYPE = MACHINE DEPENDENT RECORD	[	blank:	[0..377B],	spare2:	[0..1],	wait:	[0..1],	paperJam:	[0..1],	addPaper:	[0..1],	selectB:	[0..1],	ready:	[0..1],	lineSync:	[0..1],	pageSync:	[0..1]	--complemented signal	];normalizedStatus: ReturnStatus _ [0,0,1,1,1,0,0,0,1];	--161BMetaStat: TYPE = POINTER TO AqMetaStat;AqMetaStat: TYPE = MACHINE DEPENDENT RECORD	[wait:	BOOLEAN,	--from uCode	paperJam:	BOOLEAN,	--from uCode	paperOut:	BOOLEAN,	--from uCode	illegal:	BOOLEAN,	--from IllegalState	ready:	BOOLEAN,	--"OR" of various bits and variables	overRun:	BOOLEAN,	--from "bufferEmpty"	fill:	[0..1777B],	--filler	pageNotPrinted: CARDINAL,	--from PrintFail	diskError:	CARDINAL	--from "readErrors"	]; z20496e1(0,4800)(1,6976)(2,9760)\60i16I14i47I9i1I7i28I19i46I18i18I28i41I25i21I23i27I23i46I26i37I22i40I27i34I26i26I23i24I25i22I24i15I21i41I210i22I58i6I104i12I21i12I23i10I20i19I18i36I20i20I20i8I28i16I22i19I6i-- Public Pack Variables EXPORTED to PressDefs z20496e1(1792)\i46I--EXPORTED to PressDefsz20496e1\i--Private Pack VariablesoverRun, illegalState: BOOLEAN _ FALSE;printFail, readErrors: CARDINAL;slotCommandBlock: POINTER TO POINTER = LOOPHOLE[720B];slotSIObit: CARDINAL = 4;pageRetries: CARDINAL;maxPageRetries: CARDINAL _ 3;--debugging switchesuseSLOT: BOOLEAN _ TRUE;debug: BOOLEAN _ FALSE;noDisplay: BOOLEAN _ TRUE;diskRetries: CARDINAL _ 20B;testDiskOnly: BOOLEAN _ FALSE;buffersCheck: BOOLEAN _ TRUE;--type message if didn't get 32K for buffers in PSlotda: PAGE;	--used by SLOTPrint and ReadBufferreadNext, printNext: kcbPtr;printCount, readCount: CARDINAL;active: POINTER TO CARDINAL = LOOPHOLE[453B];--for turning off memory parity interrruptsz20496(635)\i25I39i1I168i21I165i53I11i36I107iwakeupsWaiting: POINTER TO CARDINAL = LOOPHOLE[452B];RTC: POINTER TO CARDINAL = LOOPHOLE[430B];Display: POINTER = LOOPHOLE [420B];DisplayOn: BOOLEAN _ TRUE;savedDisplay: WORD;parityInterruptBit: CARDINAL = 1;bandWidth: CARDINAL = 16;beamOnCommand: CARDINAL = 0;statusCommand: CARDINAL = 1;resetCommand: CARDINAL = 2;printCommand: CARDINAL = 3;--Signals and Errors--ProcsSlotInit: PUBLIC PROC []={	SLOTCommand[reset];	SLOTCommand[beamOn];	SlotReady[];};--SlotInitz20496\242i1I117i21I4i7bI8B80i8ISLOTCommand: PROC[cmd: SlotCommand]=BEGIN	i: CARDINAL;	sCB:	SCB;	scb: POINTER TO SCB _ @sCB;	scb _ SetSCB[scb];	--align to even word boundary and init some fields.	SELECT cmd FROMz20496\i1bI11B107i52I		setDensity, beamOn =>	scb.com _ beamOnCommand;		reset =>	{illegalState _ FALSE; printFail _ 0; overRun _ FALSE; readErrors _ 0;			 scb.com _ resetCommand;};		stopPrint, beamOff =>	scb.com _ resetCommand;		ENDCASE =>	{illegalState _ TRUE; GOTO done};z20496(0,3648)(1,4256)(2,7744)	slotCommandBlock^ _ LOOPHOLE[scb];	IF useSLOT THEN		{[] _ StartIO[slotSIObit];		FOR i IN [0..30000]		DO			IF scb. status # ReturnStatus[0,0,0,0,0,0,0,0,0] THEN EXIT;		ENDLOOP;		IF scb.status = ReturnStatus[0,0,0,0,0,0,0,0,0] THEN illegalState _ TRUE;		IF cmd = beamOn THEN MsWait[1000];		};EXITSdone => NULL;END;--SlotCommandz20496(635)\326iSlotStatus: PROC[metaStat: MetaStat]={	sCB:	SCB;	scb: POINTER TO SCB _ @sCB;	IF useSLOT THEN		{scb _ SetSCB[scb];		scb.com _ statusCommand;		scb.status _ normalizedStatus;	--some dummy bits		slotCommandBlock^ _ scb;		[] _ StartIO[slotSIObit];		 MsWait[37];					--give microcode time to see new command		IF scb.status = normalizedStatus THEN illegalState _ TRUE;		scb.status _ BITXOR[scb.status, normalizedStatus];			metaStat.wait _ scb.status.wait # 0;		metaStat.paperJam _ scb.status.paperJam # 0;		metaStat.paperOut _ scb.status.addPaper # 0;		metaStat.illegal _ illegalState;		metaStat.pageNotPrinted _ printFail;		metaStat.overRun _ overRun;		metaStat.diskError _ readErrors;z20496\b11B169i17I74i41I	metaStat.ready _ scb.status.ready = 1 AND NOT(metaStat.wait OR metaStat.paperJam OR metaStat.paperOut OR metaStat.illegal OR metaStat.pageNotPrinted # 0 OR metaStat.overRun OR metaStat.diskError # 0);}z20496l4903d3633		ELSE metaStat.ready _ TRUE;z20496l4268d2998};--SlotStatusPrintError: PROC[err: PError, num: CARDINAL]=--This routine should turn the display on if it was off and type appropriate message, then turn the display back off to continue.--if the error is notSure, display the whole slotStats structure{	displayWasOn: BOOLEAN _ DisplayOn;	continue: BOOLEAN _ FALSE;	canContinue: BOOLEAN _ FALSE;	IF ~DisplayOn THEN		{Display^ _ savedDisplay; DisplayOn _ TRUE};	SELECT err FROM	noPaper => {WriteLine["Reload printer with paper. Type any key to continue."L];					[]_ReadChar[];					continue _ TRUE;					IF ~displayWasOn THEN						{savedDisplay _ Display^; Display^ _0; DisplayOn _ FALSE};					GOTO getOut;					};	jam => 		{WriteLine["Printer jammed. Fix, then type any key to continue."L];					[]_ReadChar[];					continue _ TRUE;					IF ~displayWasOn THEN						{savedDisplay _ Display^; Display^ _0; DisplayOn _ FALSE};					GOTO getOut;					};	firstFillFailed, firstFillTimeOut=>					WriteLine["Trident didn't get off the ground."L];	pageTimeOut=>	WriteLine["Page took too long to print."L];	overRan=>	{WriteString["Disk Overran "L]; WriteDecimal[num]; WriteLine[" times."L]; canContinue _ TRUE};	readError=>	{WriteDecimal[num]; WriteLine[" readErrors."L];};	notSure =>	{WriteLine["Unknown Error"L];};	ENDCASE;	IF canContinue THEN		{WriteString["Type Y to continue, anything else to exit: "L];		 IF (UpperCase[ReadChar[]] = 'Y) THEN continue _  TRUE; WriteChar[CR]};	IF ~continue THEN abortFile;EXITS	getOut=> NULL;};--PrintErrorSlotReady: PROC [metaStat: MetaStat _ NIL]={	aqMetaStat: AqMetaStat;	mStat: MetaStat _ @aqMetaStat;	IF metaStat = NIL THEN		{metaStat _ mStat;		 SlotStatus[metaStat];};	IF ~useSLOT THEN metaStat.ready _ TRUE;	IF ~metaStat.ready THEN		{SLOTCommand[reset];		 SELECT TRUE FROM			metaStat.paperOut  => PrintError[noPaper, 0];			metaStat.paperJam  => PrintError[jam, 0];			metaStat.pageNotPrinted # 0 =>				SELECT metaStat.pageNotPrinted FROM				 1 => PrintError[firstFillFailed, 0];				 2 => PrintError[firstFillTimeOut, 0];				 3 => PrintError[pageTimeOut, 0];	--took too long to print entire page				 ENDCASE;			metaStat.overRun => {IF pageRetries > maxPageRetries								THEN PrintError[overRan, pageRetries]								ELSE pageRetries _ pageRetries + 1};			metaStat.diskError # 0 => PrintError[readError, metaStat.diskError]			ENDCASE => PrintError[notSure, 0];		 SLOTCommand[reset];		 SLOTCommand[beamOn];		};};--SlotReadyMsWait: PROC[ms: CARDINAL]={	timeOut: CARDINAL _  RTC^ + ms/37;	--RTC runs at ~38 uSec/click, but clicks are measured at a scale of ~1024 uSec/click	UNTIL RTC^  >= timeOut DO ENDLOOP;};--MsWait--Pslot grabs as much storage as it can for buffers of scan lines. Each buffer holds a multiple of TfsWordsPerPage--The buffers are arranged in a ring, with @buffer-1 holding the address of the next buffer. The storage is grabbed from the system as--  one large segment if it can get it, and then divided into the buffers.--The display machinery is turned off here in the final product. It is turned back on if there is an eror.--SLOTPrint is then called to print the page by filling the buffers and passing them to the microcode.z20496\1i13bI12B36i129I1i65I1250i14bI10B565i36I325i11bI8B59i84I39i8I3i535bIPSlot: PUBLIC PROC[disk: tfsdskPtr, pageG: PageGptr, lastPage: BOOLEAN, firstVDA: PAGE, filePtr: POINTER TO FP] =z20496l3633d2998\b5BBEGIN	i, nBufs, oldActive: CARDINAL;	zoneBase, firstBuf, buf: POINTER;	aqMetaStat: AqMetaStat;BEGIN ENABLE UNWIND => IF zoneBase # NIL THEN  FreeWords[zoneBase];	firstBitPageDA: PAGE _ pageG.BitPage + firstVDA;	--assume a contiguous file for now	metaStat: MetaStat _ @ aqMetaStat;	buffLen: CARDINAL _ (1024*((pageG.BitWc*bandWidth+1023)/1024))+2;	pageRetries _ 0;	nBufs _ 10;	IF ~debug THEN		{oldActive _ active^;		active^ _ BITAND[oldActive, BITNOT[parityInterruptBit]]};--get buffer space		zoneBase _ Words[nBufs * buffLen!			InsufficientVM, ZoneTooLarge =>				{nBufs _ nBufs - 1; RETRY}];	IF nBufs < 10 THEN WriteLine["Didn't use 32K of buffer space"L];	IF nBufs < 2 THEN		{active^ _ oldActive;		 FreeWords[zoneBase];		 WriteLine["Not Enough Memory. Type any char to continue"L];		 []_ReadChar[];		RETURN;};--the microcode requires the bit array to begin on an even word boundary AND bit array[-1] must be available for linking the pointers.--Since MakeNode has a bookkeeping word at ptr-1, we must round up. Hence the +2 in the original calc.	buf _ firstBuf _ (IF BITAND[zoneBase, 1] THEN zoneBase+1 ELSE zoneBase + 2);	FOR i IN [0..nBufs)		DO			(buf-1)^ _ buf+buffLen;			buf _ buf+buffLen;		ENDLOOP;		(buf-(buffLen+1))^ _ firstBuf;	--backup to fix up last pointer & complete the ring.	DOz20496\217i34I237i19I331i239I197i52ISLOTPrint[disk, lastPage, pageG.FirstBand*bandWidth, pageG.BitMargin, pageG.BitWc*16, (pageG.LastBand-pageG.FirstBand+1)*bandWidth, bandWidth, firstBuf, firstBitPageDA, metaStat];	--print this page till it's printed without errors.z20496l4891d4256\180i	IF (~metaStat.ready AND (metaStat.wait OR metaStat.paperJam OR metaStat.paperOut OR metaStat.illegal OR metaStat.pageNotPrinted#0))z20496l4903d3633			THEN				{SLOTCommand[reset];	--only clear Slot Errors (not disk errors)				 SlotReady[metaStat];}			ELSE				EXIT;	ENDLOOP;	FreeWords[zoneBase];	zoneBase _ NIL;	IF ~debug THEN		{wakeupsWaiting^ _ BITAND[wakeupsWaiting^, BITNOT[parityInterruptBit]];		active^ _ oldActive;};END;--of UNWINDEND;--PSlotz20496\33i42I216i12I4i7ISLOTPrint: PROC[disk: tfsdskPtr, lastPage: BOOLEAN, scanMargin, bitMargin, scanLength, numScans, scansPerBuffer: CARDINAL, firstBuf: POINTER, FirstDA: PAGE, metaStat: MetaStat]=z20496l3633d2998\b9B{	i, timeOut: CARDINAL;		--i is used in two loops	dontUseTrident: BOOLEAN _ FALSE;	buf,  currentBuf: POINTER;	dcb: kcbPtr;					--used in first half of code and in inner loop	dcbTable: POINTER;	dcbSegment: DataSegmentHandle;	dcbTableSize: CARDINAL _ ((32*lKCB)/(PageSize))+1;	--in alto pages	labelBuf: ARRAY [0..10) OF WORD;	tridentStart: CARDINAL = 40B;	tridentStop: CARDINAL = 20B;	sCB:	SCB;	scb: POINTER TO SCB _ @sCB;	numWords: CARDINAL _ BITSHIFT[scanLength, -4]; 	sectorsPerBuffer: CARDINAL _ (scansPerBuffer * numWords+1023)/1024; --these vars were in PrintBuffer and ReadBuffer	status: Status;	DCBseal: CARDINAL = 122645B;	startNext: kcbPtr;	daPtr: POINTER TO DA;--vars that are needed by TfsRealDA replacement	nSectors: CARDINAL _ disk.tfskd.kdh.nSectors;	nHeads: CARDINAL _ disk.tfskd.kdh.nHeads;	quotient: CARDINAL;	da _ FirstDA;	printCount _ readCount _ (numScans+scansPerBuffer-1)/scansPerBuffer;	scb _ SetSCB[scb];	--must init buf etc. here to avoid "warning: multiple initialization with a pointer"	scb.currentBuf _ scb.bufferPtr _ buf _  currentBuf _ firstBuf;	scb.com _ printCommand;	scb.lastPage _ IF lastPage THEN 1 ELSE 0;	scb.bitMargin _ bitMargin + SLOTBitMarginAdjust;	scb.scanLineWc _ BITSHIFT[scanLength, -5];--shift right 5 bits	scb.scanMargin _ scanMargin + SLOTScanMarginAdjust;	scb.scansPerPage _ numScans;	scb.scanLineWcInc _ numWords;	scb.scansPerBuff _ scansPerBuffer;	slotCommandBlock^ _ scb;								--give microcode the pointer, (uCode not running yet).	--get enough room for 64 buffers of 1024 words each	dcbSegment _ NewDataSegment[DefaultBase, ((64*lKCB)/(PageSize))+1];	dcbTable _ DataSegmentAddress[dcbSegment];	dcb _ LOOPHOLE[dcbTable, kcbPtr];	DO	readNext _ dcb;	FOR i IN [0..sectorsPerBuffer) DO		Zero[dcb, lKCB];		dcb.nextKCB _ dcb + lKCB;		dcb.blockH.comm _ diskCheck;		dcb.blockH.count _ 2;		dcb.blockH.addr _ LOOPHOLE[@dcb.diskAddress, dlPtr];	--disk label pointer		dcb.blockL.comm _ diskRead;		dcb.blockL.addr _ LOOPHOLE[@labelBuf, dlPtr];		dcb.blockL.count _ 10;		dcb.blockD.comm _ diskRead;		dcb.blockD.count _ TFSwordsPerPage;		dcb.blockD.addr _ (buf+i*TFSwordsPerPage);		dcb _ dcb.nextKCB;		ENDLOOP;	ReadBuffer[FALSE, sectorsPerBuffer, disk];	buf _ (buf-1)^;	IF buf = firstBuf THEN EXIT;	ENDLOOP;--buffers filled		(dcb-lKCB).nextKCB _ dcbTable;	readNext _ printNext _ dcbTable;IF noDisplay THEN				{savedDisplay _ Display^;			 	DisplayOn _ FALSE;			 	Display^ _ 0;};	IF ~dontUseTrident THEN			{[] _ StartIO[tridentStart];			 track^ _ 177777B;			 statusptr^ _ Mstatus[1,1,1,1,1,1,1,1,1,1,1,1, 17B];			 ptr^ _ dcbTable;			};	timeOut _ RTC^ + SLOTTimeOut*27;						--give us SLOTTimeOut seconds to finish page	--PrintBuffer will return true as soon as the first buffer is filled (with or w/o errors)	UNTIL PrintBuffer[sectorsPerBuffer] DO		IF RTC^ >= timeOut THEN printFail _ (IF printNext = firstBuf THEN 1 ELSE 2);	ENDLOOP;	overRun _ FALSE;	IF printFail = 0 THEN											--start the SLOT!		{IF useSLOT THEN			[]_StartIO[slotSIObit];		DO			IF scb.currentBuf # currentBuf THEN						--uCode started outputting next buf				{currentBuf _ scb.currentBuf;				 --Put PrintBufer and ReadBuffer in line				  --IF ~ PrintBuffer[sectorsPerBuffer] THEN EXIT;			----"must be full" i.e., end of buffers to read--				 ReadBuffer[TRUE, sectorsPerBuffer, disk];					-------------- PrintBuffer code ------------------------------------------------				dcb _ printNext;							IF (printCount _ printCount - 1) # 0 THEN	--go check result of another transfer					{FOR i IN [1..sectorsPerBuffer] DO						IF dcb.blockD.status = dstZeroStatus THEN {overRun _ TRUE; EXIT};--exits print loop						status _ BITOR[BITOR[dcb.blockH.status, dcb.blockD.status], dcb.blockL.status];						IF status # dstDone THEN							readErrors _ readErrors + 1;						dcb _ dcb.nextKCB;						dcb.blockD.status _ dstZeroStatus;	--added for debugging!					ENDLOOP;									printNext _ dcb;					}; --IF (printCount _ printCount - 1) # 0				-------------- End PrintBuffer code --------------------------------------------				-------------- ReadBuffer code ------------------------------------------------					startNext _ readNext;					--readCount _ readCount - 1; No one references this.					FOR i IN [1..sectorsPerBuffer] DO						daPtr _ LOOPHOLE[readNext];						--daPtr^ _ TfsRealDA[disk, da];	----returns a DA record (2 words)						-------------- TfsRealDA code ------------------------------------------------						--This code could be replaced by keeping track of sector,,head,,track info with conditionals & eliminate						--	 the MOD's and /'s							daPtr^.sector _ da MOD nSectors;							quotient _ da/nSectors;											daPtr^.head _ quotient MOD nHeads;							daPtr^.track _ quotient/nHeads;						-------------- End TfsRealDA code --------------------------------------------						da _ da + 1;						readNext.blockD.status _ dstZeroStatus;						readNext.id _ DCBseal;						readNext _ readNext.nextKCB;					ENDLOOP;				IF ptr^ = NIL THEN ptr^ _ startNext;				-------------- End ReadBuffer code --------------------------------------------				};			IF scb.status # ReturnStatus[0,0,0,0,0,0,0,0,0] THEN EXIT;	--from inner loop			--IF ~ debug THEN			IF RTC^ >= timeOut THEN {printFail _3; EXIT};		ENDLOOP;												--DO above IF scb.currentBuf #		};														--IF printFail = 0 THEN	ptr^ _ NIL;														--quiet disk	DeleteDataSegment[dcbSegment];	IF ~DisplayOn THEN		{Display^ _ savedDisplay;		 DisplayOn _ TRUE;		};	SlotStatus[metaStat];											--return final status	IF lastPage THEN {MsWait[6000]; SLOTCommand[reset];};};--SLOTPrintz20496e6\25i24I81i46I105i15I257i46I90i48I220i35I277i6I5i7I185i54I5i49I363i20I349i16I362i49I5i87I182i19I95i37I42i141I1i49I157i37I106b4B2i18I220i2b20BI50i38I202i54I73i72I93i10I5i115I581i39I59i42I5i37I1i1I12i26I33i1I73i1I30i23I58i11Iz20496e6PrintBuffer: PROC[sectorsPerBuffer: CARDINAL] RETURNS[ok: BOOLEAN _ TRUE]={	i: CARDINAL;	dcb: kcbPtr _ printNext;	status: Status;	IF printCount = 0 THEN RETURN;	printCount _ printCount - 1;	FOR i IN [1..sectorsPerBuffer] DO		IF dcb.blockD.status = dstZeroStatus THEN {overRun _ TRUE; RETURN [FALSE];};		status _ BITOR[BITOR[dcb.blockH.status, dcb.blockD.status], dcb.blockL.status];		IF status # dstDone THEN			readErrors _ readErrors + 1;		dcb _ dcb.nextKCB;	ENDLOOP;	printNext _ dcb;};--PrintBufferReadBuffer: PROC[startUp: BOOLEAN, sectorsPerBuffer: CARDINAL, disk: tfsdskPtr ]={	i: CARDINAL;	DCBseal: CARDINAL = 122645B;	startNext: kcbPtr _ readNext;	daPtr: POINTER TO DA;	readCount _ readCount - 1;	FOR i IN [1..sectorsPerBuffer] DO		daPtr _ LOOPHOLE[readNext];		daPtr^ _ TfsRealDA[disk, da];	--returns a DA record (2 words)		da _ da + 1;		readNext.blockD.status _ dstZeroStatus;		readNext.id _ DCBseal;		readNext _ readNext.nextKCB;	ENDLOOP;	IF startUp AND ptr^ = NIL THEN ptr^ _ startNext;};--ReadBufferSetSCB: PROC[scb: POINTER TO SCB] RETURNS[newSCBadr: POINTER TO SCB]={	Zero[scb, SIZE[SCB]];	newSCBadr _ Even[scb];	newSCBadr.invert _ IF invertMode THEN 1 ELSE 0;	newSCBadr.bitsPerLine _ SLOTScanLength;	newSCBadr.blowup _ IF SLOTDouble=0 THEN 0 ELSE 1;};--SetSCBz20496e6\b12B491i13bI12B297i31I176i13I1b6B255i8IEND.--PrintSlot-- Last Edited:  September 15, 1981  6:19 PM  By:  GWilliams z20496e1(1792)\4i--noDisplay=FALSE (i.e., leave it on) and useSlot=FALSE, debug=FALSE(do timeouts)z20496e1--October 26, 1981  2:36 PM  By:  GWilliams z20496e1\i--cause PSlot to clear disk errors (& print a goofed-up page) a few times before erroring.-- Last Edited:  October 27, 1981  1:32 PM  By:  GWilliams z20496e1\i--SLOTPrint runs too slow dat 384 spi. Put PrintBuffer and ReadBuffer inline in inner loop(635)\i