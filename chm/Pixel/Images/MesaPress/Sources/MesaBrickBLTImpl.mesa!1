-- MesaBrickBLTImpl.mesa-- Last changed by Ken Pier,          March 12, 1982  4:05 PMDIRECTORY  MesaBrickBLT,  MesaBandFormat,  Inline USING [HighHalf, LowHalf],  BitBltDefs;MesaBrickBLTImpl: PROGRAMIMPORTS  Inline, BitBltDefsEXPORTS MesaBrickBLT = {OPEN BB: BitBltDefs, BFormat: MesaBandFormat, MesaBrickBLT;bitsPerWord: CARDINAL = 16;--InitializeBrickBLT is called with a client BBTableSpace.--Procedure makes bbtable and fills in constant values for blitting--scanline buffer into band buffer. Clients will pass this bbtable--to other routines for filling and blitting.InitializeBrickBLT: PUBLIC PROC [ptr: POINTER TO BB.BBTableSpace] RETURNS [bbptr: BB.BBptr] = {  bbptr _ BB.AlignedBBTable[ptr];  bbptr^ _ [    ptrs: short,    pad: 0,    sourcealt: FALSE,     destalt:  FALSE,     sourcetype:  block,    function:  replace,    unused: 0, --REALLY HOLDS HIGH HALF OF ALTERNATE BANK POINTER!!    dbca: NIL,    dbmr:  0, -- destination raster width(in words)    dlx:  0, -- destination left x    dty:  0, -- destination top y    dw:   0, -- block width in bits    dh:   0, -- block height in scanlines    sbca: NIL,    sbmr:   0, -- source raster width(in words)    slx:    0, -- source left x    sty:    0, -- source top y    gray0:  0, -- four words of "gray"    gray1:  0,    gray2:  0,    gray3:  0,     slbca:  NIL, -- IGNORED ON ALTO!!    dlbca:  NIL]; -- IGNORED ON ALTO!!    };--InitializeBrickBLTBrickBLT:PUBLIC PROC [bbptr: BB.BBptr, tBrick: BFormat.TBrickRef,		destLine: LONG POINTER, hx, hy: CARDINAL,	        xmin,xmax: CARDINAL,		lineBuffer: POINTER] = {  L: CARDINAL _ tBrick.L;  brickIndex: CARDINAL _ L*hy; --start of line in brick to replicate  w, wmax: CARDINAL;--move one line from the tBrick into the line buffer  bbptr^ _ [    ptrs: short,    pad: 0,    sourcealt: FALSE,     destalt:  FALSE,     sourcetype:  block,    function:  replace,    unused: 0, --REALLY HOLDS HIGH HALF OF ALTERNATE BANK POINTER!!    dbca: lineBuffer,    dbmr:  0, -- destination raster width(in words)    dlx:  0, -- destination left x    dty:  0, -- destination top y    dw:   L, -- block width in bits    dh:   1, -- block height in scanlines    sbca: @tBrick.brick+(brickIndex/bitsPerWord)+1,    sbmr:   0, -- source raster width(in words)    slx:    brickIndex MOD bitsPerWord, -- source left x    sty:    0 -- source top y    ];  BB.BITBLT[bbptr]; --blit the correct brick line into the line buffer--now replicate the brick line of length L to form a scan line, doubling--the replication each time  bbptr^ _ [    dbca: lineBuffer,    dbmr:  0, -- destination raster width(in words)    dty:  0, -- destination top y    dh:   1, -- block height in scanlines    sbca: lineBuffer,    sbmr:   0, -- source raster width(in words)    slx:    0, -- source left x    sty:    0 -- source top y    ];--all constants for this part  wmax _ hx+xmax-xmin; --max of bits needed  w _ L; --bits started with  UNTIL w >= wmax/2 DO    bbptr.dlx _ bbptr.dw _ w;    BB.BITBLT[bbptr]; --double the contents    w _ w+w;    ENDLOOP;  --last part  bbptr.dlx _ w;  bbptr.dw _ wmax-w;  BB.BITBLT[bbptr];--BLT just enough to fill scanline-- now BLT the buffer into the bitmap  bbptr^ _ [    ptrs: short,    pad: 0,    sourcealt: FALSE,    destalt:  TRUE,    sourcetype:  block,    function:  replace,    unused: Inline.HighHalf[destLine], --NOT REALLY UNUSED    dbca: Inline.LowHalf[destLine],    dbmr:  0, -- destination raster width unused for height=1    dlx:  xmin, -- destination left x    dty:  0, -- destination top y    dw:   xmax-xmin, -- block width in bits    dh:   1, -- block height in scanlines    sbca: lineBuffer+hx/bitsPerWord,    sbmr:   0, -- source raster width unused for height=1    slx:    hx MOD bitsPerWord, -- source left x    sty:    0 -- source top y    ];  BB.BITBLT[bbptr];  };--BrickBLT}.LOGMarch 11, 1982, changed linebuffers to SHORT POINTERS