-- File:  PressListener.mesa: Routines for getting for a file at a printing server.e1(1792)\i-- GetBits is called by Press.mesa-- Last Edited:  November 19, 1982  7:06 PM   By:  GWilliams e1\i-- Restructuring GetBits for clarity, debugging page writing.e1\i62IDIRECTORYe1AltoDefs USING [BytesPerWord, PageSize],l4269d3634e1k72(635)AltoRam USING [CantFindFile, FileLooksCrufty],l4269d3634e1k72EFTPDefs USING [EFTPAbortReceiving, EFTPAlreadyReceiving, EFTPEndReceiving, EFTPFinishReceiving, EFTPGetBlock, EFTPNotReceiving, EFTPOpenForReceiving, EFTPTimeOut, EFTPTroubleReceiving],l4269d3634e1k72IODefs USING[CR, SP, WriteChar, WriteDecimal, WriteOctal, WriteLine, WriteString],l3634e1k72InlineDefs USING [BITOR, BITSHIFT, LongCOPY],	--LongCOPY[from, nwords, to]l4269d3634e1k72\46i28IMesaBands USING [BandDevice, ShowBands, ShowBandsInit],l4269d3634e1k72MiscDefs USING[CallDebugger, Zero],l4269d3634e1k72PressDefs USING [PageG, PressPassword, RamBoot, uCodeLoaded],l4269d3634e1k72PressNetDefs USING [--attributesCode,-- EndReason, --imageCode,-- PageAttributes],l4269d3634e1k72\20i19I12i14IPressBandsDefs USING [CloseBandsFile, OpenPressBands, InitTfsBandsBuffer, ReleaseTfsBandsBuffer],l4269d3634e1k72PupDefs USING [GetPupAddress, PupPackageDestroy, PupPackageMake],l4269d3634e1k72PupStream USING [AppendPupAddress],l4269d3634e1k72PupTypes USING[PupAddress, PupSocketID],l4269d3634e1k72SegmentDefs USING[DataSegmentHandle, DefaultBase, DeleteDataSegment, NewDataSegment, SegmentAddress],l4269d3634e1k72TridentDefs USING [BadErrorRtn, dcReadLD, dcReadLnD, dcWriteD, dcWriteLnD, ddMgrPtr, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, eofDA, fillInDA, FA, FP, LD, NoopTfsCleanupRtn, PAGE, TfsActOnPages, TfsCloseDisk, TfsCreateDDmgr, TfsDeletePages, tfsdskPtr, TfsInit, TfsOpenFile, TFSwordsPerPage, TfsWritePages];l4269d3634e1k72e1(1792)\bPressNetListener: PROGRAMe1\b16BIMPORTS AltoRam, EFTPDefs, IODefs, InlineDefs, MesaBands, MiscDefs, PressDefs, PressBandsDefs, PupDefs, PupStream, SegmentDefs, TridentDefsl4904d3634e1k72(635)EXPORTS PressBandsDefs, PressNetDefs =l3633e1(1792)l3633d2998e1BEGIN OPEN AltoDefs, AltoRam, EFTPDefs, IODefs, InlineDefs, MiscDefs, PressDefs, PressBandsDefs, PressNetDefs, PupDefs, PupStream, PupTypes, SegmentDefs, TridentDefs;l3633d2998e1l4269d2999e1k72(635)	TerminationReason: TYPE = {errorTermination, fileDoneTermination, pageDoneTermination, nullTerminationReason};l4278d2999e1k72--Interpress Stuff	HeraldStart: CARDINAL = 125252B;--Press Stuff	pressFile: BOOLEAN;	bandWidth: CARDINAL = 16;	FirstPage: TYPE = MACHINE DEPENDENT RECORD	[	nPages: CARDINAL _ 1,		pageGSize: CARDINAL _ SIZE[PageG],  --14B		printerMode: CARDINAL,	--3=portrait, 8=Landscape		password: CARDINAL _ PressPassword,		pageGs: ARRAY[0..85) OF PageG	--enough to fit into a Trident Page	];	scanSeg: DataSegmentHandle _ NIL;	scanLength: CARDINAL;	wordAddrInTfsBuffer: CARDINAL;	scanInBand: CARDINAL;--net stuff 	connectionOpen: BOOLEAN _ FALSE;	gotAJob: BOOLEAN _ FALSE;	hostAddress: PupAddress;	pupPtr: POINTER TO PupAddress _ @hostAddress;	senderAddress: PupAddress;	shortFile, pupPkgExtant: BOOLEAN _ FALSE;--Tfs stuff	TfsMaxWords: TYPE = [0..TFSwordsPerPage];	TfsCharsPerPage: CARDINAL = TFSwordsPerPage*BytesPerWord;	TfsMaxChars: TYPE = [0..TfsCharsPerPage];	pressStr: STRING = "TridentTemp.press.";	bandStr: STRING = "PBand.0.";	bitsStr: STRING = "Press.bits.";	lastPageChars: TfsMaxChars;	extendedFile: BOOLEAN;--TRUE=> we had hit EOF in adding pages	bandDiskBuffer: POINTER;	ddMgr: PUBLIC ddMgrPtr _ NIL;	disk: tfsdskPtr _ NIL;	bufferWordLen: CARDINAL = TFSwordsPerPage;	bufferByteLen: CARDINAL = BytesPerWord*bufferWordLen;l3008d2999e1k72\i19I33i15I157i3I26i28I68i35I120i10I207i12bI13B29b1B60b12B29b1B161i37I	pagesLength: CARDINAL = 6;--prev, this, next, [next+1, next+2 (for adding pages)]	leaderVda, firstVda: CARDINAL _ 0;				--allways holds page 0 &1 of the file	fp: FP;										--fp gets filled in by TfsOpenFile	filePtr: POINTER TO FP _ @fp;	tfsSeg: DataSegmentHandle _ NIL;	tfsBuff: POINTER TO ARRAY[0..TFSwordsPerPage) OF CARDINAL;	pages: ARRAY[0..pagesLength) OF PAGE;	dAsLength: CARDINAL;	dAsBase: POINTER;							--this is modified after ea call on TfsActOnPages.	pageNum: CARDINAL;	OutputFile: TYPE = {bitsFile, anyOtherFile};	outputFile: OutputFile;--Debugging Switches	fileLengthReport: BOOLEAN _ TRUE;				--print out length of received file in pages	dasMonitor: BOOLEAN _ FALSE;					--for debugging tfs file handler.	debuggerIfTfsError: PUBLIC BOOLEAN _ TRUE;	checkTermination: PUBLIC BOOLEAN _ TRUE;--Signals & ErrorsCommErr: TYPE = {alreadyHaveJob, nullComErr, endReceiving, noisyChannel, protocolError, illegalEnd, notReceiving, alreadyReceiving};errorComm: ERROR[e: CommErr, wordsTransferred: CARDINAL _ 0, s: STRING _ NIL] = CODE;errorTfs: PUBLIC ERROR[e: EndReason] = CODE;EOFerror: ERROR = CODE;GetBits: PUBLIC PROC[] RETURNS[okToProceed: BOOLEAN _ FALSE]=--Raises no signals or errorsBEGIN--	pa: PageAttributes;	endReason: EndReason _ illegalReason;	iii: CARDINAL _ 0;	--used in data fetching loop--	inCoreAddress: POINTER TO ARRAY OF WORD;	tooMuchData: BOOLEAN _ FALSE;	--set when sender sends too much data	receivedFile: BOOLEAN _ FALSE;	--scanLineLength: CARDINAL;			----copy of scanLength	wordsInBuff: CARDINAL;BEGIN	extendedFile _ FALSE;--if true, add empty page to end of file on exiting.	lastPageChars _ 0;	IF ~FirstPageCheck[] THEN RETURN[FALSE];	WHILE ~receivedFile	DOl2999e1k72\27i55I40i37I21i32I1i1I30i1I92i1I61i1I24i51I20b12B33b1B25i22I40i42I37i31I87i20bI7B126b9B77b10B35b10B16b7B55i30I6i23I59i28I1i44I31i39I31i53I54i52I	TridentThere[! errorTfs => IF e=noTrident		THEN {WriteLine["Trident not up"L]; GOTO getOut};];	GetTfsBuffer[];	BEGIN ENABLE BEGIN--for catching signals from the communications proc.l3634e1k72\134i52I		errorComm => 			{SELECT e FROM				noisyChannel => {WriteLine["Noisy Channel, aborting transfer"L];								EFTPAbortReceiving["Channel too noisy, aborting transfer"L!									EFTPNotReceiving => CONTINUE]};				endReceiving =>      --all OK								{WriteTfsPage[wordsTransferred];--empty the last load from the net								GOTO closeConn;								};				ENDCASE;			GOTO incompleteXFer};		errorTfs => SELECT e FROM tridentError, hitEOF, dANotFilled => {endReason _ e; GOTO done}; ENDCASE;		END;--of catch series	wordsInBuff _ GetAJob[! errorComm => IF e = alreadyReceiving THEN {PupPackageDestroy[]; GOTO getOut}];	OpenAppropriateFile[(IF pressFile THEN pressStr ELSE bandStr), filePtr						! errorTfs => {SELECT e FROM  noTrident => WriteLine["Trident not up"L];			 			cantFindFile => {endReason _ e;								WriteString["Can't find "L]; WriteLine[(IF pressFile THEN pressStr ELSE bandStr)];};							ENDCASE; GOTO done}--state cleaned up at exit--];	InitTfsBuffer[anyOtherFile];--find first VDA to write	--	inCoreAddress _ InitScanBuffer[pa];	----get enough space for a scan line; must call after InitTfsBuffer	--	scanLineLength _ scanLength;	----scan Length is valid now.	IF shortFile THEN {WriteTfsPage[wordsInBuff]; GOTO closeConn};--File < 1024 words.	DO		WriteTfsPage[wordsInBuff];--the first load was gotten in GetAJob		wordsInBuff _ GetBuffer[tfsBuff, TFSwordsPerPage];	ENDLOOP;	EXITS	incompleteXFer =>			{IF checkTermination THEN				CallDebugger["File transfer trouble"];			CloseStorage[];			LOOP};		--restart @ WHILE ~ receivedFilel4269e1k72\239i6I43i32I176i2I4i18I414i26f7 2I3f0 32i23I45i64I35i28I119i37I192i32I		closeConn => NULL;	END;--of scope of the catch phrasel3634e1k72\26i30I	CloseStorage[];	receivedFile _ TRUE;l3634e1k72\i1I	ENDLOOP;	okToProceed _ TRUE;EXITSgetOut=> NULL;done=> l2999e1k72\10i1I20i1I	{ReleaseTfsBuffer[];	CloseServerConnection[];		--turn off net if on.l2999e1k72(0,3648)(1,7232)\51i19I	SELECT endReason FROM		emptyBuffReason=>	WriteLine["Empty Page: error!"L];		illegalReason =>	WriteLine["illegal End."L];		tridentError =>	{WriteLine["Trident error"L];				EFTPAbortReceiving["Trident error"L];};		hitEOF => 	{WriteLine["Ran into EOF on write"L];				EFTPAbortReceiving["Trident ran into EOF on file write"L];};		dANotFilled =>	{WriteLine["Trident software trouble -- bad DA multiple times"L];				EFTPAbortReceiving["Trident software trouble -- bad DA"L];};	ENDCASE;l2999e1k72(1,4269)(2,7867)	SELECT endReason FROM	   tridentError => NULL;	   cantFindFile, emptyBuffReason, hitEOF, dANotFilled => {IF disk # NIL THEN disk _ TfsCloseDisk[disk, FALSE]; ddMgr _ NIL};	ENDCASE;	};l2999e1k72(1,7232)(2,65535)END;l3634d2999e1k72(635)	IF checkTermination THEN		IF ~okToProceed THEN CallDebugger["Exiting with error from GetBits"L];END;--of GetBitsCloseStorage: PROC []=	--Close connection, give back free storage and close the disk{	CloseServerConnection[];	CloseTfsBuffers[];	disk_TfsCloseDisk[disk, FALSE];--delete the ddMgr too	ddMgr _ NIL;};--CloseStorage.l2999e1k72\103i12bI1B1b13B10i62I79i22I19i13IFirstPageCheck: PROC [] RETURNS[goAhead: BOOLEAN _ TRUE]={	IF SIZE[FirstPage] > TFSwordsPerPage THEN			{WriteLine["First page description exceeds Trident Page Length"];			 RETURN[FALSE]};};--FirstPageCheckGetBuffer: PROC[buffer: POINTER, len: CARDINAL] RETURNS [wordsInBufCt: CARDINAL _ 0]=l2999e1k72\b14B179i17bI10B--copy from net Stream to buffer len amount of wordsBEGIN	blockByteLen, bytesToGet: CARDINAL _ 0;	bufferEnd: POINTER _ buffer + len;	--actually is first word past buffer	bufferPos: POINTER _ buffer;	getABuffEndReason: EndReason _ illegalReason;BEGIN	UNTIL bufferPos = bufferEnd	DO 		bytesToGet _ (bufferEnd - bufferPos) + (bufferEnd - bufferPos);	--remember, bufferEnd is one past end of buffer		blockByteLen _ 0;		blockByteLen _ EFTPGetBlock[bufferPos, bytesToGet!		EFTPNotReceiving => {getABuffEndReason _ errorNotReceiving; GOTO done;};		EFTPEndReceiving => {getABuffEndReason _ doneReason; GOTO done;};		EFTPTroubleReceiving => {getABuffEndReason _ errorTroubleReceiving; GOTO done;};		EFTPTimeOut => RETRY];			bufferPos _ bufferPos + blockByteLen/2;		wordsInBufCt _ wordsInBufCt + BITSHIFT[blockByteLen, -1];--divide by bytes/word	ENDLOOP;EXITS	done=>l2999e1\i53I83i36I186i47I428i22I	{	--CloseServerConnection[]; - - this is done at the catch phrase higher up.		wordsInBufCt _ wordsInBufCt + BITSHIFT[blockByteLen, -1];--divide by bytes/word;		SELECT getABuffEndReason FROM			doneReason =>			ERROR errorComm[endReceiving, wordsInBufCt, NIL];--not necessarily an error			errorTroubleReceiving =>	ERROR errorComm[noisyChannel, wordsInBufCt, NIL];			errorNotReceiving =>		ERROR errorComm[notReceiving, 0, NIL];			illegalReason =>			ERROR errorComm[illegalEnd, wordsInBufCt, NIL];		ENDCASE;	};END;END;--of GetBufferl2999e1k72\5i73I59i22I103i26I237i14IGetAJob: PUBLIC PROC[] RETURNS[wordsReturned: CARDINAL _ 0]=--Changed this routine.  It used to get a 1-word code that specified data or attributes.-- If the code was attributesCode, it would get the attributes and return.-- Now it just reads in the first 1K words (or what ever is available) and checks to see whether it is an Interpress doc or a Press doc.{	typedMessage: BOOLEAN _ FALSE;	getAJobEndReason: EndReason _ illegalReason;	--code: CARDINAL;	pupAddressString: STRING _ [30];	IF gotAJob THEN ERROR errorComm [alreadyHaveJob, , ];	shortFile _ FALSE;	WHILE ~gotAJob DO	pupAddressString.length _ 0;	IF ~connectionOpen THEN		{IF ~pupPkgExtant THEN			{PupPackageMake[];			 pupPkgExtant _ TRUE;			 GetPupAddress[pupPtr, "ME"];		--don't use the normal socket for debugging!			 pupPtr.socket _ PupSocketID[1, 25B];	--[0, 20B] is the normal printer socket			};--use [1, 25B] for debugging PressNetSender		senderAddress _ EFTPOpenForReceiving[pupPtr^!			EFTPTimeOut =>				{IF ~typedMessage					THEN {WriteLine["Listening for print request."]; typedMessage _ TRUE;};				 RESUME};			EFTPAlreadyReceiving =>				{WriteLine["Connection Already Open!"L];				 ERROR errorComm[alreadyReceiving, 0, NIL]};			];		connectionOpen _ TRUE;		};	WriteString["Connection open to "L];	AppendPupAddress[pupAddressString, senderAddress];	WriteLine[pupAddressString];	typedMessage _ FALSE;	[wordsReturned] _ GetBuffer[tfsBuff, TFSwordsPerPage!		errorComm =>		 {IF e = endReceiving AND (wordsReturned _ wordsTransferred) # 0			THEN {shortFile _ TRUE; CONTINUE}		  	ELSE {EFTPFinishReceiving[!						EFTPNotReceiving => CONTINUE];			 		connectionOpen _ FALSE; LOOP};		  };							];	--get first page's bytes of file	PostJob[];--see if this is an InterPress file; if not, is a Press file	ENDLOOP;};--GetAJobPostJob: PROC[]={IF tfsBuff[0] # HeraldStart THEN pressFile _ TRUE ELSE pressFile _ FALSE; 	gotAJob _ TRUE;};GetBitsFromBands: PUBLIC PROC[] RETURNS[okToProceed: BOOLEAN _ FALSE]=--Raises no signals or errorsBEGIN	pa: PageAttributes;	endReason: EndReason _ illegalReason;	iii: CARDINAL _ 0;	--used in data fetching loop	inCoreAddress: POINTER TO ARRAY OF WORD;	tooMuchData: BOOLEAN _ FALSE;	--set when sender sends too much data	receivedFile: BOOLEAN _ FALSE;	shortFile _ FALSE;BEGIN--this routine destroys the ddMgr if it fails	OpenPressBits[filePtr! errorTfs => {SELECT e FROM  noTrident => WriteLine["Trident not up"L];												 cantFindFile => WriteLine["Can't find Press.bits"L];												 ENDCASE; GOTO getOut --no state to clean up--}];		OpenPressBands[!  errorTfs => {SELECT e FROM 	noTrident => WriteLine["Trident not up"L];												 cantFindFile =>													{WriteLine["Can't find PBand.0"L];													 disk _ TfsCloseDisk[disk, FALSE]; --get rid of Bits file disk object													ddMgr _ NIL};				  --and the community ddMgr												ENDCASE; GOTO getOut}];	bandDiskBuffer _ InitTfsBandsBuffer[];	--init the input buffer for Press.Bands	pa _ MesaBands.ShowBandsInit[hornet];	GetTfsBuffer[];	InitTfsBuffer[bitsFile];	--init the output buffer to Press.bits	inCoreAddress _ InitScanBuffer[pa];	--get enough space for a scan line; must call after InitTfsBufferl2999e1k72\2b9B54i299I80i18I291i45I40i40I8i41I781i32I13i60I13i9I1b8B103b17B55i30I87i28I74i39I58i45I195i25I220i35I30i28I77i40I7f1 10f0 66i38I40i63I	MesaBands.ShowBands[];	ReleaseScanBuffer[FALSE, inCoreAddress, pa];	--write out blank scan lines if last band is not full & free storage	WritePageGPage[pa!						--get out if error		errorTfs => IF (e = tridentError) 			THEN {WriteLine["Transfer Complete, but"L]; endReason _ tridentError; GOTO done}];	ReleaseTfsBuffer[];	ReleaseTfsBandsBuffer[];	CloseBandsFile[];			--must call this before TfsCloseDisk[,FALSE] as it needs a disk descriptor	disk_TfsCloseDisk[disk, FALSE];	ddMgr _ NIL;	okToProceed _ TRUE;EXITSgetOut=> NULL;done=> l2999e1k72\1f1 10f0 13i1I46i68I1i2I21i21I171i1I20i74I69i1I	{	ReleaseScanBuffer[FALSE, inCoreAddress, pa];	--write out blank scan lines if last band is not full & free storage	ReleaseTfsBandsBuffer[];	ReleaseTfsBuffer[];	SELECT endReason FROM		emptyBuffReason=>	WriteLine["Empty Page: error!"L];		illegalReason =>	WriteLine["illegal End."L];		tridentError =>	WriteLine["Trident error"L];		hitEOF => 	WriteLine["Ran into EOF on write"L];		dANotFilled =>	WriteLine["Trident software trouble -- bad DA multiple times"L];	ENDCASE;l2999e1k72(0,3648)(1,4269)(2,7867)\49i68I	SELECT endReason FROM	   tridentError => NULL;	   emptyBuffReason, hitEOF, dANotFilled => { CloseBandsFile[]; disk _ TfsCloseDisk[disk, FALSE]; ddMgr _ NIL};	ENDCASE;	};l2999e1k72(1,7232)(2,65535)END;l3634d2999e1k72(635)	IF checkTermination THEN		IF ~okToProceed THEN CallDebugger["Exiting with error from GetBits"L];END;--of GetBitsFromBandsl2999d2364e1k72\103i21bI1BStoreScanLine: PUBLIC PROC [p: LONG POINTER]=--Put scan line into Press.bits. Breaks scan line up if it overflows a Trident Page. Also pads the band out to 1K boundary.--Now, if we overflow the Tfsbuffer, we automatically write out the full page and add remainder of scan to newly emptied buffer. If that was the last scan line of the buffer, we write out the partial page regardless whether we just flushed the full buffer since we're padding the trident page at the end of a band. Hence the test for scanInBand at end.{	wordsLeft: CARDINAL;	wordsLeft _ (TFSwordsPerPage-wordAddrInTfsBuffer);	LongCOPY[p,  MIN[wordsLeft, scanLength], tfsBuff + wordAddrInTfsBuffer];	IF wordsLeft < scanLength	--wordsLeft can be zero		THEN			{WriteTfsPage[];			 LongCOPY[p+wordsLeft, wordAddrInTfsBuffer _ (scanLength-wordsLeft), tfsBuff];			}		ELSE wordAddrInTfsBuffer _ wordAddrInTfsBuffer + scanLength;--can = TFSwordsPerPage	IF (scanInBand _ scanInBand + 1) = bandWidth THEN		{WriteTfsPage[];		wordAddrInTfsBuffer _ 0;				--reset wordAddrInTfsBuffer to 0 to avoid an empty page next go around		scanInBand _ 0;		};};--StoreScanLineInitTrident: PUBLIC PROC[ddMgrPt: ddMgrPtr _ NIL, iDisk: tfsdskPtr] RETURNS [disk: tfsdskPtr]=BEGIN	IF ~uCodeLoaded THEN					--load microcode		{RamBoot["MesaSlotMc.br"! CantFindFile => GOTO noUcode;							FileLooksCrufty  =>GOTO badUcode];	 	 uCodeLoaded _ TRUE;};	IF iDisk # NIL THEN disk _ TfsCloseDisk[iDisk, TRUE];	disk _ TfsInit[TRUE,, ddMgrPt,];				--initmode=TRUE, drive, ddMgr, freshDisk=FALSE EXITS	noUcode => WriteLine["Can't find file MesaSlotMc.br."L];	badUcode => WriteLine["Microcode file ""MesaSlotMc.br"" is malformed."L];END;--of InitTridentGetTfsBuffer: PROC[]={	IF tfsSeg # NIL THEN DeleteDataSegment[tfsSeg];	tfsSeg _ NewDataSegment[DefaultBase, (TFSwordsPerPage + PageSize-1)/PageSize];	tfsBuff _ SegmentAddress[tfsSeg];l2999e1k72\b14B32i123I1i352I179i23I177i8I113i74I26i16bI12B118i14I219i47I147i14I1b14B10i1I	pages _ [fillInDA, fillInDA, fillInDA, fillInDA, fillInDA, fillInDA];	dAsLength _ pagesLength;					--this varies with the bits file writing};--GetTfsBufferInitTfsBuffer: PROC[file: OutputFile]={--Call this routine only after calling GetTfsBuffer!--this routine assumes we're writing. If we were reading only, the ExtendFile call would not be automatic. However,--nearly all the routines that use the trident in this pack write to it.	pg: CARDINAL _ (IF file=bitsFile THEN 2 ELSE 1);	nmChars: CARDINAL _ 0;	dAs: DESCRIPTOR FOR ARRAY OF PAGE _ DESCRIPTOR[@pages[1], dAsLength];	dAs[0] _ leaderVda;	dAs[1] _ firstVda;l2999e1k72\101i40I5i13bI14B27i242I[]_ TfsActOnPages[disk, NIL, dAs, filePtr^, 1, 2, dcReadLnD, @nmChars, dcReadLnD, @nmChars,  DefaultTfsCleanupRtn, DefaultTfsErrorRtn, TRUE, 0];	--leave the VDA to pages 2 and 3 in the arrayl4269d3634e1k72\147i43I--	IF dAs[pg+1] = eofDA THEN	----make sure there's a DA for future writes--		ExtendFile[dAs, pg+1, TRUE ];	----TRUE="rewrite startPage label to point to newly-added page"	outputFile _ file;					--let CloseTfsBuffers know not to truncate	SELECT file FROM		anyOtherFile=> 	pageNum _ 1;		bitsFile=>	pageNum _ 2;		--begin writing the bits file at page 2.	ENDCASE;	dAsBase _ @pages[1];};--InitTfsBufferGetTfsBandsBuffer: PUBLIC PROC[] RETURNS[POINTER]={	RETURN[bandDiskBuffer]};	--GetTfsBandsBufferCheckPage: PROC[p: PAGE, both: BOOLEAN _ TRUE] RETURNS [notOK: BOOLEAN _ FALSE]={	IF p = fillInDA		THEN												--the vda is not valid			IF debuggerIfTfsError				THEN 	CallDebugger["next disk address is fillInDA"L]				 ELSE	RETURN[TRUE];	IF ~both THEN RETURN[notOK];	IF p = eofDA		THEN												--the vda is not valid			IF debuggerIfTfsError				THEN 	CallDebugger["next disk address is eofDA"L]				 ELSE	RETURN[TRUE];};ExtendFile: PROC[dAs: DESCRIPTOR FOR ARRAY OF PAGE, lastPage: PAGE, linkPointer: BOOLEAN _ FALSE, nmChars: TfsMaxChars _ TfsCharsPerPage]={--may want to write one page of data here and one following label	dAs[lastPage] _ dAs[lastPage+1] _ fillInDA;	--was eofDAl2999e1k72\i171I28i40I77i40I35i16bI20B59i19I1b13B108i20I171i20I107b12B130i2b64BI45i11I	[] _ TfsWritePages[disk, NIL, dAs, filePtr^, lastPage, lastPage, dcWriteLnD, @nmChars, nmChars, tfsBuff, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, TRUE, 0];l4269d2999e1k72	IF linkPointer THEN						--write the forward pointer in prev pagel4269d2999e1k72\28i38I	[] _ TfsWritePages[disk, NIL, dAs, filePtr^, lastPage-1, lastPage-1, dcWriteD, NIL, nmChars, tfsBuff, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, TRUE, 0];l4904d3634e1k72	extendedFile _ TRUE;};--ExtendFileWriteTfsPage: PROC[wordCt: TfsMaxWords _ TFSwordsPerPage]=--This routine writes only full pages!!!!!{	endReason: EndReason _ illegalReason;	nmChars: CARDINAL _ BytesPerWord*wordCt;	dAs: DESCRIPTOR FOR ARRAY OF PAGE _ DESCRIPTOR[dAsBase, dAsLength];	BEGIN	IF ((lastPageChars _ nmChars) # TfsCharsPerPage) THEN GOTO nullExit;			--let CloseTfsBuffers clean up	IF CheckPage[dAs[pageNum], TRUE] THEN {endReason _ dANotFilled; GOTO done};	dAs[pageNum+1] _ fillInDA;				--so as to get the real VDAl2999e1k72\26i10bI14B47bi42BI233i30I112i25I--since we're writing a full page, will need a page following, even if it turns out to be of length zero (last page of file).l3634e1k72\2bi123BI[]_TfsWritePages[disk, NIL, dAs, filePtr^, pageNum, pageNum+1, dcWriteD, NIL, 0, tfsBuff, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, TRUE, 0!		BadErrorRtn => {endReason _ tridentError; GOTO done;};];l4904d3634e1k72	dAs[pageNum-1] _ dAs[pageNum]; dAs[pageNum] _ dAs[pageNum+1];	dAsLength _ dAsLength + 1;				--extend range of descriptor from new base	dAsBase _ dAsBase - 1;					--must reset base because the low-level disk routines write pageNum onto	pageNum _ pageNum + 1;					--     the disk label; and the vda is accessed from dAs using pageNum!	EXITS	done=> l2999e1k72\98i40I31i70I31i68I		SELECT endReason FROM			illegalReason =>					WriteLine["illegal End."L];			tridentError, hitEOF, dANotFilled =>	errorTfs[endReason];		ENDCASE;	nullExit=> NULL;	END;l2999e1k72};--WriteTfsPageReleaseTfsBuffer: PROC[]={	IF tfsSeg # NIL THEN		DeleteDataSegment[tfsSeg];	tfsSeg _ NIL;};--ReleaseTfsBufferCloseTfsBuffers: PROC[]=--this routine never writes full pages; writes partial or zero-length pages only.--It also never extends the file. All file extension is done in WriteTfsPage.BEGIN	dAs: DESCRIPTOR FOR ARRAY OF PAGE _ DESCRIPTOR[dAsBase, dAsLength];	lastPage: CARDINAL _ pageNum;--this guy is guaranteed to be there.	nmChars: CARDINAL _ 0;	leaderChars: CARDINAL _ TfsCharsPerPage;	lastDA, toDelete: PAGE;	ld: POINTER TO LD _ LOOPHOLE[tfsBuff];	IF outputFile = bitsFile THEN GOTO getout;--don't truncate press.bits	IF ~(lastPageChars = TfsCharsPerPage)THEN nmChars _ lastPageChars;l2999e1k72\2i16I1b16B78i19bI19B9i2b157BI109i12b10B13I178i25I[] _ CheckPage[dAs[lastPage], FALSE];--error if dAs[lastPage]= fillInDAl4904d3634e1k72\37i--[] _ TfsActOnPages[disk, NIL, dAs, filePtr^, lastPage, lastPage, dcReadLnD, @leaderChars, dcReadLnD, tfsBuff, DefaultTfsCleanupRtn, , TRUE, 0];----get next VDA for DeletePagesl4904d3634e1k72\i177I--the value in dAs[lastPage+1] was filled in by the two-page write in WriteTfsPagetoDelete _ dAs[lastPage + 1]; dAs[lastPage + 1] _ eofDA;--for labell3634e1k72\1i83I56i11I[]_TfsWritePages[disk, NIL, dAs, filePtr^, lastPage, lastPage, dcWriteD, @nmChars, nmChars, tfsBuff, NIL, DefaultTfsErrorRtn, NIL, 0];l4904d3634e1k72	TfsDeletePages[disk, tfsBuff, toDelete, filePtr^, , lastPage+1,];	--read in leader page and fix hintLastPageFa	lastDA _ dAs[lastPage];	dAs[0] _ eofDA; leaderChars _ TfsCharsPerPage;	dAs _ DESCRIPTOR[dAsBase+1, dAsLength-1]; dAs[0] _ leaderVda; dAs[1] _ fillInDA;l2999e1k72\67i45I[] _ TfsActOnPages[disk, NIL, dAs, filePtr^, 0, 0, dcReadLD, @leaderChars, dcReadLD, tfsBuff, NoopTfsCleanupRtn, , TRUE, 0];l4269d3634e1k72ld.hintLastPageFa _ FA[lastDA, lastPage, nmChars];l4269d3634e1k72[] _ TfsActOnPages[disk, NIL, dAs, filePtr^, 0, 0, dcWriteD, @leaderChars, dcWriteD, tfsBuff, NoopTfsCleanupRtn, , TRUE, 0];l4269d3634e1k72	ReleaseTfsBuffer[];	 EXITSgetout =>	ReleaseTfsBuffer[];END;--CloseTfsBuffersInitScanBuffer: PROC[pa: PageAttributes] RETURNS [coreAddress: POINTER]={	padding: CARDINAL;	IF scanSeg # NIL THEN DeleteDataSegment[scanSeg];	scanSeg _ NewDataSegment[DefaultBase, (pa.bitWc + PageSize-1)/PageSize];	coreAddress _ SegmentAddress[scanSeg];l2999e1k72\65i17bI1B1b14B60i1I	scanInBand _ wordAddrInTfsBuffer _ 0;		--init the scan line # we're on	scanLength _ pa.bitWc;	--will never need more than bandWidth scans	IF (padding _ pa.firstScan MOD bandWidth) > 0 THEN		{Zero[coreAddress, pa.bitWc];		FOR i: CARDINAL IN [0..padding)			DO StoreScanLine[coreAddress]; ENDLOOP;		};};--InitScanBufferReleaseScanBuffer: PROC[aborting: BOOLEAN _ FALSE, address: POINTER, pa: PageAttributes]=--Pads the first and last bands with blank scan lines if, for instance, firstScan is not = to a (multiple of bandWidth + 1)BEGIN	padding: CARDINAL;	IF ~aborting THEN		{padding _ pa.lastScan MOD bandWidth;		IF padding # bandWidth-1 THEN			{Zero[address, pa.bitWc];			FOR i: CARDINAL IN [1..bandWidth-padding)	--output bandWidth-padding-1 lines			DO	StoreScanLine[address];			ENDLOOP};};	DeleteDataSegment[scanSeg];	scanSeg _ NIL;END;--ReleaseScanBufferTridentThere: PROC[]={	IF ddMgr = NIL THEN ddMgr _ TfsCreateDDmgr[];	disk _ InitTrident[ddMgr, disk];									--loads disk object	IF disk = NIL THEN ERROR errorTfs[noTrident];};--TridentThereOpenPressBits: PROC[filePtr: POINTER TO FP]={	TridentThere[];	OpenAppropriateFile[bitsStr, filePtr];};--OpenPressBitsOpenAppropriateFile: PROC[fileName: STRING, filePtr: POINTER TO FP]=--This routine deletes the global ddMgr if it can't find Press.bits on the Trident. It also deletes the disk object.--Thus, this routine must be called before calling OpenPressBands, as that routine assumes this routine has already succeeded.BEGIN	fileSys: CARDINAL _ 1;						--TP0:sys 1--	IF ddMgr = NIL THEN ddMgr _ TfsCreateDDmgr[];--	disk _ InitTrident[ddMgr, disk];									- -loads disk object--	IF disk = NIL THEN ERROR errorTfs[noTrident];	[leaderVda, firstVda,] _ TfsOpenFile[disk, fileName, read, filePtr];--must fool Open with read. Only other option is create.	IF firstVda=0 AND disk.tfskd.model = 80 THEN  --"not found" if not on 1st file system.			GOTO errorXit;	WHILE firstVda = 0 AND fileSys < 23 						--check all filesystems on a T300	 DO													--drives 0-7 and 3 filesystems/drive		IF disk # NIL THEN			disk_LOOPHOLE[TfsCloseDisk[disk, TRUE]];		--keep ddMgr, and make disk NIL 		disk _ TfsInit[TRUE, BITOR[BITSHIFT[(fileSys MOD 3), 8], (fileSys/3)], ddMgr,];		fileSys _ fileSys + 1;		IF disk = NIL THEN LOOP;		[leaderVda, firstVda, ] _ TfsOpenFile[disk, fileName, read, filePtr];	ENDLOOP;	IF firstVda = 0 THEN 			GOTO errorXit;	--not anywhere on T300EXITSerrorXit =>	{IF disk # NIL THEN disk _ TfsCloseDisk[disk, FALSE];				ddMgr _ NIL;				ERROR errorTfs[cantFindFile]};END;--OpenAppropriateFilel2999e1k72\41i31I27i44I169i17bI18B73i124I192i34I95i20bI2B2b14B98i19I66b15B94i13I2b19B50i244I35i11I96i20I123i54I46i46I14i1I43i34I20i34I65i33I260i22I130i23IWritePageGPage: PROC[pa: PageAttributes]=--can raise errorTfs[tridentError]{	pageBuf: ARRAY[0..TFSwordsPerPage) OF WORD; --Plug in PageG info and write this buffer to disk	firstPage: POINTER TO FirstPage _ LOOPHOLE[@pageBuf[0]];	nmChars: CARDINAL _ BytesPerWord*TFSwordsPerPage;	dAs: DESCRIPTOR FOR ARRAY OF PAGE _ DESCRIPTOR[@pages[1], dAsLength];	dAs[1] _ firstVda;	Zero [@pageBuf[0], TFSwordsPerPage];	firstPage.nPages _ 1;	firstPage.pageGSize _ SIZE[PageG];	firstPage.printerMode _ (IF pa.scanDirection = portrait THEN 3 ELSE 8);	firstPage.password _ PressPassword;	firstPage.pageGs[0].FirstBand _ pa.firstScan/bandWidth;	firstPage.pageGs[0].LastBand _ pa.lastScan/bandWidth;	firstPage.pageGs[0].BitMargin _ pa.margin;	firstPage.pageGs[0].BitWc _ pa.bitWc;	firstPage.pageGs[0].BitPage _ 1;	--i.e., first page after the firstPge	firstPage.pageGs[0].PageNumber _ 1;	--i.e., from first page of Press file	[]_ TfsActOnPages[disk, NIL, dAs, filePtr^, 1, 1, dcWriteD, @nmChars, dcWriteD, @pageBuf[0], DefaultTfsCleanupRtn, DefaultTfsErrorRtn, TRUE, 0!	BadErrorRtn => GOTO done];l2999e1k72\1b14B28i35I48i49I639i37I38i37IEXITSdone => errorTfs[tridentError];};--WritePageGPageCloseServerConnection: PROC[]={	IF ~gotAJob THEN GOTO done;	EFTPFinishReceiving[!			EFTPNotReceiving => CONTINUE];	--acknowledge to sender.	PupPackageDestroy[];	gotAJob _ pupPkgExtant _ connectionOpen _ FALSE;EXITS  done => NULL;};--CloseServerConnectionl2999e1k72\42i18bI21B99i24I98i2I21iTypeOutStatus: PROC[dAs: DESCRIPTOR FOR ARRAY OF PAGE, pageNum, charsInPage: CARDINAL, beforeActOnPages: BOOLEAN _ TRUE]={--for debugging	i: CARDINAL;--debugging variable	IF ~dasMonitor THEN RETURN;	IF beforeActOnPages		THEN WriteLine["Before ActOnPages"L]		ELSE WriteLine["After ActOnPages"L];	WriteString["page number: "L];	WriteDecimal[pageNum]; WriteChar[CR];	IF beforeActOnPages		THEN {WriteString["Before ActOnPages -- chars received from GetAPage: "L];				WriteDecimal[charsInPage]; WriteChar[CR];};	WriteLine["dAs[0]..dAs[dAsLength] (length changes with page#)"];	FOR i IN [0..dAsLength) DO		WriteOctal[dAs[i]]; WriteChar[SP]; WriteChar [SP]; ENDLOOP;	WriteChar[CR]; WriteChar[CR];};--TypeOutStatus--initialization (for debugging only)--filePtr _ @fp;  Use this if Mesa doesn't allow startup assignmentEND. -- PressNetListener.mesal2999e1k72(0,3648)(1,4269)(2,8064)\b14B141i18I539i13I2i39I73i25I-- Last Edited:  October 27, 1981  4:35 PM   By:  GWilliams e1(1792)\i-- added code to try for the next vda again if not filled by TfsActOnPages the first -- Last Edited:  October 27, 1981  3:12 PM   By:  GWilliams e1\i-- added debuggerIfTfsError-- Last Edited:  October 26, 1981  2:38 PM   By:  GWilliams e1\i-- added check that filled-in DA is valid at GetBits & added EFTPFinishReceiving.-- Last Edited:  October 26, 1981  10:54 AM   By:  GWilliams e1\i--added fileLengthReport-- Last Edited:  October 27, 1981  5:17 PM   By:  GWilliams e1\2i-- put check at end of GetBits to stop if not continuing-- Last Edited:  November 24, 1981  3:04 PM   By:  GWilliams e1\i-- In middle of revamping to accept bits on a scan line basis rather than read a whole Press.bits file.-- Last Edited:  December 2, 1981  11:16 AM   By:  GWilliams e1\i-- Back again - - took time out to help Starkweather & to write Performance appraisal.-- Last Edited:  December 8, 1981  6:03 PM   By:  GWilliams e1\i-- Back again - - Press.fonts broke, now debugging.-- Last Edited:  December 9, 1981  4:38 PM   By:  GWilliams e1\i-- Fixing OpenPressBits for when can't find Press.bits on T300.-- Last Edited:  December 10, 1981  4:24 PM   By:  GWilliams e1\i-- In InitTfsBuffer, was loading vda of 2nd page of bits file with firstVda.-- Last Edited:  December 21, 1981  3:49 PM   By:  GWilliams e1\i-- Changed CloseServerConnection to not do EFTPFinishReceiving on closing.-- Last Edited:  December 21, 1981  5:04 PM   By:  GWilliams e1\i-- Changed GetBits to ask for more data than needed in order to wait for sender disconnect.-- Last Edited:  December 31, 1981  3:17 PM   By:  GWilliams e1\i-- Changed ordering of call on InitTfsBuffer and InitScanBuffer.-- GetBits is called by Press.mesa-- Last Edited:  February 8, 1982  11:22 AM   By:  GWilliams e1\i-- WritePageGPage now gets printerMode from pageAttributes record sent from client.-- Last Edited:  March 5, 1982  3:48 PM   By:  GWilliams e1\i-- Added Press Bands code to read Cedar bands file entries and explode into press.bits.-- Last Edited:  March 8, 1982  1:59 PM   By:  GWilliams e1\i-- Refining Bands code: clean up bits file disk object if fail in openning band sfile.-- Last Edited:  July 9, 1982  3:11 PM   By:  GWilliams e1\i-- Changing to 1) listen for both Press files and Bands files 2) in doing so, must possibly extend TridentTemp.press, or shorten it.-- Last Edited:  July 15, 1982  3:20 PM   By:  GWilliams e1\i-- Last Edited:  August 13, 1982  4:37 PM   By:  GWilliams e1\i-- faking out TfsWritePages by shoving in an EOFDA at end of file.-- Last Edited:  August 16, 1982  6:47 PM   By:  GWilliams e1\i-- must now write the leader page to keep the file current for BFS and TFS.-- Last Edited:  August 31, 1982  10:45 AM   By:  GWilliams e1\i-- Had trouble linking new pages in the file system, need to keep file one page longer than current page, as in the Streams code.-- Last Edited:  September 1, 1982  11:07 AM   By:  GWilliams e1\i-- Still linking new pages @end of file, do it by writing previous header over when adding new page.-- Last Edited:  November 17, 1982  4:03 PM   By:  GWilliams e1\i-- Debugging again.e1\i20I(635)\i