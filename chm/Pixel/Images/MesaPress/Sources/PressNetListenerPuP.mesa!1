-- File:  PressNetListener.mesa: Routines for getting for a file at a printing server.e1(1792)-- GetBits is called by Press.mesa-- Last Edited:  April 16, 1982  2:36 PM   By:  GWilliams & Pier e1-- Normalizing for Press Bands world.e1\3i35IDIRECTORYe1AltoDefs USING [BytesPerWord, PageSize],l4269d3634e1k72(635)AltoRam USING [CantFindFile, FileLooksCrufty],l4269d3634e1k72EFTPDefs USING [EFTPAbortReceiving, EFTPAlreadyReceiving, EFTPEndReceiving, EFTPFinishReceiving, EFTPGetBlock, EFTPNotReceiving, EFTPOpenForReceiving, EFTPTimeOut, EFTPTroubleReceiving],l4269d3634e1k72IODefs USING[CR, SP, WriteChar, WriteDecimal, WriteOctal, WriteLine, WriteString],l3634e1k72InlineDefs USING [BITOR, BITSHIFT, LongCOPY],	--LongCOPY[from, nwords, to]l4269d3634e1k72\46i28IMesaBands USING [BandDevice, ShowBands, ShowBandsInit],l4269d3634e1k72MiscDefs USING[CallDebugger, Zero],l4269d3634e1k72PressDefs USING [PageG, PressPassword, RamBoot, uCodeLoaded],l4269d3634e1k72PressNetDefs USING [attributesCode, EndReason, imageCode, PageAttributes],l4269d3634e1k72PressBandsDefs USING [CloseBandsFile, OpenPressBands, InitTfsBandsBuffer, ReleaseTfsBandsBuffer],l4269d3634e1k72PupDefs USING [GetPupAddress, PupPackageDestroy, PupPackageMake],l4269d3634e1k72PupStream USING [AppendPupAddress],l4269d3634e1k72PupTypes USING[PupAddress, PupSocketID],l4269d3634e1k72SegmentDefs USING[DataSegmentHandle, DefaultBase, DeleteDataSegment, NewDataSegment, SegmentAddress],l4269d3634e1k72SlotDefs USING [longScans],l4269d3634e1k72StreamDefs USING[AccessOptions, DiskHandle, FileNameError, NewByteStream, Read],l4269d3634e1k72StringDefs USING [AppendChar, EquivalentString],l4269d3634e1k72TridentDefs USING [BadErrorRtn, dcReadLD, dcWriteD, ddMgrPtr, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, eofDA, fillInDA, FP, PAGE, TfsActOnPages, TfsCloseDisk, TfsCreateDDmgr, tfsdskPtr, TfsInit, TfsOpenFile, TFSwordsPerPage];l4269d3634e1k72PressNetListener: PROGRAMe1(1792)\1b16BIMPORTS AltoRam, EFTPDefs, IODefs, InlineDefs, MesaBands, MiscDefs, PressDefs, PressBandsDefs, PupDefs, PupStream, SegmentDefs, StreamDefs, StringDefs, TridentDefsl4904d3634e1k72(635)EXPORTS PressBandsDefs, PressNetDefs =l3633e1(1792)l3633d2998e1BEGIN OPEN AltoDefs, AltoRam, EFTPDefs, IODefs, InlineDefs, MesaBands, MiscDefs, PressDefs, PressBandsDefs, PressNetDefs, PupDefs, PupStream, PupTypes, SegmentDefs, SlotDefs, StreamDefs, StringDefs, TridentDefs;l3633d2998e1l4269d2999e1k72(635)	TerminationReason: TYPE = {errorTermination, fileDoneTermination, pageDoneTermination, nullTerminationReason};l4278d2999e1k72--Press Stuff	bandWidth: CARDINAL _ 0;	FirstPage: TYPE = MACHINE DEPENDENT RECORD	[	nPages: CARDINAL _ 1,		pageGSize: CARDINAL _ SIZE[PageG],		printerMode: CARDINAL,	--3=portrait, 8=Landscape		password: CARDINAL _ PressPassword,		pageGs: ARRAY[0..80) OF PageG	--enough to fit into a Trident Page	];	scanSeg: DataSegmentHandle _ NIL;	scanLength: CARDINAL;	wordAddrInTfsBuffer: CARDINAL;	scanInBand: CARDINAL;--net stuff 	connectionOpen: BOOLEAN _ FALSE;	gotAJob: BOOLEAN _ FALSE;	hostAddress: PupAddress;	pupPtr: POINTER TO PupAddress _ @hostAddress;	senderAddress: PupAddress;	pupPkgExtant: BOOLEAN _ FALSE;--Band Stuff	device: PUBLIC BandDevice _ end;--Tfs stuff	bandDiskBuffer: POINTER;	ddMgr: PUBLIC ddMgrPtr _ NIL;	disk: tfsdskPtr _ NIL;	bufferWordLen: CARDINAL = TFSwordsPerPage;	bufferByteLen: CARDINAL = BytesPerWord*bufferWordLen;l3008d2999e1k72\i14I157i28I68i35I120i10I195i13I35i12I	pagesLength: CARDINAL = 4;	firstVda: CARDINAL _ 0;						--allways holds page 1 of the file	fp: FP;											--fp gets filled in by TfsOpenFile	filePtr: POINTER TO FP _ @fp;	tfsSeg: DataSegmentHandle _ NIL;	tfsBuff: POINTER TO ARRAY[0..TFSwordsPerPage) OF CARDINAL;	pages: ARRAY[0..pagesLength] OF PAGE;	dAsLength: CARDINAL;	dAsBase: POINTER;			--this is modified after ea call on TfsActOnPages.	pageNum: CARDINAL;--Debugging Switches	fileLengthReport: BOOLEAN _ TRUE;	--print out length of received file in pages	dasMonitor: BOOLEAN _ FALSE;--for debugging tfs file handler.	debuggerIfTfsError: PUBLIC BOOLEAN _ TRUE;	checkTermination: PUBLIC BOOLEAN _ TRUE;--Signals & ErrorsCommErr: TYPE = {alreadyHaveJob, nullComErr, endReceiving, noisyChannel, protocolError, illegalEnd, notReceiving, alreadyReceiving};errorComm: ERROR[e: CommErr, wordsTransferred: CARDINAL _ 0, s: STRING _ NIL] = CODE;errorTfs: PUBLIC ERROR[e: EndReason] = CODE;GetBits: PUBLIC PROC[] RETURNS[okToProceed: BOOLEAN _ FALSE]=--Raises no signals or errorsBEGIN	pa: PageAttributes;	endReason: EndReason _ illegalReason;	iii: CARDINAL _ 0;	--used in data fetching loop	inCoreAddress: POINTER TO ARRAY OF WORD;	tooMuchData: BOOLEAN _ FALSE;	--set when sender sends too much data	receivedFile: BOOLEAN _ FALSE;	scanLineLength: CARDINAL;			--copy of scanLength	wordsInBuff: CARDINAL;BEGIN	IF ~FirstPageCheck[] THEN RETURN[FALSE];	WHILE ~receivedFile	DOe1k72\58i34I22i32I1i1I30i1I92i1I61i1I20i51I20i22I37i42I32i31I87i20bI7B126b9B77b10B37b7B55i30I87i28I74i39I60i20I	OpenPressBits[filePtr! errorTfs => {SELECT e FROM  noTrident => WriteLine["Trident not up"L];												 cantFindFile => WriteLine["Can't find Press.bits"L];												ENDCASE; GOTO getOut}--no state to clean up--];	pa _ GetAJob[! errorComm => IF e = alreadyReceiving THEN {PupPackageDestroy[]; GOTO getOut}];	bandWidth _ (IF pa.bitWc > longScans THEN 8 ELSE 16);	InitTfsBuffer[];	inCoreAddress _ InitScanBuffer[pa];	--get enough space for a scan line; must call after InitTfsBuffer	scanLineLength _ scanLength;	--scan Length is valid now.l3634e1k72\194i24I3i1I207i64I30i28I	BEGIN ENABLE BEGINl3634e1k72		errorComm => 			{SELECT e FROM				noisyChannel => {WriteLine["Noisy Channel, aborting transfer"L];								EFTPAbortReceiving["Channel too noisy, aborting transfer"L!									EFTPNotReceiving => CONTINUE]};				endReceiving => WriteLine["Transfer aborted, not enough data received"L];				ENDCASE;			GOTO incompleteXFer};		errorTfs => SELECT e FROM tridentError, hitEOF, dANotFilled => {endReason _ e; GOTO done}; ENDCASE;		END;--of catch series	FOR  iii IN [0..pa.lastScan-pa.firstScan]		DO			wordsInBuff _ GetBuffer[inCoreAddress, 1];		--check header word			IF inCoreAddress[0] # imageCode THEN					{WriteLine["Buffer doesn't contain image data"L]; GOTO incompleteXFer};				wordsInBuff _ GetBuffer[inCoreAddress, scanLineLength];	--get scan line			IF wordsInBuff = 0 THEN {endReason _ emptyBuffReason; GOTO done};--blow up			StoreScanLine[inCoreAddress];				--buffers data and writes to disk.		ENDLOOP;	EXITS	incompleteXFer =>			{IF checkTermination THEN				CallDebugger["File transfer trouble"];			CloseServerConnection[];			disk_TfsCloseDisk[disk, FALSE];--delete the ddMgr too			ddMgr _ NIL;			ReleaseScanBuffer[TRUE, inCoreAddress, pa];			ReleaseTfsBuffer[];			LOOP};		--restart @ WHILE ~ receivedFilel4269e1k72\430i2I4i19I95i19I181i13I69i9I37i34I173i22I98i32I	END;l3634e1k72--now loop asking for data, waiting for an EFTPEndReceiving	BEGIN ENABLE errorComm => IF e = endReceiving THEN GOTO closeConn;		DO wordsInBuff _ GetBuffer[inCoreAddress, scanLineLength]; tooMuchData _ TRUE;		ENDLOOP;	EXITS	closeConn => NULL;	END;	CloseServerConnection[];	--turn off net driver	ReleaseScanBuffer[FALSE, inCoreAddress, pa];	--write out blank scan lines if last band is not full & free storage	WritePageGPage[pa!						--get out if error		errorTfs => IF (e = tridentError) 			THEN {WriteLine["Transfer Complete, but"L]; endReason _ tridentError; GOTO done}];	ReleaseTfsBuffer[];	disk_TfsCloseDisk[disk, FALSE];	ddMgr _ NIL;	receivedFile _ TRUE;l3634e1k72\1i61I158i2I31i2I26i21I47i68I1i1I21i21I	ENDLOOP;	okToProceed _ TRUE;EXITSgetOut=> NULL;done=> e1k72\10i1I20i1I	{	ReleaseScanBuffer[FALSE, inCoreAddress, pa];	--write out blank scan lines if last band is not full & free storage	ReleaseTfsBuffer[];	CloseServerConnection[];		--turn off net if on.e1k72(0,3648)(1,7232)\49i68I51i19I	SELECT endReason FROM		emptyBuffReason=>	WriteLine["Empty Page: error!"L];		illegalReason =>	WriteLine["illegal End."L];		tridentError =>	{WriteLine["Trident error"L];				EFTPAbortReceiving["Trident error"L];};		hitEOF => 	{WriteLine["Ran into EOF on write"L];				EFTPAbortReceiving["Trident ran into EOF on file write"L];};		dANotFilled =>	{WriteLine["Trident software trouble -- bad DA multiple times"L];				EFTPAbortReceiving["Trident software trouble -- bad DA"L];};	ENDCASE;e1k72(1,4269)(2,7867)	SELECT endReason FROM	   tridentError => NULL;	   emptyBuffReason, hitEOF, dANotFilled => {IF disk # NIL THEN disk _ TfsCloseDisk[disk, FALSE]; ddMgr _ NIL};	ENDCASE;	};e1k72(1,7232)(2,65535)END;l3634d2999e1k72(635)	IF checkTermination THEN		IF ~okToProceed THEN CallDebugger["Exiting with error from GetBits"L];END;--of GetBitse1k72\103i12bI1BGetBitsFromBands: PUBLIC PROC[] RETURNS[okToProceed: BOOLEAN _ FALSE]=--Raises no signals or errorsBEGIN	pa: PageAttributes;	endReason: EndReason _ illegalReason;	iii: CARDINAL _ 0;	--used in data fetching loop	inCoreAddress: POINTER TO ARRAY OF WORD;	tooMuchData: BOOLEAN _ FALSE;	--set when sender sends too much data	receivedFile: BOOLEAN _ FALSE;	pTypeH: DiskHandle _ NIL;	pName: STRING _ [5];BEGIN--this routine destroys the ddMgr if it fails	device _ end;	pTypeH _ NewByteStream["PrinterType"L, Read!			FileNameError => {WriteLine["Can't find file PrinterType"L];									 GOTO getOut;}];	FOR ii: CARDINAL IN [0..5) DO			AppendChar[pName, pTypeH.get[pTypeH]]; ENDLOOP;	pTypeH.destroy[pTypeH];	IF EquivalentString[pName, "Horne"L] THEN device _ hornet;	IF EquivalentString[pName, "Plate"L] THEN device _ platemaker;	IF EquivalentString[pName, "Retic"L] THEN device _ reticlemaker;	IF device = end THEN {WriteLine["Device mismatch"L]; GOTO getOut;};	OpenPressBits[filePtr! errorTfs => {SELECT e FROM  noTrident => WriteLine["Trident not up"L];												 cantFindFile => WriteLine["Can't find Press.bits"L];												 ENDCASE; GOTO getOut --no state to clean up--}];		OpenPressBands[!  errorTfs => {SELECT e FROM 	noTrident => WriteLine["Trident not up"L];												 cantFindFile =>													{WriteLine["Can't find RETBAND"L];													 disk _ TfsCloseDisk[disk, FALSE]; --get rid of Bits file disk object													ddMgr _ NIL};				  --and the community ddMgr												ENDCASE; GOTO getOut}];	bandDiskBuffer _ InitTfsBandsBuffer[];	--init the input buffer for Press.Bands	pa _ MesaBands.ShowBandsInit[device];	bandWidth _ (IF pa.bitWc > longScans THEN 8 ELSE 16);	InitTfsBuffer[];	--init the output buffer to Press.bits	inCoreAddress _ InitScanBuffer[pa];	--get enough space for a scan line; must call after InitTfsBuffere1k72\b16B55i30I87i28I74i39I114i45I714i25I220i35I30i28I77i40I7f1 10f0 96i38I40i63I	MesaBands.ShowBands[];	ReleaseScanBuffer[FALSE, inCoreAddress, pa];	--write out blank scan lines if last band is not full & free storage	WritePageGPage[pa!						--get out if error		errorTfs => IF (e = tridentError) 			THEN {WriteLine["Transfer Complete, but"L]; endReason _ tridentError; GOTO done}];	ReleaseTfsBuffer[];	ReleaseTfsBandsBuffer[];	CloseBandsFile[];			--must call this before TfsCloseDisk[,FALSE] as it needs a disk descriptor	disk_TfsCloseDisk[disk, FALSE];	ddMgr _ NIL;	okToProceed _ TRUE;EXITSgetOut=> NULL;done=> e1k72\1f1 10f0 13i1I46i68I1i2I21i21I171i1I20i74I69i1I	{	ReleaseScanBuffer[FALSE, inCoreAddress, pa];	--write out blank scan lines if last band is not full & free storage	ReleaseTfsBandsBuffer[];	ReleaseTfsBuffer[];	SELECT endReason FROM		emptyBuffReason=>	WriteLine["Empty Page: error!"L];		illegalReason =>	WriteLine["illegal End."L];		tridentError =>	WriteLine["Trident error"L];		hitEOF => 	WriteLine["Ran into EOF on write"L];		dANotFilled =>	WriteLine["Trident software trouble -- bad DA multiple times"L];	ENDCASE;e1k72(0,3648)(1,4269)(2,7867)\49i68I	SELECT endReason FROM	   tridentError => NULL;	   emptyBuffReason, hitEOF, dANotFilled => { CloseBandsFile[]; disk _ TfsCloseDisk[disk, FALSE]; ddMgr _ NIL};	ENDCASE;	};e1k72(1,7232)(2,65535)END;l3634d2999e1k72(635)	IF checkTermination THEN		IF ~okToProceed THEN CallDebugger["Exiting with error from GetBits"L];END;--of GetBitsFromBandsd2364e1k72\103i21bI1BGetAJob: PROC[] RETURNS [pa: PageAttributes]={	typedMessage: BOOLEAN _ FALSE;	getAJobEndReason: EndReason _ illegalReason;	code: CARDINAL;	wordsReturned: CARDINAL;	pupAddressString: STRING _ [30];	IF gotAJob THEN ERROR errorComm [alreadyHaveJob, , ];	WHILE ~gotAJob DO	IF ~connectionOpen THEN		{IF ~pupPkgExtant THEN			{PupPackageMake[];			 pupPkgExtant _ TRUE;			 GetPupAddress[pupPtr, "ME"];		--don't use the normal socket for debugging!			 pupPtr.socket _ PupSocketID[1, 25B];	--[0, 20B] is the normal printer socket			};		senderAddress _ EFTPOpenForReceiving[pupPtr^!			EFTPTimeOut =>				{IF ~typedMessage					THEN {WriteLine["Listening for print request."]; typedMessage _ TRUE;};				 RESUME};			EFTPAlreadyReceiving =>				{WriteLine["Connection Already Open!"L];				 ERROR errorComm[alreadyReceiving, 0, NIL]};			];		connectionOpen _ TRUE;		};	WriteString["Connection open to "L];	AppendPupAddress[pupAddressString, senderAddress];	WriteLine[pupAddressString];	typedMessage _ FALSE;	[wordsReturned] _ GetBuffer[@code, 1!		errorComm =>		 SELECT e FROM			  noisyChannel, protocolError, endReceiving =>					{EFTPFinishReceiving[!						EFTPNotReceiving => CONTINUE];					 connectionOpen _ FALSE; LOOP;};			ENDCASE		];	--get code to see if it is a Page Attributes code	IF code # attributesCode THEN		{EFTPAbortReceiving["I Expect Page Attributes first"];		 WriteLine["Connection Refused, protocol error."L];		 typedMessage _ connectionOpen _ FALSE; LOOP};	--get rid of this customer & type init message	wordsReturned _ GetBuffer[@pa, SIZE[PageAttributes]!		errorComm =>		 SELECT e FROM		 	noisyChannel, protocolError, endReceiving =>  LOOP;			ENDCASE			];	gotAJob _ TRUE;	ENDLOOP;};--GetAJobFirstPageCheck: PROC [] RETURNS[goAhead: BOOLEAN _ TRUE]={	IF SIZE[FirstPage] > TFSwordsPerPage THEN			{WriteLine["First page description exceeds Trident Page Length"];			 RETURN[FALSE]};};--FirstPageChecke1k72\b9B400i45I40i40I729i49I193i46I191i9I1b15B179iGetBuffer: PROC[buffer: POINTER, len: CARDINAL] RETURNS [wordsInBufCt: CARDINAL _ 0]=l3634d2999e1k72\b9B--copy from net Stream to buffer len amount of wordsBEGIN	blockByteLen, bytesToGet: CARDINAL _ 0;	bufferEnd: POINTER _ buffer + len;	--actually is first word past buffer	bufferPos: POINTER _ buffer;	getABuffEndReason: EndReason _ illegalReason;BEGIN	UNTIL bufferPos = bufferEnd	DO 		bytesToGet _ (bufferEnd - bufferPos) + (bufferEnd - bufferPos);	--remember, bufferEnd is one past end of buffer		blockByteLen _ 0;		blockByteLen _ EFTPGetBlock[bufferPos, bytesToGet!		EFTPNotReceiving => {getABuffEndReason _ errorNotReceiving; GOTO done;};		EFTPEndReceiving => {getABuffEndReason _ doneReason; GOTO done;};		EFTPTroubleReceiving => {getABuffEndReason _ errorTroubleReceiving; GOTO done;};		EFTPTimeOut => RETRY];			bufferPos _ bufferPos + blockByteLen/2;		wordsInBufCt _ wordsInBufCt + BITSHIFT[blockByteLen, -1];--divide by bytes/word	ENDLOOP;EXITS	done=>e1\i53I83i36I186i47I428i22I	{	--CloseServerConnection[]; - - this is done at the catch phrase higher up.		wordsInBufCt _ wordsInBufCt + blockByteLen;		SELECT getABuffEndReason FROM			doneReason =>			ERROR errorComm[endReceiving, wordsInBufCt, NIL];--not necessarily an error			errorTroubleReceiving =>	ERROR errorComm[noisyChannel, wordsInBufCt, NIL];			errorNotReceiving =>		ERROR errorComm[notReceiving, 0, NIL];			illegalReason =>			ERROR errorComm[illegalEnd, wordsInBufCt, NIL];		ENDCASE;	};END;END;--of GetBuffere1k72\5i73I147i26I237i14IStoreScanLine: PUBLIC PROC [p: LONG POINTER]=--Put scan line into Press.bits. Breaks scan line up if it overflows a Trident Page. Also pads the band out to 1K boundary.--Now, if we overflow the Tfsbuffer, we automatically write out the full page and add remainder of scan to newly emptied buffer. If that was the last scan line of the buffer, we write out the partial page regardless whether we just flushed the full buffer since we're padding the trident page at the end of a band. Hence the test for scanInBand at end.{	wordsLeft: CARDINAL;    xLength: CARDINAL _ scanLength;    from: LONG POINTER _ p;DO	wordsLeft _ (TFSwordsPerPage-wordAddrInTfsBuffer);	LongCOPY[from,  MIN[wordsLeft, xLength], tfsBuff + wordAddrInTfsBuffer];	IF wordsLeft < xLength	--wordsLeft can be zero		THEN --did not fit into buffer			{WriteTfsPage[];              from _ from+wordsLeft;              xLength _ xLength-wordsLeft;              wordAddrInTfsBuffer _ 0;			}		ELSE -- buffer had room for all the words            {wordAddrInTfsBuffer _ wordAddrInTfsBuffer + xLength;--can = TFSwordsPerPage             EXIT;};ENDLOOP;	IF (scanInBand _ scanInBand + 1) = bandWidth THEN		{WriteTfsPage[];		--reset wordAddrInTfsBuffer to 0 to avoid an empty page next go around		wordAddrInTfsBuffer _ 0;		scanInBand _ 0;		};};--StoreScanLineWriteTfsPage: PROC[]={	endReason: EndReason _ illegalReason;	loopCtr: CARDINAL;						--this detects infinite loops in GetBits	maxTries: CARDINAL = 3;	nmChars: CARDINAL _ BytesPerWord*TFSwordsPerPage;	dAs: DESCRIPTOR FOR ARRAY OF PAGE _ DESCRIPTOR[dAsBase, dAsLength];	BEGIN		IF (dAs[pageNum] _ dAs[pageNum+1]) = eofDA			THEN	{endReason _ hitEOF; GOTO done;};				--by now the vda of the next page to write is in						IF (dAs[pageNum] = fillInDA)			THEN												--the vda is not valid				IF debuggerIfTfsError					THEN 	CallDebugger["disk address is fillInDA"L]					 ELSE	{endReason _ dANotFilled; GOTO done};							dAs[pageNum+1] _ fillInDA;				--reset the to-be-pagenum+1 vda		dAsLength _ dAsLength + 1;				--extend range of descriptor from new base		dAsBase _ dAsBase - 1;					--must reset base because the low-level disk routines write pageNum onto		pageNum _ pageNum + 1;					--     the disk label; and the vda is accessed from dAs using pageNum!		dAs _ DESCRIPTOR[dAsBase, dAsLength];e1k72\2b14B32i123I1i352I243i23I287i8I117i73I52i16bI12B75i40I244i48I58i20I169i29I35i40I32i70I32i68I--		TypeOutStatus[dAs, pageNum, charsInPage, TRUE];----the TRUE means "before ActOnPages"l4269d2999e1k72\i89Ie1k72	[]_ TfsActOnPages[disk, NIL, dAs, filePtr^, pageNum, pageNum, dcWriteD, @nmChars, dcWriteD, tfsBuff, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, TRUE, 0!		BadErrorRtn => {endReason _ tridentError; GOTO done;};];l4904d3634e1k72--		TypeOutStatus[dAs, pageNum, charsInPage, FALSE];----the FALSE means "after ActOnPages"		loopCtr _ 0;		UNTIL dAs[pageNum+1] # fillInDA		DO		--the Default TfsCleanupRtn didn't fill in the next DA, try again, but don't write data this time			IF (loopCtr _ loopCtr + 1) > maxTries				THEN 				IF debuggerIfTfsError					THEN	CallDebugger["disk address is fillInDA after some retries"L]				 	ELSE	{endReason _ dANotFilled; GOTO done};			IF dAs[pageNum+1] = eofDA THEN EXIT;e1k72\i90I57i97I[]_TfsActOnPages[disk, NIL, dAs, filePtr^, pageNum, pageNum, dcReadLD, @nmChars, dcReadLD, tfsBuff, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, TRUE, 0!		BadErrorRtn => {endReason _ dANotFilled; GOTO done;};];l6174d4904e1k72		ENDLOOP;	EXITS	done=> e1k72		SELECT endReason FROM			illegalReason =>					WriteLine["illegal End."L];			tridentError, hitEOF, dANotFilled =>	errorTfs[endReason];		ENDCASE;	END;e1k72};--WriteTfsPageInitTrident: PUBLIC PROC[ddMgrPt: ddMgrPtr _ NIL, iDisk: tfsdskPtr] RETURNS [disk: tfsdskPtr]=BEGIN--load microcode	IF ~uCodeLoaded THEN		{RamBoot["MesaSlotMc.br"! CantFindFile => GOTO noUcode;							FileLooksCrufty  =>GOTO badUcode];	 	 uCodeLoaded _ TRUE;};	IF iDisk # NIL THEN disk _ TfsCloseDisk[iDisk, TRUE];	disk _ TfsInit[TRUE,, ddMgrPt,];					--initmode=TRUE, drive, ddMgr, freshDisk=FALSE EXITS	noUcode => WriteLine["Can't find file MesaSlotMc.br."L];	badUcode => WriteLine["Microcode file ""MesaSlotMc.br"" is malformed."L];END;--of InitTridentInitTfsBuffer: PROC[]={	IF tfsSeg # NIL THEN DeleteDataSegment[tfsSeg];	tfsSeg _ NewDataSegment[DefaultBase, (TFSwordsPerPage + PageSize-1)/PageSize];	tfsBuff _ SegmentAddress[tfsSeg];e1k72\2i16bI11B93i15I240i48I147i14I1b14B11i1I	pages _ [fillInDA, fillInDA, fillInDA, fillInDA, fillInDA];	dAsLength _ pagesLength;	--this varies with the bits file writing	--in next line, we are assuming that Press.bits is contiguous!!!!	pages[2] _ firstVda + 1;		--this will be accessed as dAs[pageNum+1] to set up dAs[pageNum]	dAsBase _ @pages[0];	pageNum _ 1;	--this gets incremented before using};--InitTfsBufferGetTfsBandsBuffer: PUBLIC PROC[] RETURNS[POINTER]={	RETURN[bandDiskBuffer]};	--GetTfsBandsBufferReleaseTfsBuffer: PROC[]={	DeleteDataSegment[tfsSeg];	tfsSeg _ NIL;};--ReleaseTfsBufferInitScanBuffer: PROC[pa: PageAttributes] RETURNS [coreAddress: POINTER]={	padding: CARDINAL;	IF scanSeg # NIL THEN DeleteDataSegment[scanSeg];	scanSeg _ NewDataSegment[DefaultBase, (pa.bitWc + PageSize-1)/PageSize];	coreAddress _ SegmentAddress[scanSeg];e1k72\87i40I2i66I27i64I37i36I3i16bI20B59i19I2b16B55i19bI16B60i1I	scanInBand _ wordAddrInTfsBuffer _ 0;		--init the scan line # we're on	scanLength _ pa.bitWc;	--will never need more than bandWidth scans	IF (padding _ pa.firstScan MOD bandWidth) > 0 THEN		{Zero[coreAddress, pa.bitWc];		FOR i: CARDINAL IN [0..padding)			DO StoreScanLine[coreAddress]; ENDLOOP;		};};--InitScanBufferReleaseScanBuffer: PROC[aborting: BOOLEAN _ FALSE, address: POINTER, pa: PageAttributes]=--Pads the first and last bands with blank scan lines if, for instance, firstScan is not = to a (multiple of bandWidth + 1)BEGIN	padding: CARDINAL;	IF ~aborting THEN		{padding _ pa.lastScan MOD bandWidth;		IF padding # bandWidth-1 THEN			{Zero[address, pa.bitWc];			FOR i: CARDINAL IN [1..bandWidth-padding)	--output bandWidth-padding-1 lines			DO	StoreScanLine[address];			ENDLOOP};};	DeleteDataSegment[scanSeg];	scanSeg _ NIL;END;--ReleaseScanBufferWritePageGPage: PROC[pa: PageAttributes]=--can raise errorTfs[tridentError]{	pageBuf: ARRAY[0..TFSwordsPerPage) OF WORD; --Plug in PageG info and write this buffer to disk	firstPage: POINTER TO FirstPage _ LOOPHOLE[@pageBuf[0]];	nmChars: CARDINAL _ BytesPerWord*TFSwordsPerPage;	dAs: DESCRIPTOR FOR ARRAY OF PAGE _ DESCRIPTOR[@pages[1], dAsLength];	dAs[1] _ firstVda;	Zero [@pageBuf[0], TFSwordsPerPage];	firstPage.nPages _ 1;	firstPage.pageGSize _ SIZE[PageG];	firstPage.printerMode _ (IF pa.scanDirection = portrait THEN 3 ELSE 8);	firstPage.password _ PressPassword;	firstPage.pageGs[0].FirstBand _ pa.firstScan/bandWidth;	firstPage.pageGs[0].LastBand _ pa.lastScan/bandWidth;	firstPage.pageGs[0].BitMargin _ pa.margin;	firstPage.pageGs[0].BitWc _ pa.bitWc;	firstPage.pageGs[0].BitPage _ 1;	--i.e., first page after the firstPge	firstPage.pageGs[0].PageNumber _ 1;	--i.e., from first page of Press file	firstPage.pageGs[0].BandWidth _ bandWidth;	--so outputter can do right thing	[]_ TfsActOnPages[disk, NIL, dAs, filePtr^, 1, 1, dcWriteD, @nmChars, dcWriteD, @pageBuf[0], DefaultTfsCleanupRtn, DefaultTfsErrorRtn, TRUE, 0!	BadErrorRtn => GOTO done];e1k72\41i31I27i44I169i17bI18B73i124I192i34I95i20bI2B1b14B28i35I48i49I639i37I38i37I45i33IEXITSdone => errorTfs[tridentError];};--WritePageGPageOpenPressBits: PROC[filePtr: POINTER TO FP]=--This routine deletes the global ddMgr if it can't find Press.bits on the Trident. It also deletes the disk object.--Thus, this routine must be called before calling OpenPressBands, as that routine assumes this routine has already succeeded.BEGIN	fileSys: CARDINAL _ 1;						--TP0:sys 1	IF ddMgr = NIL THEN ddMgr _ TfsCreateDDmgr[];	disk _ InitTrident[ddMgr, disk];									--loads disk object	IF disk = NIL THEN ERROR errorTfs[noTrident];	[, firstVda,] _ TfsOpenFile[disk, "Press.bits.", read, filePtr];--must fool Open with read. Only other option is create.	IF firstVda=0 AND disk.tfskd.model = 80 THEN  --"not found" if not on 1st file system.			GOTO errorXit;	WHILE firstVda = 0 AND fileSys < 23 						--check all filesystems on a T300	 DO													--drives 0-7 and 3 filesystems/drive		IF disk # NIL THEN			disk_LOOPHOLE[TfsCloseDisk[disk, TRUE]];		--keep ddMgr, and make disk NIL 		disk _ TfsInit[TRUE, BITOR[BITSHIFT[(fileSys MOD 3), 8], (fileSys/3)], ddMgr,];		fileSys _ fileSys + 1;		IF disk = NIL THEN LOOP;		[, firstVda, ] _ TfsOpenFile[disk, "Press.bits.", read, filePtr];	ENDLOOP;	IF firstVda = 0 THEN 			GOTO errorXit;	--not anywhere on T300EXITSerrorXit =>	{IF disk # NIL THEN disk _ TfsCloseDisk[disk, FALSE];				ddMgr _ NIL;				ERROR errorTfs[cantFindFile]};END;--OpenPressBitse1k72\42i18I2b13B32i244I35i11I92i19I117i54I46i46I14i1I44i34I20i34I65i33I256i22I130i17ICloseServerConnection: PROC[]={	IF ~gotAJob THEN GOTO done;	EFTPFinishReceiving[!			EFTPNotReceiving => CONTINUE];	--acknowledge to sender.	PupPackageDestroy[];	gotAJob _ pupPkgExtant _ connectionOpen _ FALSE;EXITS  done => NULL;};--CloseServerConnectione1k72\b21B99i24I98i2I21iTypeOutStatus: PROC[dAs: DESCRIPTOR FOR ARRAY OF PAGE, pageNum, charsInPage: CARDINAL, beforeActOnPages: BOOLEAN _ TRUE]={--for debugging	i: CARDINAL;--debugging variable	IF ~dasMonitor THEN RETURN;	IF beforeActOnPages		THEN WriteLine["Before ActOnPages"L]		ELSE WriteLine["After ActOnPages"L];	WriteString["page number: "L];	WriteDecimal[pageNum]; WriteChar[CR];	IF beforeActOnPages		THEN {WriteString["Before ActOnPages -- chars received from GetAPage: "L];				WriteDecimal[charsInPage]; WriteChar[CR];};	WriteLine["dAs[0]..dAs[dAsLength] (length changes with page#)"];	FOR i IN [0..dAsLength) DO		WriteOctal[dAs[i]]; WriteChar[SP]; WriteChar [SP]; ENDLOOP;	WriteChar[CR]; WriteChar[CR];};--TypeOutStatus--initialization (for debugging only)--filePtr _ @fp;  Use this if Mesa doesn't allow startup assignmentEND. -- ReticlePressNetListener.mesae1k72(0,3648)(1,4269)(2,8064)\b14B141i18I539i13I2i39I73i4I23i5I-- Last Edited:  October 27, 1981  4:35 PM   By:  GWilliams e1(1792)\i-- added code to try for the next vda again if not filled by TfsActOnPages the first -- Last Edited:  October 27, 1981  3:12 PM   By:  GWilliams e1\i-- added debuggerIfTfsError-- Last Edited:  October 26, 1981  2:38 PM   By:  GWilliams e1\i-- added check that filled-in DA is valid at GetBits & added EFTPFinishReceiving.-- Last Edited:  October 26, 1981  10:54 AM   By:  GWilliams e1\i--added fileLengthReport-- Last Edited:  October 27, 1981  5:17 PM   By:  GWilliams e1\2i-- put check at end of GetBits to stop if not continuing-- Last Edited:  November 24, 1981  3:04 PM   By:  GWilliams e1\i-- In middle of revamping to accept bits on a scan line basis rather than read a whole Press.bits file.-- Last Edited:  December 2, 1981  11:16 AM   By:  GWilliams e1\i-- Back again - - took time out to help Starkweather & to write Performance appraisal.-- Last Edited:  December 8, 1981  6:03 PM   By:  GWilliams e1\i-- Back again - - Press.fonts broke, now debugging.-- Last Edited:  December 9, 1981  4:38 PM   By:  GWilliams e1\i-- Fixing OpenPressBits for when can't find Press.bits on T300.-- Last Edited:  December 10, 1981  4:24 PM   By:  GWilliams e1\i-- In InitTfsBuffer, was loading vda of 2nd page of bits file with firstVda.-- Last Edited:  December 21, 1981  3:49 PM   By:  GWilliams e1\i-- Changed CloseServerConnection to not do EFTPFinishReceiving on closing.-- Last Edited:  December 21, 1981  5:04 PM   By:  GWilliams e1\i-- Changed GetBits to ask for more data than needed in order to wait for sender disconnect.-- Last Edited:  December 31, 1981  3:17 PM   By:  GWilliams e1\i-- Changed ordering of call on InitTfsBuffer and InitScanBuffer.-- GetBits is called by Press.mesa-- Last Edited:  February 8, 1982  11:22 AM   By:  GWilliams e1\i-- WritePageGPage now gets printerMode from pageAttributes record sent from client.-- Last Edited:  March 5, 1982  3:48 PM   By:  GWilliams e1\i-- Added Press Bands code to read Cedar bands file entries and explode into press.bits.-- Last Edited:  March 8, 1982  1:59 PM   By:  GWilliams e1\i-- Refining Bands code: clean up bits file disk object if fail in openning band sfile.--March 19, 1982 converted to reticle maker version by Pier--fixed bug in StoreScanLine, 4/1/82\i-- Last Edited:  April 2, 1982  1:39 PM   By:  Pier e1-- created Reticle Band version.-- Last Edited:  April 14, 1982  2:00 PM   By:  GWilliams e1-- Added possibility of cutting the bandWidth in interests of core.(635)\3i65I-- Last Edited:  April 15, 1982  3:18 PM   By:  GWilliams e1(1792)-- Record bandwidth in PageG now.(635)\3i