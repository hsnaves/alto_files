-- File:  PressBandsOps.mesa: Routines for getting for a file at a printing server.e1(1792)\i10I13i-- GetBits is called by Press.mesa-- Last Edited:  April 16, 1982  2:34 PM   By:  GWilliams & Pier e1\i-- Normalizing Press Bands world.e1\i34IDIRECTORYe1AltoDefs USING [BytesPerWord, PageSize],l4269d3634e1k72(635)IODefs USING[WriteLine],l3634e1k72InlineDefs USING [BITOR, BITSHIFT--, COPY--],	--COPY[from, nwords, to]l4269d3634e1k72\33i10I3i24IMiscDefs USING[CallDebugger--, Zero--],l4269d3634e1k72\27i10IPressBandsDefs,	--only export to itl4269d3634e1k72\16i19IPressNetDefs USING [ddMgr, debuggerIfTfsError, EndReason, errorTfs, InitTrident],l4269d3634e1k72SegmentDefs USING[DataSegmentHandle, DefaultBase, DeleteDataSegment, NewDataSegment, SegmentAddress],l4269d3634e1k72TridentDefs USING [BadErrorRtn, dcReadLD, dcReadD, ddMgrPtr, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, eofDA, fillInDA, FP, PAGE, TfsActOnPages, TfsCloseDisk, tfsdskPtr, TfsInit, TfsOpenFile, TFSwordsPerPage];l4269d3634e1k72e1(1792)\bPressBandsOps: PROGRAMe1\b13BIMPORTS IODefs, InlineDefs, MiscDefs, PressNetDefs, SegmentDefs, TridentDefsl4904d3634e1k72(635)EXPORTS PressBandsDefs =l3633e1(1792)l3633d2998e1BEGIN OPEN AltoDefs, IODefs, InlineDefs, MiscDefs, PressNetDefs, SegmentDefs, TridentDefs;l3633d2998e1l4269d2999e1k72(635)--Tfs stuff	disk: tfsdskPtr _ NIL;	--this is a separate copy of the disk object.	bufferWordLen: CARDINAL = TFSwordsPerPage;	bufferByteLen: CARDINAL = BytesPerWord*bufferWordLen;l3008d2999e1k72\1i12I24i45I	pagesLength: CARDINAL = 4;	firstVda: CARDINAL _ 0;						--allways holds page 1 of the file	fp: FP;											--fp gets filled in by TfsOpenFile	filePtr: POINTER TO FP _ @fp;	tfsSeg: DataSegmentHandle _ NIL;	tfsBuff: POINTER TO ARRAY[0..TFSwordsPerPage) OF CARDINAL;	pages: ARRAY[0..pagesLength] OF PAGE;	chars: POINTER TO ARRAY [0..30) OF CHARACTER;--just for looking around in the tfsBuff	dAsLength: CARDINAL;	dAsBase: POINTER;			--this is modified after ea call on TfsActOnPages.	pageNum: CARDINAL;		--for writing into the bands buffer--Debugging SwitchesReadTfsPage: PUBLIC PROC[]=-- Reads the next page of the bands file into the Bands trident buffer{	endReason: EndReason _ illegalReason;	loopCtr: CARDINAL;						--this detects infinite loops in GetBits	maxTries: CARDINAL = 3;	nmChars: CARDINAL _ BytesPerWord*TFSwordsPerPage;	dAs: DESCRIPTOR FOR ARRAY OF PAGE _ DESCRIPTOR[dAsBase, dAsLength];	BEGIN		IF (dAs[pageNum] _ dAs[pageNum+1]) = eofDA			THEN	{endReason _ hitEOF; GOTO done;};				--by now the vda of the next page to write is in						IF (dAs[pageNum] = fillInDA)			THEN												--the vda is not valid				IF debuggerIfTfsError					THEN 	CallDebugger["disk address is fillInDA"L]					 ELSE	{endReason _ dANotFilled; GOTO done};							dAs[pageNum+1] _ fillInDA;				--reset the to-be-pagenum+1 vda		dAsLength _ dAsLength + 1;				--extend range of descriptor from new base		dAsBase _ dAsBase - 1;					--must reset base because the low-level disk routines write pageNum onto		pageNum _ pageNum + 1;					--     the disk label; and the vda is accessed from dAs using pageNum!		dAs _ DESCRIPTOR[dAsBase, dAsLength];l2999e1k72\58i34I22i32I1i1I30i1I92i1I85i41I22i1I20i51I21i35I1i23I2b11B17i70I67i40I244i48I58i20I169i29I35i40I32i70I32i68I--		TypeOutStatus[dAs, pageNum, charsInPage, TRUE];----the TRUE means "before ActOnPages"l4269d2999e1k72\i89Il2999e1k72	[]_ TfsActOnPages[disk, NIL, dAs, filePtr^, pageNum, pageNum, dcReadD, @nmChars, dcReadD, tfsBuff, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, TRUE, 0!		BadErrorRtn => {endReason _ tridentError; GOTO done;};];l4904d3634e1k72--		TypeOutStatus[dAs, pageNum, charsInPage, FALSE];----the FALSE means "after ActOnPages"		loopCtr _ 0;		UNTIL dAs[pageNum+1] # fillInDA		DO		--the Default TfsCleanupRtn didn't fill in the next DA, try again, but don't write data this time			IF (loopCtr _ loopCtr + 1) > maxTries				THEN 				IF debuggerIfTfsError					THEN	CallDebugger["disk address is fillInDA after some retries"L]				 	ELSE	{endReason _ dANotFilled; GOTO done};			IF dAs[pageNum+1] = eofDA THEN EXIT;l2999e1k72\i90I57i97I[]_TfsActOnPages[disk, NIL, dAs, filePtr^, pageNum, pageNum, dcReadLD, @nmChars, dcReadLD, tfsBuff, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, TRUE, 0!		BadErrorRtn => {endReason _ dANotFilled; GOTO done;};];l6174d4904e1k72		ENDLOOP;	EXITS	done=> l2999e1k72		SELECT endReason FROM			illegalReason =>					WriteLine["illegal End."L];			tridentError, hitEOF, dANotFilled =>	errorTfs[endReason];		ENDCASE;	END;l2999e1k72};--ReadTfsPageInitTfsBandsBuffer: PUBLIC PROC[] RETURNS[POINTER]={	IF tfsSeg # NIL THEN DeleteDataSegment[tfsSeg];	tfsSeg _ NewDataSegment[DefaultBase, (TFSwordsPerPage + PageSize-1)/PageSize];	tfsBuff _ SegmentAddress[tfsSeg];l2999e1k72\2i16bI18B35i1I	chars _ LOOPHOLE [tfsBuff];--for snooping around during debugging	pages _ [fillInDA, fillInDA, fillInDA, fillInDA, fillInDA];	dAsLength _ pagesLength;	--this varies with the bits file writing	--in next line, we are assuming that Press.bits is contiguous!!!!	pages[1] _ firstVda;		--this will be accessed as dAs[pageNum+1] to set up dAs[pageNum]	dAsBase _ @pages[0];	pageNum _ 0;	--this gets incremented before using	RETURN [tfsBuff];};--InitTfsBandsBufferReleaseTfsBandsBuffer: PUBLIC PROC[]={	DeleteDataSegment[tfsSeg];	tfsSeg _ NIL;};--ReleaseTfsBandsBufferCloseBandsFile: PUBLIC PROC[]={	IF disk # NIL THEN 		{disk _ TfsCloseDisk[disk, TRUE]};	--the TRUE is for don'tDelete ddMgr, that's done by caller};--CloseBandsFileOpenPressBands: PUBLIC PROC[]=--If it can't find the file, it makes sure there is no disk object for it. Doesn't touch the global ddMgrBEGIN	fileSys: CARDINAL _ 1;					--TP0:sys 1--N.B. that ddMgr is assumed to have been inited by caller!! (In our case, by PressNetListener)	disk _ InitTrident[ddMgr, disk];			--loads disk object	IF disk = NIL THEN ERROR errorTfs[noTrident];	[, firstVda,] _ TfsOpenFile[disk, "BANDS.", read, filePtr];--must fool Open with read. Only other option is create.	IF firstVda=0 AND disk.tfskd.model = 80 THEN  --"not found" if not on 1st file system.										GOTO errorXit;	WHILE firstVda = 0 AND fileSys < 23 		--check all filesystems on a T300	 DO									--drives 0-7 and 3 filesystems/drive		IF disk # NIL THEN			disk_LOOPHOLE[TfsCloseDisk[disk, TRUE]];		--keep ddMgr, and make disk NIL 		disk _ TfsInit[TRUE, BITOR[BITSHIFT[(fileSys MOD 3), 8], (fileSys/3)], ddMgr,];		fileSys _ fileSys + 1;		IF disk = NIL THEN LOOP;		[, firstVda, ] _ TfsOpenFile[disk, "Press.bits.", read, filePtr];	ENDLOOP;	IF firstVda = 0 THEN --get here only when not found on T300		 GOTO errorXit;EXITSerrorXit =>	{IF disk # NIL THEN disk _ TfsCloseDisk[disk, TRUE];--keep the ddMgr around	 ERROR errorTfs[cantFindFile]};END;--OpenPressBandsEND. -- PressNetListener.mesal2999e1k72(0,3648)(1,4269)(2,4904)\28i40I86i40I2i66I23i64I37i36I22i21bI22B62i24bI16B76i58I3i18bI14B17i105I35i11I2i96I36i19I111i54I46i48I19i1I40i33I16i34I65i33I237i38I90i26I35i18I5i25I-- Last Edited:  March 4, 1982  2:38 PM   By:  GWilliams e1(1792)\i-- Created new module for Cedar bands hacking on the Alto.(635)\i-- Last Edited:  March 19, 1982  4:06 PM   By:  GWilliams e1(1792)\i-- Cleaned up the error exits some (vis-a-vis closing disk object and not the ddMgr).(635)\i