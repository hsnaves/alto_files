-- File:  PressNetListener.mesa: Routines for getting for a file at a printing server.e1(1792)\i-- GetBits is called by Press.mesa-- Last Edited:  March 22, 1982  4:01 PM   By:  GWilliams e1\i-- Adding Stream mechanism for transporting data.e1\i50IDIRECTORYe1AltoDefs USING [BytesPerWord, PageSize],l4269d3634e1k72(635)AltoRam USING [CantFindFile, FileLooksCrufty],l4269d3634e1k72IODefs USING[CR, SP, WriteChar, WriteDecimal, WriteOctal, WriteLine, WriteString],l3634e1k72InlineDefs USING [BITOR, BITSHIFT, LongCOPY],	--LongCOPY[from, nwords, to]l4269d3634e1k72\46i28IMesaBands USING [BandDevice, ShowBands, ShowBandsInit],l4269d3634e1k72MiscDefs USING[CallDebugger, Zero],l4269d3634e1k72PressDefs USING [PageG, PressPassword, RamBoot, uCodeLoaded],l4269d3634e1k72PressNetDefs USING [attributesCode, EndReason, imageCode, PageAttributes],l4269d3634e1k72PressBandsDefs USING [CloseBandsFile, OpenPressBands, InitTfsBandsBuffer, ReleaseTfsBandsBuffer],l4269d3634e1k72PupDefs USING [GetPupAddress, PupPackageDestroy, PupPackageMake, veryLongWait],l4269d3634e1k72PupStream USING [AppendPupAddress, CreatePupByteStreamListener, DestroyPupListener, PupListener, RejectThisRequest, StreamClosing],l4269d3634e1k72\97t10 15t0PupTypes USING[PupAddress, PupSocketID],l4269d3634e1k72SegmentDefs USING[DataSegmentHandle, DefaultBase, DeleteDataSegment, NewDataSegment, SegmentAddress],l4269d3634e1k72Stream USING [Block, CompletionCode, EndOfStream, GetBlock, Handle, PutBlock, SendNow, SetInputOptions, SubSequenceType ],l4269d3634e1k72TridentDefs USING [BadErrorRtn, dcReadLD, dcWriteD, ddMgrPtr, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, eofDA, fillInDA, FP, PAGE, TfsActOnPages, TfsCloseDisk, TfsCreateDDmgr, tfsdskPtr, TfsInit, TfsOpenFile, TFSwordsPerPage];l4269d3634e1k72e1(1792)\bPressNetListener: MONITORe1\b16BIMPORTS AltoRam, IODefs, InlineDefs, MesaBands, MiscDefs, PressDefs, PressBandsDefs, PupDefs, PupStream, SegmentDefs, Stream, TridentDefsl4904d3634e1k72(635)EXPORTS PressBandsDefs, PressNetDefs =l3633e1(1792)l3633d2998e1BEGIN OPEN AltoDefs, AltoRam, IODefs, InlineDefs, MiscDefs, PressDefs, PressBandsDefs, PressNetDefs, PupDefs, PupStream, PupTypes, SegmentDefs, Stream, TridentDefs;l3633d2998e1l4269d2999e1k72(635)	TerminationReason: TYPE = {errorTermination, fileDoneTermination, pageDoneTermination, nullTerminationReason};l4278d2999e1k72--Press Stuff	bandWidth: CARDINAL = 16;	FirstPage: TYPE = MACHINE DEPENDENT RECORD	[	nPages: CARDINAL _ 1,		pageGSize: CARDINAL _ SIZE[PageG],		printerMode: CARDINAL,	--3=portrait, 8=Landscape		password: CARDINAL _ PressPassword,		pageGs: ARRAY[0..92) OF PageG	--enough to fit into a Trident Page	];	scanSeg: DataSegmentHandle _ NIL;	scanLength: CARDINAL;	wordAddrInTfsBuffer: CARDINAL;	scanInBand: CARDINAL;--net stuff	listener: PupListener _ NIL; 	connectionOpen: BOOLEAN _ FALSE;	gotAJob: BOOLEAN _ FALSE;	hostAddress: PupAddress;	pupPtr: POINTER TO PupAddress _ @hostAddress;	senderAddress: PupAddress;	receiverH: Stream.Handle;	pupPkgExtant: BOOLEAN _ FALSE;--	bufferPoolSize: CARDINAL _ 15;--	bufferSize: CARDINAL _ 266;--Process StuffconnectionC: CONDITION;--Tfs stuff	bandDiskBuffer: POINTER;	ddMgr: PUBLIC ddMgrPtr _ NIL;	disk: tfsdskPtr _ NIL;	bufferWordLen: CARDINAL = TFSwordsPerPage;	bufferByteLen: CARDINAL = BytesPerWord*bufferWordLen;l3008d2999e1k72\i15I158i28I68i35I121i10I205f1 7f0 40i82I23i1I1i12I	pagesLength: CARDINAL = 4;	firstVda: CARDINAL _ 0;						--allways holds page 1 of the file	fp: FP;											--fp gets filled in by TfsOpenFile	filePtr: POINTER TO FP _ @fp;	tfsSeg: DataSegmentHandle _ NIL;	tfsBuff: POINTER TO ARRAY[0..TFSwordsPerPage) OF CARDINAL;	pages: ARRAY[0..pagesLength] OF PAGE;	dAsLength: CARDINAL;	dAsBase: POINTER;			--this is modified after ea call on TfsActOnPages.	pageNum: CARDINAL;--Debugging Switches	fileLengthReport: BOOLEAN _ TRUE;	--print out length of received file in pages	dasMonitor: BOOLEAN _ FALSE;--for debugging tfs file handler.	debuggerIfTfsError: PUBLIC BOOLEAN _ TRUE;	checkTermination: PUBLIC BOOLEAN _ TRUE;--Signals & ErrorsCommErr: TYPE = {alreadyHaveJob, nullComErr, endReceiving, noisyChannel, protocolError, illegalEnd, notReceiving, alreadyReceiving};errorComm: ERROR[e: CommErr, wordsTransferred: CARDINAL _ 0, s: STRING _ NIL] = CODE;errorTfs: PUBLIC ERROR[e: EndReason] = CODE;GetBits: PUBLIC PROC[] RETURNS[okToProceed: BOOLEAN _ FALSE]=--Raises no signals or errorsBEGIN	pa: PageAttributes;	endReason: EndReason _ illegalReason;	iii: CARDINAL;	--used in data fetching loop	inCoreAddress: POINTER TO ARRAY OF WORD;	tooMuchData: BOOLEAN _ FALSE;	--set when sender sends too much data	receivedFile: BOOLEAN _ FALSE;	scanLineLength: CARDINAL;			--copy of scanLength	wordsInBuff: CARDINAL;BEGIN	IF ~FirstPageCheck[] THEN RETURN[FALSE];	WHILE ~receivedFile	DOl2999e1k72\58i34I22i32I1i1I30i1I92i1I61i1I20i51I20i22I37i42I32i31I87i20bI7B126b9B77b10B37b7B55i30I82i28I74i39I60i20I	OpenPressBits[filePtr! errorTfs => {SELECT e FROM  noTrident => WriteLine["Trident not up"L];												 cantFindFile => WriteLine["Can't find Press.bits"L];												ENDCASE; GOTO getOut}--no state to clean up--];	pa _ GetAJob[! errorComm => IF e = alreadyReceiving THEN {PupPackageDestroy[]; GOTO getOut}];	InitTfsBuffer[];	inCoreAddress _ InitScanBuffer[pa];	--get enough space for a scan line; must call after InitTfsBuffer	scanLineLength _ scanLength;	--scan Length is valid now.l3634e1k72\194i24I3i1I152i64I30i28I	BEGIN ENABLE BEGINl3634e1k72		errorComm => 			{SELECT e FROM				noisyChannel => {WriteLine["Noisy Channel, aborting transfer"L];								AbortReceiving["Channel too noisy, aborting transfer"L]};				endReceiving => WriteLine["Transfer aborted, not enough data received"L];				ENDCASE;			GOTO incompleteXFer};		errorTfs => SELECT e FROM tridentError, hitEOF, dANotFilled => {endReason _ e; GOTO done}; ENDCASE;		END;--of catch series	FOR  iii IN [0..pa.lastScan-pa.firstScan]		DO			wordsInBuff _ GetBuffer[inCoreAddress, 1];		--check header word			IF inCoreAddress[0] # imageCode THEN					{WriteLine["Buffer doesn't contain image data"L]; GOTO incompleteXFer};				wordsInBuff _ GetBuffer[inCoreAddress, scanLineLength];	--get scan line			IF wordsInBuff = 0 THEN {endReason _ emptyBuffReason; GOTO done};--blow up			StoreScanLine[inCoreAddress];				--buffers data and writes to disk.		ENDLOOP;	EXITS	incompleteXFer =>			{IF checkTermination THEN				CallDebugger["File transfer trouble"];			CloseServerConnection[];			disk_TfsCloseDisk[disk, FALSE];--delete the ddMgr too			ddMgr _ NIL;			ReleaseScanBuffer[TRUE, inCoreAddress, pa];			ReleaseTfsBuffer[];			LOOP};		--restart @ WHILE ~ receivedFilel4269e1k72\387i2I4i19I95i19I181i13I69i9I37i34I173i22I98i32I	END;l3634e1k72--now loop asking for data, waiting for an EFTPEndReceiving	BEGIN ENABLE errorComm => IF e = endReceiving THEN GOTO closeConn;		DO wordsInBuff _ GetBuffer[inCoreAddress, scanLineLength]; tooMuchData _ TRUE;		ENDLOOP;	EXITS	closeConn => NULL;	END;	CloseServerConnection[];	--turn off net driver	ReleaseScanBuffer[FALSE, inCoreAddress, pa];	--write out blank scan lines if last band is not full & free storage	WritePageGPage[pa!						--get out if error		errorTfs => IF (e = tridentError) 			THEN {WriteLine["Transfer Complete, but"L]; endReason _ tridentError; GOTO done}];	ReleaseTfsBuffer[];	disk_TfsCloseDisk[disk, FALSE];	ddMgr _ NIL;	receivedFile _ TRUE;l3634e1k72\1i61I158i2I31i2I26i21I47i68I1i1I21i21I	ENDLOOP;	okToProceed _ TRUE;EXITSgetOut=> NULL;done=> l2999e1k72\10i1I20i1I	{	ReleaseScanBuffer[FALSE, inCoreAddress, pa];	--write out blank scan lines if last band is not full & free storage	ReleaseTfsBuffer[];	SELECT endReason FROM		emptyBuffReason=>	WriteLine["Empty Page: error!"L];		illegalReason =>	WriteLine["illegal End."L];		tridentError =>	{WriteLine["Trident error"L];				AbortReceiving["Trident error"L];};		hitEOF => 	{WriteLine["Ran into EOF on write"L];				AbortReceiving["Trident ran into EOF on file write"L];};		dANotFilled =>	{WriteLine["Trident software trouble -- bad DA multiple times"L];				AbortReceiving["Trident software trouble -- bad DA"L];};	ENDCASE;l2999e1k72(0,3648)(1,4269)(2,7867)\49i68I	CloseServerConnection[];		--turn off net if on.l2999e1k72(1,7232)(2,65535)\30i19I	SELECT endReason FROM	   tridentError => NULL;	   emptyBuffReason, hitEOF, dANotFilled => {IF disk # NIL THEN disk _ TfsCloseDisk[disk, FALSE]; ddMgr _ NIL};	ENDCASE;	};l2999e1k72END;l3634d2999e1k72(635)	IF checkTermination THEN		IF ~okToProceed THEN CallDebugger["Exiting with error from GetBits"L];END;--of GetBitsAbortReceiving: PROC[s: STRING]=BEGIN	IF ~connectionOpen THEN RETURN;	AbortReceivingLocked[s];	END;AbortReceivingLocked: ENTRY PROC[s: STRING]={	startIndex: CARDINAL _ 0;	stopIndexPlusOne: CARDINAL _ s.length;		block: Stream.Block _ [@s.text, startIndex, stopIndexPlusOne];	Stream.PutBlock[receiverH, block, FALSE!		EndOfStream => {CallDebugger["Got end of stream on put after end of stream"L];		CONTINUE}];	SendNow[receiverH];};--AbortReceivingLockedAwaitConnection: ENTRY PROC[]={	WHILE ~connectionOpen DO WAIT connectionC ENDLOOP;};FinishReceiving: ENTRY PROC[]={		 receiverH.delete[receiverH];		 connectionOpen _ FALSE;	--connectionOpen=FALSE enables new clients};--FinishReceivingl2999d2364e1k72\103i12bI1B1b14B92b20B104f1 7f0 50f1 7f0 152i22I1b16B72b15B77i42I4i17I1b1BGetAJob: PROC[] RETURNS [pa: PageAttributes]={	typedMessage: BOOLEAN _ FALSE;	getAJobEndReason: EndReason _ illegalReason;	code: CARDINAL;	wordsReturned: CARDINAL;	pupAddressString: STRING _ [30];	IF gotAJob THEN ERROR errorComm [alreadyHaveJob, , ];	IF ~connectionOpen THEN		{IF ~pupPkgExtant THEN			{PupPackageMake[];			 pupPkgExtant _ TRUE;			 GetPupAddress[pupPtr, "ME"];		--don't use the normal socket for debugging!			 pupPtr.socket _ PupSocketID[1, 25B];	--[0, 20B] is the normal printer socket			--only spawn one listener per entry to this proc.			listener _ CreatePupByteStreamListener[pupPtr.socket, PrintRequest, veryLongWait, RfcFilter];			};		};	WHILE ~gotAJob DO--we don't have a connection here, just a listener.	WriteLine["Listening for connection"L];	AwaitConnection[];	WriteString["Connection open to "L];	AppendPupAddress[pupAddressString, senderAddress];	WriteLine[pupAddressString];	typedMessage _ FALSE;	[wordsReturned] _ GetBuffer[@code, 1!		errorComm =>		SELECT e FROM			noisyChannel, protocolError, endReceiving=>				{FinishReceiving[]; connectionOpen _ FALSE; LOOP};			ENDCASE;];	--get code to see if it is a Page Attributes code	IF code # attributesCode THEN		{AbortReceiving["I Expect Page Attributes first"];		 WriteLine["Connection Refused, protocol error."L];		 FinishReceiving[];		 typedMessage _ FALSE;	--connectionOpen=FALSE enables new clients		 LOOP};	--get rid of this customer & type init message--the other process is really getting the stream data now.	wordsReturned _ GetBuffer[@pa, SIZE[PageAttributes]!		errorComm =>		SELECT e FROM			noisyChannel, protocolError, endReceiving=>				{FinishReceiving[]; LOOP};			ENDCASE;];	gotAJob _ TRUE;	ENDLOOP;};--GetAJobPrintRequest: ENTRY PROC[s: Stream.Handle, addr: PupAddress]={	receiverH _ s;	senderAddress _ addr;	SetInputOptions[s, [FALSE, FALSE, FALSE, FALSE, TRUE]];--signal on EndOfStream	NOTIFY connectionC;};--PrintRequestRfcFilter: PROC[pupAdr: PupAddress]={	IF connectionOpen THEN RejectThisRequest["Busy with another client, try later"L];	connectionOpen _ TRUE;};--RfcFilterFirstPageCheck: PROC [] RETURNS[goAhead: BOOLEAN _ TRUE]={	IF SIZE[FirstPage] > TFSwordsPerPage THEN			{WriteLine["First page description exceeds Trident Page Length"];			 RETURN[FALSE]};};--FirstPageCheckl2999e1k72\b9B381i45I40i40I4i49I128i52I392i49I187i42I11i46I2i59I207i9I1b14B15f1 7f0 124i23I24i15bI11B137i11bI15B179iGetBuffer: ENTRY PROC[buffer: POINTER, len: CARDINAL] RETURNS [wordsInBufCt: CARDINAL _ 0]=l3634d2999e1k72\b9B--copy from net Stream to buffer len amount of wordsBEGIN	getABuffEndReason: EndReason _ illegalReason;	why: CompletionCode;	sst: SubSequenceType;	bufferPos: POINTER _ buffer;	byteLen: CARDINAL _ len*2;	block: Stream.Block _ [buffer, 0, byteLen];	bytesGotten: CARDINAL _ 0;BEGIN	UNTIL block.startIndex = byteLen	DO 		[bytesGotten, why, sst] _ Stream.GetBlock[receiverH, block!		EndOfStream => {getABuffEndReason _ doneReason; GOTO done};		StreamClosing => IF why=remoteClose THEN {getABuffEndReason _ doneReason; GOTO done}];		block.startIndex _ block.startIndex + bytesGotten;	ENDLOOP;	RETURN[BITSHIFT[block.startIndex, -1]];--divide by bytes/wordEXITS	done=>l2999e1\i53I164f1 7f0 133f1 7f0 283i22I	{	--CloseServerConnection[]; - - this is done at the catch phrase higher up.		wordsInBufCt _ BITSHIFT[block.startIndex + bytesGotten, -1];		SELECT getABuffEndReason FROM			doneReason =>			RETURN WITH ERROR errorComm[endReceiving, wordsInBufCt, NIL];--not necessarily an error			errorTroubleReceiving =>	RETURN WITH ERROR errorComm[noisyChannel, wordsInBufCt, NIL];			errorNotReceiving =>		RETURN WITH ERROR errorComm[notReceiving, 0, NIL];			illegalReason =>			RETURN WITH ERROR errorComm[illegalEnd, wordsInBufCt, NIL];		ENDCASE;	};END;END;--of GetBufferl2999e1k72\5i73I176i26I273i14IGetBitsFromBands: PUBLIC PROC[] RETURNS[okToProceed: BOOLEAN _ FALSE]=--Raises no signals or errorsBEGIN	pa: PageAttributes;	endReason: EndReason _ illegalReason;	iii: CARDINAL _ 0;	--used in data fetching loop	inCoreAddress: POINTER TO ARRAY OF WORD;	tooMuchData: BOOLEAN _ FALSE;	--set when sender sends too much data	receivedFile: BOOLEAN _ FALSE;BEGIN--this routine destroys the ddMgr if it fails	OpenPressBits[filePtr! errorTfs => {SELECT e FROM  noTrident => WriteLine["Trident not up"L];												 cantFindFile => WriteLine["Can't find Press.bits"L];												 ENDCASE; GOTO getOut --no state to clean up--}];		OpenPressBands[!  errorTfs => {SELECT e FROM 	noTrident => WriteLine["Trident not up"L];												 cantFindFile =>													{WriteLine["Can't find PBand.0"L];													 disk _ TfsCloseDisk[disk, FALSE]; --get rid of Bits file disk object													ddMgr _ NIL};				  --and the community ddMgr												ENDCASE; GOTO getOut}];	bandDiskBuffer _ InitTfsBandsBuffer[];	--init the input buffer for Press.Bands	pa _ MesaBands.ShowBandsInit[hornet];	InitTfsBuffer[];	--init the output buffer to Press.bits	inCoreAddress _ InitScanBuffer[pa];	--get enough space for a scan line; must call after InitTfsBufferl2999e1k72\3b16B55i30I87i28I74i39I38i45I195i25I220i35I30i28I77i40I7f1 10f0 41i38I40i63I	MesaBands.ShowBands[];	ReleaseScanBuffer[FALSE, inCoreAddress, pa];	--write out blank scan lines if last band is not full & free storage	WritePageGPage[pa!						--get out if error		errorTfs => IF (e = tridentError) 			THEN {WriteLine["Transfer Complete, but"L]; endReason _ tridentError; GOTO done}];	ReleaseTfsBuffer[];	ReleaseTfsBandsBuffer[];	CloseBandsFile[];			--must call this before TfsCloseDisk[,FALSE] as it needs a disk descriptor	disk_TfsCloseDisk[disk, FALSE];	ddMgr _ NIL;	okToProceed _ TRUE;EXITSgetOut=> NULL;done=> l2999e1k72\1f1 10f0 13i1I46i68I1i2I21i21I171i1I20i74I69i1I	{	ReleaseScanBuffer[FALSE, inCoreAddress, pa];	--write out blank scan lines if last band is not full & free storage	ReleaseTfsBandsBuffer[];	ReleaseTfsBuffer[];	SELECT endReason FROM		emptyBuffReason=>	WriteLine["Empty Page: error!"L];		illegalReason =>	WriteLine["illegal End."L];		tridentError =>	WriteLine["Trident error"L];		hitEOF => 	WriteLine["Ran into EOF on write"L];		dANotFilled =>	WriteLine["Trident software trouble -- bad DA multiple times"L];	ENDCASE;l2999e1k72(0,3648)(1,4269)(2,7867)\49i68I	SELECT endReason FROM	   tridentError => NULL;	   emptyBuffReason, hitEOF, dANotFilled => { CloseBandsFile[]; disk _ TfsCloseDisk[disk, FALSE]; ddMgr _ NIL};	ENDCASE;	};l2999e1k72(1,7232)(2,65535)END;l3634d2999e1k72(635)	IF checkTermination THEN		IF ~okToProceed THEN CallDebugger["Exiting with error from GetBits"L];END;--of GetBitsFromBandsStoreScanLine: PUBLIC PROC [p: LONG POINTER]=--Put scan line into Press.bits. Breaks scan line up if it overflows a Trident Page. Also pads the band out to 1K boundary.--Now, if we overflow the Tfsbuffer, we automatically write out the full page and add remainder of scan to newly emptied buffer. If that was the last scan line of the buffer, we write out the partial page regardless whether we just flushed the full buffer since we're padding the trident page at the end of a band. Hence the test for scanInBand at end.{	wordsLeft: CARDINAL;	wordsLeft _ (TFSwordsPerPage-wordAddrInTfsBuffer);	LongCOPY[p,  MIN[wordsLeft, scanLength], tfsBuff + wordAddrInTfsBuffer];	IF wordsLeft < scanLength	--wordsLeft can be zero		THEN			{WriteTfsPage[];			 LongCOPY[p+wordsLeft, wordAddrInTfsBuffer _ (scanLength-wordsLeft), tfsBuff];			}		ELSE wordAddrInTfsBuffer _ wordAddrInTfsBuffer + scanLength;--can = TFSwordsPerPage	IF (scanInBand _ scanInBand + 1) = bandWidth THEN		{WriteTfsPage[];		--reset wordAddrInTfsBuffer to 0 to avoid an empty page next go around		wordAddrInTfsBuffer _ 0;		scanInBand _ 0;		};};--StoreScanLineWriteTfsPage: PROC[]={	endReason: EndReason _ illegalReason;	loopCtr: CARDINAL;						--this detects infinite loops in GetBits	maxTries: CARDINAL = 3;	nmChars: CARDINAL _ BytesPerWord*TFSwordsPerPage;	dAs: DESCRIPTOR FOR ARRAY OF PAGE _ DESCRIPTOR[dAsBase, dAsLength];	BEGIN		IF (dAs[pageNum] _ dAs[pageNum+1]) = eofDA			THEN	{endReason _ hitEOF; GOTO done;};				--by now the vda of the next page to write is in						IF (dAs[pageNum] = fillInDA)			THEN												--the vda is not valid				IF debuggerIfTfsError					THEN 	CallDebugger["disk address is fillInDA"L]					 ELSE	{endReason _ dANotFilled; GOTO done};							dAs[pageNum+1] _ fillInDA;				--reset the to-be-pagenum+1 vda		dAsLength _ dAsLength + 1;				--extend range of descriptor from new base		dAsBase _ dAsBase - 1;					--must reset base because the low-level disk routines write pageNum onto		pageNum _ pageNum + 1;					--     the disk label; and the vda is accessed from dAs using pageNum!		dAs _ DESCRIPTOR[dAsBase, dAsLength];l2999e1k72\103i21bI1Bi1bI14B32i123I1i352I179i23I177i8I87i73I52i16bI12B75i40I244i48I58i20I169i29I35i40I32i70I32i68I--		TypeOutStatus[dAs, pageNum, charsInPage, TRUE];----the TRUE means "before ActOnPages"l4269d2999e1k72\i89Il2999e1k72	[]_ TfsActOnPages[disk, NIL, dAs, filePtr^, pageNum, pageNum, dcWriteD, @nmChars, dcWriteD, tfsBuff, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, TRUE, 0!		BadErrorRtn => {endReason _ tridentError; GOTO done;};];l4904d3634e1k72--		TypeOutStatus[dAs, pageNum, charsInPage, FALSE];----the FALSE means "after ActOnPages"		loopCtr _ 0;		UNTIL dAs[pageNum+1] # fillInDA		DO		--the Default TfsCleanupRtn didn't fill in the next DA, try again, but don't write data this time			IF (loopCtr _ loopCtr + 1) > maxTries				THEN 				IF debuggerIfTfsError					THEN	CallDebugger["disk address is fillInDA after some retries"L]				 	ELSE	{endReason _ dANotFilled; GOTO done};			IF dAs[pageNum+1] = eofDA THEN EXIT;l2999e1k72\i90I57i97I[]_TfsActOnPages[disk, NIL, dAs, filePtr^, pageNum, pageNum, dcReadLD, @nmChars, dcReadLD, tfsBuff, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, TRUE, 0!		BadErrorRtn => {endReason _ dANotFilled; GOTO done;};];l6174d4904e1k72		ENDLOOP;	EXITS	done=> l2999e1k72		SELECT endReason FROM			illegalReason =>					WriteLine["illegal End."L];			tridentError, hitEOF, dANotFilled =>	errorTfs[endReason];		ENDCASE;	END;l2999e1k72};--WriteTfsPageInitTrident: PUBLIC PROC[ddMgrPt: ddMgrPtr _ NIL, iDisk: tfsdskPtr] RETURNS [disk: tfsdskPtr]=BEGIN--load microcode	IF ~uCodeLoaded THEN		{RamBoot["MesaSlotMc.br"! CantFindFile => GOTO noUcode;							FileLooksCrufty  =>GOTO badUcode];	 	 uCodeLoaded _ TRUE;};	IF iDisk # NIL THEN disk _ TfsCloseDisk[iDisk, TRUE];	disk _ TfsInit[TRUE,, ddMgrPt,];					--initmode=TRUE, drive, ddMgr, freshDisk=FALSE EXITS	noUcode => WriteLine["Can't find file MesaSlotMc.br."L];	badUcode => WriteLine["Microcode file ""MesaSlotMc.br"" is malformed."L];END;--of InitTridentInitTfsBuffer: PROC[]={	IF tfsSeg # NIL THEN DeleteDataSegment[tfsSeg];	tfsSeg _ NewDataSegment[DefaultBase, (TFSwordsPerPage + PageSize-1)/PageSize];	tfsBuff _ SegmentAddress[tfsSeg];l2999e1k72\2i16bI11B93i15I240i48I147i14I1b14B11i1I	pages _ [fillInDA, fillInDA, fillInDA, fillInDA, fillInDA];	dAsLength _ pagesLength;	--this varies with the bits file writing	--in next line, we are assuming that Press.bits is contiguous!!!!	pages[2] _ firstVda + 1;		--this will be accessed as dAs[pageNum+1] to set up dAs[pageNum]	dAsBase _ @pages[0];	pageNum _ 1;	--this gets incremented before using};--InitTfsBufferGetTfsBandsBuffer: PUBLIC PROC[] RETURNS[POINTER]={	RETURN[bandDiskBuffer]};	--GetTfsBandsBufferReleaseTfsBuffer: PROC[]={	DeleteDataSegment[tfsSeg];	tfsSeg _ NIL;};--ReleaseTfsBufferInitScanBuffer: PROC[pa: PageAttributes] RETURNS [coreAddress: POINTER]={	padding: CARDINAL;	IF scanSeg # NIL THEN DeleteDataSegment[scanSeg];	scanSeg _ NewDataSegment[DefaultBase, (pa.bitWc + PageSize-1)/PageSize];	coreAddress _ SegmentAddress[scanSeg];l2999e1k72\87i40I2i66I27i64I37i36I3i16bI20B59i19I2b16B55i19bI16B60i1I	scanInBand _ wordAddrInTfsBuffer _ 0;		--init the scan line # we're on	scanLength _ pa.bitWc;	--will never need more than bandWidth scans	IF (padding _ pa.firstScan MOD bandWidth) > 0 THEN		{Zero[coreAddress, pa.bitWc];		FOR i: CARDINAL IN [0..padding)			DO StoreScanLine[coreAddress]; ENDLOOP;		};};--InitScanBufferReleaseScanBuffer: PROC[aborting: BOOLEAN _ FALSE, address: POINTER, pa: PageAttributes]=--Pads the first and last bands with blank scan lines if, for instance, firstScan is not = to a (multiple of bandWidth + 1)BEGIN	padding: CARDINAL;	IF ~aborting THEN		{padding _ pa.lastScan MOD bandWidth;		IF padding # bandWidth-1 THEN			{Zero[address, pa.bitWc];			FOR i: CARDINAL IN [1..bandWidth-padding)	--output bandWidth-padding-1 lines			DO	StoreScanLine[address];			ENDLOOP};};	DeleteDataSegment[scanSeg];	scanSeg _ NIL;END;--ReleaseScanBufferWritePageGPage: PROC[pa: PageAttributes]=--can raise errorTfs[tridentError]{	pageBuf: ARRAY[0..TFSwordsPerPage) OF WORD; --Plug in PageG info and write this buffer to disk	firstPage: POINTER TO FirstPage _ LOOPHOLE[@pageBuf[0]];	nmChars: CARDINAL _ BytesPerWord*TFSwordsPerPage;	dAs: DESCRIPTOR FOR ARRAY OF PAGE _ DESCRIPTOR[@pages[1], dAsLength];	dAs[1] _ firstVda;	Zero [@pageBuf[0], TFSwordsPerPage];	firstPage.nPages _ 1;	firstPage.pageGSize _ SIZE[PageG];	firstPage.printerMode _ (IF pa.scanDirection = portrait THEN 3 ELSE 8);	firstPage.password _ PressPassword;	firstPage.pageGs[0].FirstBand _ pa.firstScan/bandWidth;	firstPage.pageGs[0].LastBand _ pa.lastScan/bandWidth;	firstPage.pageGs[0].BitMargin _ pa.margin;	firstPage.pageGs[0].BitWc _ pa.bitWc;	firstPage.pageGs[0].BitPage _ 1;	--i.e., first page after the firstPge	firstPage.pageGs[0].PageNumber _ 1;	--i.e., from first page of Press file	[]_ TfsActOnPages[disk, NIL, dAs, filePtr^, 1, 1, dcWriteD, @nmChars, dcWriteD, @pageBuf[0], DefaultTfsCleanupRtn, DefaultTfsErrorRtn, TRUE, 0!	BadErrorRtn => GOTO done];l2999e1k72\41i31I27i44I169i17bI18B73i124I192i34I95i20bI2B1b14B28i35I48i49I639i37I38i37IEXITSdone => errorTfs[tridentError];};--WritePageGPageOpenPressBits: PROC[filePtr: POINTER TO FP]=--This routine deletes the global ddMgr if it can't find Press.bits on the Trident. It also deletes the disk object.--Thus, this routine must be called before calling OpenPressBands, as that routine assumes this routine has already succeeded.BEGIN	fileSys: CARDINAL _ 1;						--TP0:sys 1	IF ddMgr = NIL THEN ddMgr _ TfsCreateDDmgr[];	disk _ InitTrident[ddMgr, disk];									--loads disk object	IF disk = NIL THEN ERROR errorTfs[noTrident];	[, firstVda,] _ TfsOpenFile[disk, "Press.bits.", read, filePtr];--must fool Open with read. Only other option is create.	IF firstVda=0 AND disk.tfskd.model = 80 THEN  --"not found" if not on 1st file system.			GOTO errorXit;	WHILE firstVda = 0 AND fileSys < 23 						--check all filesystems on a T300	 DO													--drives 0-7 and 3 filesystems/drive		IF disk # NIL THEN			disk_LOOPHOLE[TfsCloseDisk[disk, TRUE]];		--keep ddMgr, and make disk NIL 		disk _ TfsInit[TRUE, BITOR[BITSHIFT[(fileSys MOD 3), 8], (fileSys/3)], ddMgr,];		fileSys _ fileSys + 1;		IF disk = NIL THEN LOOP;		[, firstVda, ] _ TfsOpenFile[disk, "Press.bits.", read, filePtr];	ENDLOOP;	IF firstVda = 0 THEN 			GOTO errorXit;	--not anywhere on T300EXITSerrorXit =>	{IF disk # NIL THEN disk _ TfsCloseDisk[disk, FALSE];				ddMgr _ NIL;				ERROR errorTfs[cantFindFile]};END;--OpenPressBitsl2999e1k72\42i18I2b13B32i244I35i11I92i19I117i54I46i46I14i1I44i34I20i34I65i33I256i22I130i17ICloseServerConnection: PROC[]={	IF ~gotAJob THEN GOTO done;	receiverH.delete[receiverH];		--this hopefully destroys the PrintRequest that was detached by the pupListener.	DestroyPupListener[listener];	listener _ NIL;	PupPackageDestroy[];	gotAJob _ pupPkgExtant _ connectionOpen _ FALSE;EXITS  done => NULL;};--CloseServerConnectionl2999e1k72\b21B72i81I146i2I21iTypeOutStatus: PROC[dAs: DESCRIPTOR FOR ARRAY OF PAGE, pageNum, charsInPage: CARDINAL, beforeActOnPages: BOOLEAN _ TRUE]={--for debugging	i: CARDINAL;--debugging variable	IF ~dasMonitor THEN RETURN;	IF beforeActOnPages		THEN WriteLine["Before ActOnPages"L]		ELSE WriteLine["After ActOnPages"L];	WriteString["page number: "L];	WriteDecimal[pageNum]; WriteChar[CR];	IF beforeActOnPages		THEN {WriteString["Before ActOnPages -- chars received from GetAPage: "L];				WriteDecimal[charsInPage]; WriteChar[CR];};	WriteLine["dAs[0]..dAs[dAsLength] (length changes with page#)"];	FOR i IN [0..dAsLength) DO		WriteOctal[dAs[i]]; WriteChar[SP]; WriteChar [SP]; ENDLOOP;	WriteChar[CR]; WriteChar[CR];};--TypeOutStatus--initialization (for debugging only)--filePtr _ @fp;  Use this if Mesa doesn't allow startup assignmentEND. -- PressNetListener.mesal2999e1k72(0,3648)(1,4269)(2,8064)\b14B141i18I539i13I2i39I73i25I-- Last Edited:  October 27, 1981  4:35 PM   By:  GWilliams e1(1792)\i-- added code to try for the next vda again if not filled by TfsActOnPages the first -- Last Edited:  October 27, 1981  3:12 PM   By:  GWilliams e1\i-- added debuggerIfTfsError-- Last Edited:  October 26, 1981  2:38 PM   By:  GWilliams e1\i-- added check that filled-in DA is valid at GetBits & added EFTPFinishReceiving.-- Last Edited:  October 26, 1981  10:54 AM   By:  GWilliams e1\i--added fileLengthReport-- Last Edited:  October 27, 1981  5:17 PM   By:  GWilliams e1\2i-- put check at end of GetBits to stop if not continuing-- Last Edited:  November 24, 1981  3:04 PM   By:  GWilliams e1\i-- In middle of revamping to accept bits on a scan line basis rather than read a whole Press.bits file.-- Last Edited:  December 2, 1981  11:16 AM   By:  GWilliams e1\i-- Back again - - took time out to help Starkweather & to write Performance appraisal.-- Last Edited:  December 8, 1981  6:03 PM   By:  GWilliams e1\i-- Back again - - Press.fonts broke, now debugging.-- Last Edited:  December 9, 1981  4:38 PM   By:  GWilliams e1\i-- Fixing OpenPressBits for when can't find Press.bits on T300.-- Last Edited:  December 10, 1981  4:24 PM   By:  GWilliams e1\i-- In InitTfsBuffer, was loading vda of 2nd page of bits file with firstVda.-- Last Edited:  December 21, 1981  3:49 PM   By:  GWilliams e1\i-- Changed CloseServerConnection to not do EFTPFinishReceiving on closing.-- Last Edited:  December 21, 1981  5:04 PM   By:  GWilliams e1\i-- Changed GetBits to ask for more data than needed in order to wait for sender disconnect.-- Last Edited:  December 31, 1981  3:17 PM   By:  GWilliams e1\i-- Changed ordering of call on InitTfsBuffer and InitScanBuffer.-- GetBits is called by Press.mesa-- Last Edited:  February 8, 1982  11:22 AM   By:  GWilliams e1\i-- WritePageGPage now gets printerMode from pageAttributes record sent from client.-- Last Edited:  March 5, 1982  3:48 PM   By:  GWilliams e1\i-- Added Press Bands code to read Cedar bands file entries and explode into press.bits.-- Last Edited:  March 8, 1982  1:59 PM   By:  GWilliams e1\i-- Refining Bands code: clean up bits file disk object if fail in openning band sfile.-- Last Edited:  March 10, 1982  11:19 AM   By:  GWilliams e1\i-- Integrating Bands expanding code.(635)\i