-- File:  PressInit.mesa: Mesa version of PressInite1(1792)\i-- Last Edited:  November 18, 1981  4:50 PM   By:  GWilliams e1\i--Fixed PressInit to OR rather than AND the filesys and drive.e1\i63IDIRECTORYe1AltoRam USING [CantFindFile, FileLooksCrufty],InlineDefs USING[BITOR, BITSHIFT, COPY],IODefs USING[CR, NUL, SP, TAB, ReadChar, WriteChar, WriteString, WriteLine],l3634e1k72(635)PressDefs USING [PageG, PageGLength, PressPassword, RamBoot, readBandsFile, serverMode, SlotInit, uCodeLoaded],l4269d3634e1k72SegmentDefs USING[DataSegmentHandle, DefaultBase, DeleteDataSegment, DeleteFileSegment, FileHandle, FileSegmentHandle, NewFile, NewFileSegment, FileNameError, NewDataSegment, OldFileOnly, SegmentAddress, SwapIn, SwapOut, Unlock],l4269d3634e1k72StreamDefs USING[NewByteStream, Read, StreamHandle],l3634e1k72StringDefs USING[AppendChar, StringToDecimal, UpperCase],l3634e1k72SystemDefs USING [AllocateHeapNode],l3634e1k72TridentDefs USING[BadErrorRtn, dcReadD, ddMgrPtr, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, fillInDA, FP, PAGE, TfsActOnPages, tfsdskPtr, TfsCloseDisk, TfsCreateDDmgr, TfsDestroyDDMgr, TfsInit, TfsOpenFile, VDA];l4269d3634e1k72e1(1792)\bPressInit: PROGRAMe1\b9BIMPORTS AltoRam, InlineDefs, IODefs, PressDefs, SegmentDefs, StreamDefs, StringDefs, SystemDefs, TridentDefsl4904d3634e1k72(635)EXPORTS PressDefs=l3633e1(1792)--SHARES l3633e1BEGIN OPEN AltoRam, InlineDefs, IODefs, PressDefs, SegmentDefs, StreamDefs, StringDefs, SystemDefs, TridentDefs;l3633d2998e1-- Typese1\iAqSwitches: TYPE=RECORD[	length: INTEGER,	options: ARRAY[1..5]OF CHARACTER,	num: INTEGER];Switches: TYPE = POINTER TO AqSwitches;PressError: TYPE = {noUcode, badUcode, noTrident, noBitsFile, tridentError, badBitFile, badStateFile};e1\236i-- Public Pack Variables EXPORTED to PressDefs e1\i46Icopies: PUBLIC INTEGER _ 1;invertMode: PUBLIC BOOLEAN _ FALSE;reprint: PUBLIC BOOLEAN _ FALSE;numPages: PUBLIC CARDINAL;fp: FP;filePtr: PUBLIC POINTER TO FP; --empty at first, load as first line of Init (compiler bug)pageGarray: PUBLIC POINTER TO ARRAY OF PageG;--EXPORTED to PressDefse1\165i58I47inPrinterColors, portrait, printerDevice, printerMode, ResolutionB, ResolutionS, SLOTScanLength, SLOTScanMarginAdjust, SLOTBitMarginAdjust, SLOTDouble, SLOTTimeOut, printerMaxBitsPerScan, ScanLengthInches: PUBLIC INTEGER;l3633d2998e1--Private Pack Variablesdebug: BOOLEAN _ FALSE;h: StreamDefs.StreamHandle;putBackChar: CHARACTER _ NUL;--Signals and Errors. None of these gets out of this module.segmentNotIn: ERROR = CODE;BadPressStateFile: ERROR = CODE;CantOpenTrident: ERROR = CODE;CantFindPressBits: ERROR = CODE;TridentError: ERROR = CODE;InconsistentBitsFile: ERROR = CODE;--Procs--Main routine:-- 1) Get commands  (NO LONGER - - October 23, 1981  3:27 PM )-- 2) Load state from Press.state off model 31 disk.--	3) Load the ram--	4) Init the Trident and find press.bits--	5) exit to perform Press Main loopl2999k72(635)\1i25I27f1 11f0 44i62bI14B13i1bI19B13i1bI17B14b19B13i1bI14B13i1bI22B13i1I4iInit: PUBLIC PROC[] RETURNS [disk: tfsdskPtr _ NIL, firstVDA: VDA _ LOOPHOLE[0, VDA], goAhead: BOOLEAN _ FALSE]=l3634d2999k72\b4B108bBEGIN	filePtr _ @fp;--	Read Com.cm before calling this stuff	IF ~GetPressState[!BadPressStateFile => GOTO badStateFile] THEN RETURN [ , , ];--load microcode if not already in.IF ~uCodeLoaded THEN	{RamBoot["MesaSlotMc.br"! CantFindFile => GOTO noUcode;							FileLooksCrufty  =>GOTO badUcode];	 uCodeLoaded _ TRUE;};--init the Trident and find Press.bits	[disk, firstVDA] _ InitTrident[!								CantOpenTrident => GOTO noTrident;							CantFindPressBits => GOTO noBitsFile;							TridentError => GOTO tridentError;							InconsistentBitsFile => GOTO badBitFile];	goAhead _ TRUE;		--made it here, continue.EXITSnoUcode => Scream[noUcode];badUcode => Scream[badUcode];noTrident => Scream[noTrident];noBitsFile => Scream[noBitsFile];tridentError => Scream[tridentError];badBitFile => Scream[badBitFile];badStateFile => Scream[badStateFile];END;--Initl2999k72\24i41I65b6B13i34I143i40I231i25I242b4i6BIScream: PROC[error: PressError]={	SELECT error FROM	noUcode => WriteLine["Can't find file MesaSlotMc.br."L];	badUcode => WriteLine["Microcode file ""MesaSlotMc.br"" is malformed."L];	noTrident => WriteLine["Can't Init Trident, check it."L];	noBitsFile => WriteLine["Can't find file ""Press.bits""."L];	tridentError => WriteLine["Sorry, Trident Hard Read Error."L];	badBitFile => WriteLine["Bits File is inconsistent."L];	badStateFile => WriteLine["Press.state is inconsistent."L];	ENDCASE;	WriteLine["Type any key to finish"];	[] _ ReadChar[];};--ScreamReadCommandFile: PUBLIC PROC[] RETURNS[okToProceed: BOOLEAN _ FALSE]=--Raises no signals or errorsBEGIN	swIndex: INTEGER _ 1;	aqSwitches: AqSwitches_[0, [NUL, NUL, NUL, NUL, NUL], -1];	switches: Switches = @aqSwitches; BEGIN	command: STRING _ [20];	switches.length _ 0;	IF serverMode THEN RETURN[TRUE];	ReadComInit[];-- open Com.cm etc.	UNTIL ReadCom[command, switches]--returns eof	DO		FOR swIndex IN [1..switches.length] DO			SELECT switches.options[swIndex] FROM					'N => invertMode _ TRUE;					'D => NULL;				ENDCASE => GOTO illegalComSwitch;		ENDLOOP;	IF debug THEN		{WriteString["Switches: "];		 IF invertMode THEN WriteChar['N] ELSE WriteString["None"]; WriteLine[""];		}; -- one line output per token	IF command[0] = 'R AND command[1] = 'E AND command[2] = 'P THEN		reprint _ TRUE;	IF command[0] = 'C AND command[1] = 'O AND command[2] = 'P THEN		copies _ switches.num;	IF command[0] = 'S AND command[1] = 'E AND command[2] = 'R THEN		serverMode _ TRUE;	IF command[0] = 'B AND command[1] = 'A AND command[2] = 'N THEN		readBandsFile _ TRUE;	IF copies < 1 THEN GOTO illegalCom;	ENDLOOP;	IF (~reprint AND ~ serverMode AND ~readBandsFile) THEN GOTO noCom;	h.destroy[h];--close file	okToProceed _ TRUE;EXITSillegalComSwitch => {WriteString["Illegal Switch: "];				WriteChar[switches.options[swIndex]];				WriteLine[""];				WriteLine["Type any key to finish"];				[]_ReadChar[]; h.destroy[h];};illegalCom => {WriteLine["Illegal command Line"];				WriteLine["Type any key to finish"];				[]_ReadChar[]; h.destroy[h];};noCom => 	{WriteLine["Reprint, Server, Copies & Bands are the only valid commands; /N the only switch"];		 		WriteLine["Type any character to finish"];		 		[]_ReadChar[]; h.destroy[h];};END;--for EXITS to be able to see switchesEND;--of ReadCommandFileReadCom: PROC[com: STRING, sw: Switches] RETURNS[eof: BOOLEAN _ FALSE]=--This routine is called repeatedly until it returns true.--Raises no Errors or Signals{	c: CHARACTER _ NUL;	nm: STRING _ [10];	com.length _ 0;	nm.length _ 0;	sw^ _ [0, [NUL, NUL, NUL, NUL, NUL], -1];	UNTIL h.endof[h] DO		--get command		c _ GetChar[];		SELECT c FROM			CR, '/ => EXIT;			SP, TAB => {IF com.length#0 THEN EXIT ELSE LOOP}; --elim leading spaces		IN ['a..'z] => AppendChar[com, UpperCase[c]];		IN ['A..'Z] => AppendChar[com,c];		ENDCASE;	ENDLOOP;	IF c = '/ THEN			--get 1 switch only		{UNTIL h.endof[h] DO			c_ GetChar[];			SELECT c FROM				SP, TAB => LOOP;				CR => EXIT;			ENDCASE => {sw.length _ sw.length + 1;							sw.options[1] _ UpperCase[c]; EXIT};		ENDLOOP;		}	ELSE					--look for a number		{UNTIL h.endof[h] DO			SELECT c FROM				CR => EXIT;				SP, TAB => {c_GetChar[]; LOOP};				IN ['0..'9] => AppendChar[nm, c];			ENDCASE => {putBackChar _ c; EXIT};--save other chars for later scan			c_GetChar[];		ENDLOOP;		}; 	IF nm.length # 0 THEN sw.num _ StringToDecimal[nm];	IF com.length =0 AND h.endof[h] THEN eof _ TRUE;};--ReadComReadComInit: PROC[]={	h _ NewByteStream["Com.cm", Read];};--ReadComInitGetChar: PROC[]RETURNS[ch: CHARACTER]={	IF putBackChar # NUL	THEN {ch _ putBackChar; putBackChar _ NUL}	 ELSE ch _ h.get[h];};--GetCharInitTrident: PROC[] RETURNS [disk: tfsdskPtr _ NIL, firstVda: VDA]=--firstVda is not initialized at declaration line because this routine fills it in on successful return--and error returns (as signals) => value is undefined.--Errors: CantOpenTrident CantFindPressBits TridentError InconsistentBitsFileBEGIN	DAs: DESCRIPTOR FOR ARRAY OF PAGE;	ddMgr: ddMgrPtr;	fileSys: CARDINAL _ 1; --ignore this and go to fileSys 0 on first try	nmChars: CARDINAL _ 2048;	pages: ARRAY[0..4] OF PAGE _ [fillInDA, fillInDA, fillInDA, fillInDA, fillInDA];	tridentBuffer: POINTER TO ARRAY [0..1024) OF WORD _ NIL;	tridentBufferSegment: DataSegmentHandle;	vda: CARDINAL _ 0;	disk.tfskd.ddMgr _ddMgr _ TfsCreateDDmgr[];	--assign disk part due to bug in TfsCreateDDmgr	disk _ TfsInit[TRUE,,ddMgr,];					--initmode=TRUE, drive, ddMgr, freshDisk=FALSE 	IF disk = NIL THEN {TfsDestroyDDMgr[ddMgr]; ERROR CantOpenTrident;}; --pretty bad if drive zero doesn't work.	[, vda,] _ TfsOpenFile[disk, "Press.bits.", read, filePtr];	WHILE vda = 0 AND fileSys < 23 				--check all filesystems on a T300	 DO											--drives 0-7 and 3 filesystems/drive		IF disk.tfskd.model = 80 THEN EXIT;   			 --"not found" if not on 1st file system.		[]_TfsCloseDisk[disk, TRUE];				--keep ddMgr around		disk _ TfsInit[TRUE, BITOR[BITSHIFT[(fileSys MOD 3), 8], (fileSys/3)], ddMgr, ];		fileSys_fileSys+1;		IF disk=NIL THEN LOOP;		[, vda,] _ TfsOpenFile[disk, "Press.bits.", read, filePtr];	 ENDLOOP;									--of  WHILE vda = 0 DO		IF vda # 0 THEN		{		tridentBufferSegment _ NewDataSegment[DefaultBase, 4];--get 1K		tridentBuffer _ SegmentAddress[tridentBufferSegment];l2999e1k72\b7B551i8I3b16B55i30I229i19I35i13I309i29I1031i38I6i20bI1B2b7B65i89I140i15I104i22I125i19I206i19I169i33I139i11bI12B64b7B123i9I1b1B1b12B57i159I1i77I61i1I25i44I276i47I35i48I71i40I98i33I18i34I32i1bI4B1i3I3i41I32i23I202i31I80i8I		DAs _ DESCRIPTOR[@pages[1], 4];l4896d2999e1k72		DAs[1] _ vda;l4896d2999e1k72		[] _ TfsActOnPages[disk, NIL, DAs, filePtr^, 1, 1, dcReadD, @nmChars, dcReadD, tridentBuffer, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, TRUE, 0!BadErrorRtn =>	{DeleteDataSegment[tridentBufferSegment];	 [] _ TfsCloseDisk[disk, FALSE! BadErrorRtn => ERROR TridentError];	ERROR TridentError;	};]; --end of call to TfsActOnPagesl4896d2999e1k72\300i31I			numPages _ tridentBuffer[0];				--get number of pages to print from this Press.bits		printerMode _ (IF portrait # 0 THEN 3 ELSE 8);		IF tridentBuffer[1] # PageGLength THEN {DeleteDataSegment[tridentBufferSegment]; ERROR InconsistentBitsFile;};		IF LOOPHOLE[tridentBuffer[2], INTEGER] # printerMode THEN			{DeleteDataSegment[tridentBufferSegment]; ERROR InconsistentBitsFile;};		IF tridentBuffer[3] # PressPassword THEN {DeleteDataSegment[tridentBufferSegment]; ERROR InconsistentBitsFile;};		pageGarray _ AllocateHeapNode[PageGLength*numPages];		COPY[@tridentBuffer[4], PageGLength*numPages, pageGarray];		DeleteDataSegment[tridentBufferSegment];		RETURN [disk, LOOPHOLE[vda, VDA]];		}		ELSE 									--here if didn't find either on T80 or T300		{[] _ TfsCloseDisk[disk, FALSE]; 				--with "don'tFree"=FALSE => destroy ddMgr		 ERROR CantFindPressBits;		};END; --of InitTrident--Format of Press.State holds state for all types of printing devices supported by press:--Word#			Function--0				Creation date time stamp--1				# of default switches--2-40			the switches--41-<a zero	3-word tables:--	  word>		word 0: address of static--					word1:  length of block (if zero, then block is 1 word log)--					word2:  value of static--only words 0-40 are used by this program. BCPL Press uses the tables on initialization.GetPressState: PROC[] RETURNS[flag: BOOLEAN _ TRUE]=	--default to say all is ok--load global variables that we'll need--The global variables will appear in the following order (after the default list):--	DoMeter, DoFileMeter, DoFaultMeter, UseMicroCode, DoEtherReport, SoftScan, nPrinterColors, PaperSpeedInches, printerDevice, ResolutionB, ResolutionS, printerForward, portrait, SLOTScanLength, SLOTScanMarginAdjust, SLOTBitMarginAdjust, SLOTDouble, SLOTTimeOut, VersatecMsSl, VersatecFF, blockBitsFile, printerMaxBitsPerScan, PaperDimensionB, PaperDimensionS, ScanLengthInches, ScreenModulus, ScreenMagnitude, ScreenAngle, len -this is a block > 0 - (for indexing files), tridentUsed, BESizes -another block >0-, OverlayTable -block >0---all the settings that concern us are single variables, and consist of a subset of the above list. Raises BadPressStateFile, segmentNotIn{	fH: FileHandle;	fileSeg: FileSegmentHandle;	inCoreAddress: POINTER TO ARRAY [0..256) OF CARDINAL;	curEntry: INTEGER;	fH _ NewFile["Press.State", Read, OldFileOnly!			FileNameError => {	WriteString["File Press.State is required"];								GOTO abortRoutine;};]; 	fileSeg _ NewFileSegment[fH, 1, 2, ];--point to one page; default access	SwapIn[fileSeg];--get it into core	inCoreAddress _ LOOPHOLE[SegmentAddress[fileSeg]];--find out where it is	IF inCoreAddress = NIL THEN segmentNotIn;  --pick up index that points past last word of defaults	curEntry _ inCoreAddress[1] +1+ 7 * 3;	--"7" for nPrinterColors, (3=length of each entry)+1 for loc of offset amt	--now load globals	nPrinterColors _ inCoreAddress[curEntry];	curEntry _ curEntry + 6; 	printerDevice _ inCoreAddress[curEntry];	curEntry _ curEntry + 3;	ResolutionB _ inCoreAddress[curEntry];	curEntry _ curEntry + 3;	ResolutionS _ inCoreAddress[curEntry];	curEntry _ curEntry + 6;	portrait _ inCoreAddress[curEntry];	curEntry _ curEntry + 3;	SLOTScanLength _ inCoreAddress[curEntry];	curEntry _ curEntry + 3;	SLOTScanMarginAdjust _ inCoreAddress[curEntry];	curEntry _ curEntry + 3;	SLOTBitMarginAdjust _ inCoreAddress[curEntry];	curEntry _ curEntry + 3;	SLOTDouble _ inCoreAddress[curEntry];	curEntry _ curEntry + 3;	SLOTTimeOut _ inCoreAddress[curEntry];	curEntry _ curEntry + 12;	printerMaxBitsPerScan _ inCoreAddress[curEntry];	curEntry _ curEntry + 9;	ScanLengthInches _ inCoreAddress[curEntry];	Unlock[fileSeg];	SwapOut[fileSeg];	DeleteFileSegment[fileSeg];--calls ReleaseFile	IF nPrinterColors # LOOPHOLE[inCoreAddress[27+2]] OR	--check for a little consistency		printerDevice # LOOPHOLE[inCoreAddress[5+2]] OR		~(printerDevice IN [1..9]) THEN BadPressStateFile;EXITS	abortRoutine => RETURN[FALSE];	--error!};	--of GetPressStatePrintInit: PUBLIC PROC[] ={--this routine would normally select on which device we're running and init that device.--However, just init the slot.SlotInit[]; };--PrintInitEND. -- PressInit.mesal2999d1729e1k72\37i50I167f1 9f0 18f1 8f0 372b6B40i52I35i46I41i15I1i93u5U3u8U338I1b13B39i27I1i42f1 510f0b22f1B44f0b18f1B15f0b10B140I497i57I43i1I1i70I5i16I271f1i1f0I62f1i1f0I537i19I57i30I144i6I3i20I2b9B22i118I11i1I3i11I6i18ILOGl4269d2999e1\iTime: May 15, 1981  3:55 PM	By: Glen Williams	Action: Created.l4269d2999e1\i-- Last Edited:  September 3, 1981  12:58 PM   By:  GWilliams e1(1792)\ie1-- Last Edited:  October 23, 1981  3:25 PM   By:  GWilliams e1\i--changed ReadCommandFile to look for server switch, and make it public.-- Last Edited:  November 4, 1981  3:21 PM   By:  GWilliams e1\i--dropped the WriteLine["Bit Flinger"];  changed # 11 to # PageGLength @InitTrident-- Last Edited:  November 18, 1981  10:17 AM   By:  GWilliams e1\i--had given Press.bits. to tfsOpenfile, but then gave it Press.bits on a retry. Tfs blew up.(635)\i