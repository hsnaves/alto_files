-- File:  ExperimentalPrintSlot.mesa.z20496e1(1792)\i--edit history at bottom of file-- Last Edited:  April 12, 1982  4:39 PM  By:  GWilliams z20496e1\i--Get scan buffers through segmentation machinery now rather than through Words.DIRECTORYz20496e1\i81IAltoDefs USING [PageSize],z20496l4269d3634e1k72(635)InlineDefs USING[BITAND, BITNOT, BITOR, BITSHIFT, BITXOR],IODefs USING[CR, ReadChar, --ReadDecimal,-- WriteChar, WriteDecimal, WriteLine, WriteString],z20496l3634e1k72\86i16IMiscDefs USING [--CallDebugger,-- Zero],z20496l4269d3634e1k72\16i17IPressDefs USING [abortFile, invertMode, PageG, PageGptr, SLOTScanLength, SLOTScanMarginAdjust, SLOTBitMarginAdjust, SLOTDouble, SLOTTimeOut],z20496l4269d3634e1k72RamDefs USING[StartIO],z20496l4269d3634e1k72SegmentDefs USING[DataSegmentAddress, DataSegmentHandle, DefaultBase, DeleteDataSegment, InsufficientVM, NewDataSegment],z20496l4269d3634e1k72--StringDefs USING [UpperCase],SystemDefs USING [Even],z20496l3634e1k72TridentDefs USING[DA, diskCheck, diskRead, dlPtr, dstDone, dstZeroStatus, FP, kcbPtr, lKCB, Mstatus, PAGE, ptr, statusptr, Status, tfsdskPtr, TfsRealDA, TFSwordsPerPage, track];z20496l4269d3634e1k72\151i1Iz20496e1(1792)\bPrintSlot: PROGRAMz20496e1\b9BIMPORTS InlineDefs, IODefs, MiscDefs, PressDefs, RamDefs, SegmentDefs, --Storage, StringDefs,-- SystemDefs, TridentDefsz20496l4904d3634e1k72(635)\71i25IEXPORTS PressDefs=z20496l3633e1(1792)BEGIN OPEN AltoDefs, InlineDefs, IODefs, MiscDefs, PressDefs, RamDefs, SegmentDefs, --StringDefs, Storage,-- SystemDefs, TridentDefs;z20496l3633d2998e1\84i24I-- Typesz20496e1\iPError: TYPE = {noPaper, jam, firstFillFailed, firstFillTimeOut, pageTimeOut, overRan, scannerOverRan, readError, illegal, notSure};SlotCommand: TYPE = {setDensity, beamOn, reset, stopPrint, beamOff};z20496e1\201i--SCB: TYPE = MACHINE DEPENDENT RECORD--	[--	blank:	[0..37777B],	- -14 bits worth--	com:	[0..3],	- -Beam On =0, Status = 1, Reset = 2, Print = 3--	blowup:	[0..1),	- -True: make one bit into 4--	lastPage:	[0..1),	- -Marks this command as the last page if true--	invert:	[0..1),	- -invert this page--	bitsPerLine:	[0..17777B],	- -servo count for number of bits per line--	bitMargin:	CARDINAL,	- -bottom margin in bits--	scanLineWc:	CARDINAL,	- -double of the word count--	scanMargin:	CARDINAL,	- -left margin (bits before print in portrait)--	scansPerPage:	CARDINAL,	- -total number of scan lines per page--	bufferPtr:	POINTER,	- -print buffer base address (first loc.)--	scanLineWcInc:	CARDINAL,	- -print buffer scan line increment--	scansPerBuff:	CARDINAL,	- -print-mode buffer length--	currentBuf:	POINTER,	- -current buffer address--	currentLine:	CARDINAL,	- -current scan address--	status:	ReturnStatus,	- -return status--	filler:	CARDINAL];	- -in case SetSCB adds one to base addressSCB: TYPE = MACHINE DEPENDENT RECORD	[	blank:	[0..37777B],	--14 bits worth	com:	[0..3],	--Beam On =0, Status = 1, Reset = 2, Print = 3	blowup:	[0..1),	--True: make one bit into 4	lastPage:	[0..1),	--Marks this command as the last page if true	invert:	[0..1),	--invert this page	slug:	[0..17777B],	--13 bits of filler. Was bitsPerLine.	bitMargin:	CARDINAL,	--bottom margin in bits	scanLineWc:	CARDINAL,	--double of the word count	scanMargin:	CARDINAL,	--left margin (bits before print in portrait)	scansPerPage:	CARDINAL,	--total number of scan lines per page	bufferPtr:	POINTER,	--print buffer base address (first loc.)	scanLineWcInc:	CARDINAL,	--print buffer scan line increment	scansPerBuff:	CARDINAL,	--print-mode buffer length	bitsPerLine:	CARDINAL,	--servo count for number of bits per line	currentBuf:	POINTER,	--current buffer address	currentLine:	CARDINAL,	--current scan address	status:	ReturnStatus,	--return status	debuggingSpace0: CARDINAL,	debuggingSpace1: CARDINAL,	debuggingSpace2: CARDINAL,	debuggingSpace3: CARDINAL,	debuggingSpace4: CARDINAL,	debuggingSpace5: CARDINAL,	debuggingSpace6: CARDINAL,	debuggingSpace7: CARDINAL,	filler:	CARDINAL	--in case SetSCB adds one to base address	];ReturnStatus: TYPE = MACHINE DEPENDENT RECORD	[	blank:	[0..377B],	spare2:	[0..1],	wait:	[0..1],	paperJam:	[0..1],	addPaper:	[0..1],	selectB:	[0..1],	ready:	[0..1],	lineSync:	[0..1],	pageSync:	[0..1]	--complemented signal	];normalizedStatus: ReturnStatus _ [0,0,1,1,1,0,0,0,1];	--161BMetaStat: TYPE = POINTER TO AqMetaStat;AqMetaStat: TYPE = MACHINE DEPENDENT RECORD	[wait:	BOOLEAN,	--from uCode	paperJam:	BOOLEAN,	--from uCode	paperOut:	BOOLEAN,	--from uCode	illegal:	BOOLEAN,	--from IllegalState	ready:	BOOLEAN,	--"OR" of various bits and variables	overRun:	BOOLEAN,	--from "bufferEmpty"--	fill:	[0..1777B],	----filler	fill:	[0..0777B],	--filler	scannerOverRun: BOOLEAN,	--scanner got >1 buffers ahead	pageNotPrinted: CARDINAL,	--from PrintFail	diskError:	CARDINAL	--from "readErrors"	]; z20496e1(0,4800)(1,6976)(2,9760)\i952I14i39I61i16I14i47I9i1I7i28I19i46I18i18I21i37I25i21I23i27I23i46I26i37I22i40I27i34I26i26I25i41I23i24I25i22I24i15I243i41I214i22I58i6I104i12I21i12I23i10I20i19I18i36I20i20I24i8I20i8I29i29I27i16I22i19I6i-- Public Pack Variables EXPORTED to PressDefs z20496e1(1792)\i46I--EXPORTED to PressDefsz20496e1\i--Private Pack VariablesscannerOverRun, overRun, illegalState: BOOLEAN;	--these are initialized by SlotInitprintFail, readErrors, pBufferCalls: CARDINAL;slotCommandBlock: POINTER TO POINTER = LOOPHOLE[720B];slotSIObit: CARDINAL = 4;--debugging switchesuseSLOT: BOOLEAN _ TRUE;debug: BOOLEAN _ FALSE;noDisplay: BOOLEAN _ TRUE;diskRetries: CARDINAL _ 20B;testDiskOnly: BOOLEAN _ FALSE;checkBufs: BOOLEAN _ TRUE;da: PAGE;	--used by SLOTPrint and ReadBufferreadNext, printNext: kcbPtr;printCount, readCount: CARDINAL;--global names for variables that will be initialized in ReadBuffer for PrintSlotgTrack: INTEGER;gHead, gSector: INTEGER;active: POINTER TO CARDINAL = LOOPHOLE[453B];--for turning off memory parity interrruptsz20496(635)\i25I47i37I129i21I173i36I64i80I88iwakeupsWaiting: POINTER TO CARDINAL = LOOPHOLE[452B];RTC: POINTER TO CARDINAL = LOOPHOLE[430B];Display: POINTER = LOOPHOLE [420B];DisplayOn: BOOLEAN _ TRUE;savedDisplay: WORD;parityInterruptBit: CARDINAL = 1;bandWidth: CARDINAL = 16;beamOnCommand: CARDINAL = 0;statusCommand: CARDINAL = 1;resetCommand: CARDINAL = 2;printCommand: CARDINAL = 3;--Signals and Errors--ProcsOriginalSlotInit: PUBLIC PROC []={	SLOTCommand[reset];	SLOTCommand[beamOn];	SlotReady[];};--SlotInitz20496\242i1I117i21I4i7bI16B80i8ISlotInit: PUBLIC PROC []={	SLOTCommand[reset];--	SLOTCommand[beamOn];	SlotReady[];};--SlotInitz20496\b8B40i24I18i8IOriginalSLOTCommand: PROC[cmd: SlotCommand]=BEGIN	i: CARDINAL;	sCB:	SCB;	scb: POINTER TO SCB _ @sCB;	scb _ SetSCB[scb];	--align to even word boundary and init some fields.	SELECT cmd FROMz20496\i1bI19B107i52I		setDensity, beamOn =>	scb.com _ beamOnCommand;		reset =>	{overRun _ scannerOverRun _ illegalState _ FALSE; printFail _ readErrors _ 0;			 scb.com _ resetCommand;};		stopPrint, beamOff =>	scb.com _ resetCommand;		ENDCASE =>	{illegalState _ TRUE; GOTO done};z20496(0,3648)(1,4256)(2,7744)	slotCommandBlock^ _ LOOPHOLE[scb];	IF useSLOT THEN		{[] _ StartIO[slotSIObit];		FOR i IN [0..30000]		DO			IF scb. status # ReturnStatus[0,0,0,0,0,0,0,0,0] THEN EXIT;		ENDLOOP;		IF scb.status = ReturnStatus[0,0,0,0,0,0,0,0,0] THEN illegalState _ TRUE;		IF cmd = beamOn THEN MsWait[1000];		};EXITSdone => NULL;END;--SlotCommandz20496(635)\326iSLOTCommand: PROC[cmd: SlotCommand]=BEGIN	i: CARDINAL;	sCB:	SCB;	scb: POINTER TO SCB _ @sCB;	scb _ SetSCB[scb];	--align to even word boundary and init some fields.	SELECT cmd FROMz20496\b11B107i52I		setDensity, beamOn =>	scb.com _ beamOnCommand;		reset =>	{overRun _ scannerOverRun _ illegalState _ FALSE; printFail _ readErrors _ 0;			 scb.com _ resetCommand;};		stopPrint, beamOff =>	scb.com _ resetCommand;		ENDCASE =>	{illegalState _ TRUE; GOTO done};z20496(0,3648)	slotCommandBlock^ _ LOOPHOLE[scb];	IF useSLOT THEN		{[] _ StartIO[slotSIObit];		FOR i IN [0..30000]		DO			IF scb. status # ReturnStatus[0,0,0,0,0,0,0,0,0] THEN EXIT;		ENDLOOP;		IF scb.status = ReturnStatus[0,0,0,0,0,0,0,0,0] THEN illegalState _ TRUE;		IF cmd = beamOn THEN MsWait[1000];		};EXITSdone => NULL;END;--SlotCommandz20496(635)\326iSlotStatus: PROC[metaStat: MetaStat]={	sCB:	SCB;	scb: POINTER TO SCB _ @sCB;	IF useSLOT THEN		{scb _ SetSCB[scb];		scb.com _ statusCommand;		scb.status _ normalizedStatus;	--some dummy bits		slotCommandBlock^ _ scb;		[] _ StartIO[slotSIObit];		 MsWait[37];					--give microcode time to see new command		IF scb.status = normalizedStatus THEN illegalState _ TRUE;		scb.status _ BITXOR[scb.status, normalizedStatus];			metaStat.wait _ scb.status.wait # 0;		metaStat.paperJam _ scb.status.paperJam # 0;		metaStat.paperOut _ scb.status.addPaper # 0;		metaStat.illegal _ illegalState;		metaStat.pageNotPrinted _ printFail;		metaStat.overRun _ overRun;		metaStat.scannerOverRun _ scannerOverRun;		metaStat.diskError _ readErrors;z20496\b11B169i17I74i41I	metaStat.ready _ scb.status.ready = 1 AND NOT(metaStat.wait OR metaStat.paperJam OR metaStat.paperOut OR metaStat.illegal OR metaStat.pageNotPrinted # 0 OR metaStat.overRun OR metaStat.scannerOverRun OR metaStat.diskError # 0);}z20496l4903d3633		ELSE metaStat.ready _ TRUE;z20496l4268d2998};--SlotStatusPrintError: PROC[err: PError, num: CARDINAL] RETURNS[continue: BOOLEAN _ FALSE]=--This routine should turn the display on if it was off and type appropriate message, then turn the display back off to continue.--if the error is notSure, display the whole slotStats structure{	displayWasOn: BOOLEAN _ DisplayOn;	canContinue: BOOLEAN _ FALSE;	IF ~DisplayOn THEN		{Display^ _ savedDisplay; DisplayOn _ TRUE};	SELECT err FROM	noPaper => {WriteLine["Reload printer with paper. Type any key to continue."L];					[]_ReadChar[];					continue _ TRUE;					IF ~displayWasOn THEN						{savedDisplay _ Display^; Display^ _0; DisplayOn _ FALSE};					GOTO getOut;					};	jam => 		{WriteLine["Printer jammed. Fix, then type any key to continue."L];					[]_ReadChar[];					continue _ TRUE;					IF ~displayWasOn THEN						{savedDisplay _ Display^; Display^ _0; DisplayOn _ FALSE};					GOTO getOut;					};	firstFillFailed, firstFillTimeOut=>					{WriteLine["Trident didn't get off the ground."L];					 WriteString["Calls to start Trident: "L];					 WriteDecimal[num]; WriteChar[CR]};	pageTimeOut=>	{WriteLine["Page took too long to print."L];					 WriteString["Calls to start Trident: "L];					 WriteDecimal[num]; WriteChar[CR]};	overRan=>	{WriteLine["Disk Overran "L]; canContinue _ TRUE};	scannerOverRan=>	{WriteLine["Slot Overran"L]; canContinue _ TRUE};	readError=>	{WriteDecimal[num]; WriteLine[" readErrors."L];};	illegal =>		WriteLine["Slot doesn't answer request for status"L];	notSure =>	{WriteLine["Unknown Error"L];};	ENDCASE;--	IF canContinue THEN--		{WriteString["Type Y to continue, anything else to exit: "L];--		 IF (UpperCase[ReadChar[]] = 'Y) THEN continue _  TRUE; WriteChar[CR]};--	IF ~continue THEN abortFile;EXITS	getOut=> NULL;};--PrintErrorSlotReady: PROC [metaStat: MetaStat _ NIL]={	aqMetaStat: AqMetaStat;	mStat: MetaStat _ @aqMetaStat;	continue: BOOLEAN _ FALSE;	IF metaStat = NIL THEN		{metaStat _ mStat;		 SlotStatus[metaStat];};	IF ~useSLOT THEN metaStat.ready _ TRUE;	IF ~metaStat.ready THEN		{SLOTCommand[reset];		 IF metaStat.paperOut  THEN  continue _ PrintError[noPaper, 0];		 IF metaStat.paperJam  THEN  continue _  PrintError[jam, 0];		 IF metaStat.illegal THEN  continue _  PrintError[illegal, 0];		 IF metaStat.pageNotPrinted # 0 THEN				SELECT metaStat.pageNotPrinted FROM				 1 => continue _ PrintError[firstFillFailed, pBufferCalls];				 2 => continue _ PrintError[firstFillTimeOut, pBufferCalls];				 3 => continue _ PrintError[pageTimeOut, pBufferCalls];	--took too long to print entire page				 ENDCASE;		 IF metaStat.overRun THEN  continue _ PrintError[overRan, 0];		 IF metaStat.scannerOverRun THEN  continue _ PrintError[scannerOverRan, 0];		 IF metaStat.diskError # 0 THEN  continue _ PrintError[readError, metaStat.diskError];		 IF ~continue THEN			{WriteString["Type any key to exit: "L];			[] _ ReadChar[]; WriteChar[CR];			abortFile};		 SLOTCommand[reset];		 SLOTCommand[beamOn];		};};--SlotReadyMsWait: PROC[ms: CARDINAL]={	timeOut: CARDINAL _  RTC^ + ms/37;	--RTC runs at ~38 uSec/click, but clicks are measured at a scale of ~1024 uSec/click	UNTIL RTC^  >= timeOut DO ENDLOOP;};--MsWait--Pslot grabs as much storage as it can for buffers of scan lines. Each buffer holds a multiple of TfsWordsPerPage--The buffers are arranged in a ring, with @buffer-1 holding the address of the next buffer. The storage is grabbed from the system as--  one large segment if it can get it, and then divided into the buffers.--The display machinery is turned off here in the final product. It is turned back on if there is an eror.--SLOTPrint is then called to print the page by filling the buffers and passing them to the microcode.--November 10, 1981  1:47 PM: no longer get as much storage as possible. Just get 2 buffers and go with themPSlot: PUBLIC PROC[disk: tfsdskPtr, pageG: PageGptr, lastPage: BOOLEAN, firstVDA: PAGE, filePtr: POINTER TO FP] =z20496l2999d2998\1i13bI12B71i129I1i65I1501i14bI10B744i36I417i11bI8B59i84I39i8I3i537b26B81bI5BBEGIN	i, nBufs, oldActive: CARDINAL;	zoneBase, firstBuf, buf: POINTER _ NIL;	aqMetaStat: AqMetaStat;	myZone: DataSegmentHandle _ NIL;	dcbSegment: DataSegmentHandle;	dcbTab: POINTER _ NIL;	totalBufferLength: LONG CARDINAL;	--added this to catch possible overflowsBEGIN ENABLE UNWIND => {IF myZone # NIL THEN  DeleteDataSegment[myZone];								  IF dcbTab # NIL THEN DeleteDataSegment[dcbSegment]};	firstBitPageDA: PAGE _ pageG.BitPage + firstVDA;	--assume a contiguous file for now	metaStat: MetaStat _ @ aqMetaStat;	buffLen: CARDINAL _ (1024*(((pageG.BitWc*bandWidth)+2 +1023)/1024));	buffLenInAltoPages: CARDINAL _ buffLen/256;	need: CARDINAL;	--# of pages needed in InsufficientVM signal.	--get enough room for 64 buffers of 1024 words each	dcbSegment _ NewDataSegment[DefaultBase, ((64*lKCB)/(PageSize))+1];	dcbTab _ DataSegmentAddress[dcbSegment];	nBufs _ 5;			--now get the scan buffers	IF ~debug THEN		{oldActive _ active^;		active^ _ BITAND[oldActive, BITNOT[parityInterruptBit]]};	totalBufferLength _ LONG[nBufs] * LONG[buffLen];	WHILE totalBufferLength > LONG[LAST[CARDINAL]] DO		nBufs _ nBufs - 1; totalBufferLength _ LONG[nBufs] * LONG[buffLen];		ENDLOOP; 	myZone _ NewDataSegment[DefaultBase, nBufs*buffLenInAltoPages!		InsufficientVM => {need _ needed;								IF (nBufs _ nBufs - 1) = 0 THEN CONTINUE ELSE RETRY}];	IF nBufs < 2 THEN		{active^ _ oldActive;		IF myZone # NIL THEN	  DeleteDataSegment[myZone];		 WriteLine["Not Enough Memory. Type any char to continue"L];		 []_ReadChar[];		RETURN;};	zoneBase _ DataSegmentAddress[myZone];--the microcode requires the bit array to begin on an even word boundary AND bit array[-1] must be available for linking the pointers.--Since MakeNode has a bookkeeping word at ptr-1, we must round up. Hence the +2 in the original calc.	buf _ firstBuf _ (IF BITAND[zoneBase, 1] THEN zoneBase+1 ELSE zoneBase + 2);	FOR i IN [0..nBufs)		DO			(buf-1)^ _ buf+buffLen;			buf _ buf+buffLen;		ENDLOOP;		(buf-(buffLen+1))^ _ firstBuf;	--backup to fix up last pointer & complete the ring.	DOz20496\229i41I188i34I169i46I4i49I127i26I679i239I197i52ISLOTPrint[disk, lastPage, pageG.FirstBand*bandWidth, pageG.BitMargin, pageG.BitWc*16, (pageG.LastBand-pageG.FirstBand+1)*bandWidth, bandWidth, firstBuf, firstBitPageDA, metaStat, dcbTab];	--print this page till it's printed without errors.z20496l4891d4256\188i	IF (~metaStat.ready AND (metaStat.wait OR metaStat.paperJam OR metaStat.paperOut OR metaStat.illegal OR metaStat.pageNotPrinted#0))z20496l4903d3633			THEN				{SLOTCommand[reset];	--only clear Slot Errors (not disk errors)				 SlotReady[metaStat];}			ELSE				EXIT;	ENDLOOP;	DeleteDataSegment[dcbSegment];	dcbTab _ NIL;	DeleteDataSegment[myZone];	myZone _ NIL;	IF ~debug THEN		{wakeupsWaiting^ _ BITAND[wakeupsWaiting^, BITNOT[parityInterruptBit]];		active^ _ oldActive;};END;--of UNWINDEND;--PSlotz20496\33i42I267i12I4i7I1bz20496SLOTPrint: PROC[disk: tfsdskPtr, lastPage: BOOLEAN, scanMargin, bitMargin, scanLength, numScans, scansPerBuffer: CARDINAL, firstBuf: POINTER, FirstDA: PAGE, metaStat: MetaStat, dcbTable: POINTER]=z20496l3633d2998\b9B{	i, timeOut: CARDINAL;		--i is used in two loops	dontUseTrident: BOOLEAN _ FALSE;	buf,  currentBuf: POINTER;	dcb: kcbPtr _ LOOPHOLE[dcbTable];				--used in first half of code and in inner loop	--dcbTable: POINTER;	labelBuf: ARRAY [0..10) OF WORD;	tridentStart: CARDINAL = 40B;	tridentStop: CARDINAL = 20B;	sCB:	SCB;	scb: POINTER TO SCB _ @sCB;	numWords: CARDINAL _ BITSHIFT[scanLength, -4]; 	sectorsPerBuffer: CARDINAL _ (scansPerBuffer * numWords+1023)/1024; --these vars were in PrintBuffer and ReadBuffer--	status: Status;	DCBseal: CARDINAL = 122645B;	startNext: kcbPtr _ NIL;	daPtr: POINTER TO DA;--vars that are needed by TfsRealDA replacement	nSectors: CARDINAL _ disk.tfskd.kdh.nSectors;	nHeads: CARDINAL _ disk.tfskd.kdh.nHeads;--	quotient: CARDINAL;--vars for timeout book keeping	subInterval, timeLeft: CARDINAL;	subIntervalSeconds: CARDINAL = 3;	subIntervalQuantum: CARDINAL = 78;	--3  * 26 * .039 = 3 seconds--local vars for printing	printCt, readCt: CARDINAL;--locals for readNext and printNext	pNext, rNext, kcbHead, newKcbTail, kcbTail: kcbPtr;--locals for reading trident	trackNum: INTEGER;	sector, head: INTEGER;	da _ FirstDA;	printCount _ readCount _ (numScans+scansPerBuffer-1)/scansPerBuffer;	scb _ SetSCB[scb];	--must init buf etc. here to avoid "warning: multiple initialization with a pointer"	scb.currentBuf _ scb.bufferPtr _ buf _  currentBuf _ firstBuf;	scb.com _ printCommand;	scb.lastPage _ IF lastPage THEN 1 ELSE 0;	scb.bitMargin _ bitMargin + SLOTBitMarginAdjust;	scb.scanLineWc _ BITSHIFT[scanLength, -5];--shift right 5 bits	scb.scanMargin _ scanMargin + SLOTScanMarginAdjust;	scb.scansPerPage _ numScans;	scb.scanLineWcInc _ numWords;	scb.scansPerBuff _ scansPerBuffer;	slotCommandBlock^ _ scb;								--give microcode the pointer, (uCode not running yet).	DO	readNext _ dcb;	FOR i IN [0..sectorsPerBuffer) DO		Zero[dcb, lKCB];		dcb.nextKCB _ dcb + lKCB;		dcb.blockH.comm _ diskCheck;		dcb.blockH.count _ 2;		dcb.blockH.addr _ LOOPHOLE[@dcb.diskAddress, dlPtr];	--disk label pointer		dcb.blockL.comm _ diskRead;		dcb.blockL.addr _ LOOPHOLE[@labelBuf, dlPtr];		dcb.blockL.count _ 10;		dcb.blockD.comm _ diskRead;		dcb.blockD.count _ TFSwordsPerPage;		dcb.blockD.addr _ (buf+i*TFSwordsPerPage);		dcb _ dcb.nextKCB;		ENDLOOP;	ReadBuffer[FALSE, sectorsPerBuffer, disk];	buf _ (buf-1)^;	IF buf = firstBuf THEN EXIT;	ENDLOOP;--buffers filled	--	(dcb-lKCB).nextKCB _ dcbTable;	dcb _ (dcb-lKCB);	dcb.nextKCB _ NIL;	kcbTail _ dcb;	readNext _ printNext _ dcbTable;	IF noDisplay THEN				{savedDisplay _ Display^;			 	DisplayOn _ FALSE;			 	Display^ _ 0;};	IF ~dontUseTrident THEN			{[] _ StartIO[tridentStart];			 track^ _ 177777B;			 statusptr^ _ Mstatus[1,1,1,1,1,1,1,1,1,1,1,1, 17B];			 ptr^ _ dcbTable;			};	pBufferCalls _ 0;	timeOut _ RTC^ + 5*27;						--give us 5 seconds to read disk--PrintBuffer will return true as soon as the first buffer is filled (with or w/o errors)	UNTIL PrintBuffer[sectorsPerBuffer] DO		pBufferCalls _ pBufferCalls + 1;		IF RTC^ >= timeOut THEN printFail _ (IF printNext = firstBuf THEN 1 ELSE 2);	ENDLOOP;	timeLeft _ SLOTTimeOut / subIntervalSeconds;				--# of sub intervals	overRun _ FALSE;	printCt _ printCount;		--get globals into locals for speed	readCt _ readCount;	pNext _ printNext;	kcbHead _ readNext;	trackNum _ gTrack; sector _ gSector; head _ gHead;	IF printFail = 0 THEN									--start the SLOT!		{IF useSLOT THEN			[]_StartIO[slotSIObit];		subInterval _ RTC^ + subIntervalQuantum;			--subIntervalSeconds  * 26 * .039 = 3 seconds		DO			IF scb.currentBuf # currentBuf THEN				--uCode started outputting next buf				{currentBuf _ scb.currentBuf;				-------------- ReadBuffer code ------------------------------------------------					rNext _ startNext _ kcbHead;					FOR i IN [1..sectorsPerBuffer] DO						daPtr _ LOOPHOLE[rNext];						-------------- ~TfsRealDA code ------------------------------------------------						IF (sector _ sector+1) > 8 THEN							{sector _ 0;							 IF (head _ head + 1) > 18 THEN								{head _ 0;								trackNum _ trackNum + 1;								};							};						daPtr^ _ DA[trackNum, head, sector];  --store the new values						-------------- End TfsRealDA code --------------------------------------------						rNext.blockD.status _ dstZeroStatus;						rNext.id _ DCBseal;						IF i=sectorsPerBuffer THEN							{kcbHead _ rNext.nextKCB;							 newKcbTail _ rNext;							 rNext.nextKCB _ NIL;							} ELSE							rNext _ rNext.nextKCB;					ENDLOOP;				--IF ptr^ = NIL THEN ptr^ _ startNext;					--seems I can eliminate the first test on IF ptr^ # 0, but will try it once.				IF ptr^ # NIL  THEN {kcbTail.nextKCB _ startNext; kcbTail _ newKcbTail;}							ELSE {kcbTail.nextKCB _ startNext; kcbTail _ newKcbTail};				IF ptr^ = NIL THEN ptr^ _ startNext;				-------------- End ReadBuffer code --------------------------------------------				};			IF scb.status # LOOPHOLE[0, ReturnStatus] THEN EXIT;			IF RTC^ > subInterval THEN				{IF (timeLeft _ timeLeft - 1) = 0 THEN {printFail _ 3; EXIT}  ELSE subInterval _ RTC^ + subIntervalQuantum};		ENDLOOP;												--DO above IF scb.currentBuf #		};														--IF printFail = 0 THEN	ptr^ _ NIL;														--quiet disk	IF ~DisplayOn THEN		{Display^ _ savedDisplay;		 DisplayOn _ TRUE;		};	SlotStatus[metaStat];											--return final status	IF lastPage THEN {MsWait[6000]; SLOTCommand[reset];};	--CallDebugger["check scb for uCode Status"L];};--SLOTPrintz20496e6\25i24I101i46I1i22I256i46I98i48I91i23I3i30I105i28I1i27I28i37I54i27I152i35I277i6I5i7I185i54I215i20I349i16I3i34I391i37I4i87I217i19I42i35I147i17I92i2I18i25I49i35I523i22I336i42I2i81I142i4I36i1I300i42I5i37I1i1I12i26I1i1I73i1I30i23I107i11Iz20496e6PrintBuffer: PROC[sectorsPerBuffer: CARDINAL] RETURNS[ok: BOOLEAN _ TRUE]={	i: CARDINAL;	dcb: kcbPtr _ printNext;	status: Status;	IF printCount = 0 THEN RETURN;	FOR i IN [1..sectorsPerBuffer] DO		IF dcb.blockD.status = dstZeroStatus THEN {overRun _ TRUE; RETURN [FALSE];};		status _ BITOR[BITOR[dcb.blockH.status, dcb.blockD.status], dcb.blockL.status];		IF status # dstDone THEN			readErrors _ readErrors + 1;		dcb _ dcb.nextKCB;	ENDLOOP;	printCount _ printCount - 1;	printNext _ dcb;};--PrintBufferReadBuffer: PROC[startUp: BOOLEAN, sectorsPerBuffer: CARDINAL, disk: tfsdskPtr ]={	i: CARDINAL;	DCBseal: CARDINAL = 122645B;	startNext: kcbPtr _ readNext;	daPtr: POINTER TO DA;	readCount _ readCount - 1;	FOR i IN [1..sectorsPerBuffer] DO		daPtr _ LOOPHOLE[readNext];		daPtr^ _ TfsRealDA[disk, da];	--returns a DA record (2 words)		da _ da + 1;		readNext.blockD.status _ dstZeroStatus;		readNext.id _ DCBseal;		readNext _ readNext.nextKCB;	ENDLOOP;	gTrack _ daPtr.track; gSector _ daPtr.sector; gHead _ daPtr.head;	IF startUp AND ptr^ = NIL THEN ptr^ _ startNext;};--ReadBufferSetSCB: PROC[scb: POINTER TO SCB] RETURNS[newSCBadr: POINTER TO SCB]={	Zero[scb, SIZE[SCB]];	newSCBadr _ Even[scb];	newSCBadr.invert _ IF invertMode THEN 1 ELSE 0;	newSCBadr.bitsPerLine _ SLOTScanLength;	newSCBadr.blowup _ IF SLOTDouble=0 THEN 0 ELSE 1;};--SetSCBz20496e6\b12B491i13bI12B297i31I244i13I1b6B255i8IEND.--PrintSlot-- Last Edited:  September 15, 1981  6:19 PM  By:  GWilliams z20496e1(1792)\4i--noDisplay=FALSE (i.e., leave it on) and useSlot=FALSE, debug=FALSE(do timeouts)z20496e1--October 26, 1981  2:36 PM  By:  GWilliams z20496e1\i--cause PSlot to clear disk errors (& print a goofed-up page) a few times before erroring.-- Last Edited:  October 27, 1981  1:32 PM  By:  GWilliams z20496e1\i--SLOTPrint runs too slow dat 384 spi. Put PrintBuffer and ReadBuffer inline in inner loop-- Last Edited:  October 28, 1981  11:34 AM  By:  GWilliams z20496e1\i--a 4K buffer load is dropped sporatically, added one line in inner loop to zero status on dequeing (@inline PrintBuffer code). This is to observe it.-- Last Edited:  October 28, 1981  3:01 PM  By:  GWilliams z20496e1\i--moved printCount test to bottom of PrintBuffer routine..-- Last Edited:  October 29, 1981  9:38 AM  By:  GWilliams z20496e1\i--Added code to see whether uCode is getting two buffers ahead.-- Last Edited:  October 30, 1981  5:16 PM  By:  GWilliams z20496e1\i--Added code to allow me to set # of buffers in PSlot for debugging.-- Last Edited:  November 4, 1981  11:10 AM  By:  GWilliams z20496e1\i--Changed calculation of buffLen to include the +2 inside brackets.--also now allocate the dcbTable at PSlot instead of SLOTPrint to make sure there's space for it.-- Last Edited:  November 10, 1981  2:17 PM  By:  GWilliams z20496e1\i--New amalgam that asks for two buffers only and doesn't get storage for the dcbs from local frame.-- Last Edited:  November 11, 1981  2:11 PM  By:  GWilliams z20496e1\i--changed def of SCB to allow for change in uCode to have 64K bits per scan line.-- Last Edited:  December 3, 1981  11:42 AM  By:  GWilliams z20496e1\i--Used PrintSlot of Nov 81 but plugged in the original SCB def.-- Last Edited:  January 14, 1982  4:14 PM  By:  GWilliams z20496e1\i--The plate maket needs extremely long timeouts, whereas a fast device needs relatively short ones. The RTC wraps around at 40 minute intervals. I changed the code to minimize false timeouts caused by adding large numbers to the RTC value when it is near wrap-around state.-- Last Edited:  January 15, 1982  2:49 PM  By:  GWilliams z20496e1\i--This is a speed-up attempt on PrintSlotGary: copy globals into local frame.-- Last Edited:  January 26, 1982  11:47 AM  By:  GWilliams z20496e1\i--Last attempt to speed up process didn't work. Seem not to be setting the dcb's correctly. This is an experiment to see whether it is only the dropping of the MOD's and /'s, or whether it was a bug introduced elsewhere. In other words, I'm changing back to using the MOD's and /'s, but leaving all other code that was changed, in.-- Last Edited:  January 26, 1982  1:55 PM  By:  GWilliams z20496e1\i--OK, this one should work, no MOD's or /'s.-- Last Edited:  January 27, 1982  10:46 AM  By:  GWilliams z20496e1\i--The code works ok, but didn't fix the problem. This version tries a new scheme with running the disk.-- Last Edited:  January 27, 1982  10:46 AM  By:  GWilliams z20496e1\i--Added more buffers in case we've run out.-- Last Edited:  January 27, 1982  10:46 AM  By:  GWilliams z20496e1\i--Adding more buffers didn't help. Try waiting for the disk to be idle.-- Last Edited:  January 27, 1982  1:10 PM  By:  GWilliams z20496e1\i-- Last Edited:  January 28, 1982  2:34 PM  By:  GWilliams z20496e1\i--Turns out this version doesn't work. There is a race in the original coding of the BCPL version of this code that I hope to rectify. Briefly, the trident controller should not be run with rings of control blocks.-- Last Edited:  February 19, 1982  11:13 AM  By:  GWilliams z20496e1\i--Running the Trident with lists rather than a ring wins.--Adding fix to get some space in PSlot that I know I'll need in SLOTPrint before getting the buffers.-- Last Edited:  February 19, 1982  3:41 PM  By:  GWilliams z20496e1\i--added totalBufferLength to PSlot to guard against overflows-- Last Edited:  March 3, 1982  12:06 PM  By:  GWilliams z20496e1\i--Changed Slot Ready and PrintError to report all errors, not just the first encountered.-- Last Edited:  April 12, 1982  1:05 PM  By:  GWilliams z20496e1\i--Made calculations with nBufs LONG in PSlot.(635)\i31I4i