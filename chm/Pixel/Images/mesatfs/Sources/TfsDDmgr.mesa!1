--Last edited on June 1, 1982  4:00 PM by GWiliams--store segment handle in ddMgr object now--	A DDMgr is an object for managing pages of the DiskDescriptor (DD) files--	on one or more disks.  The default one is created by calling:--	ddMgr _ TFSCreateDDMgr[]DIRECTORYMiscDefs: FROM "miscdefs" USING [Zero],(448)\51i43ISegmentDefs USING [NewDataSegment, DefaultBase, DeleteDataSegment, SegmentAddress],l3633d2998SystemDefs: FROM "systemdefs" USING [AllocateHeapNode, FreeHeapNode],TridentDefs: FROM "tridentdefs";--A DDMgr is an object for managing pages of the DiskDescriptor (DD) files-- on one or more disks.  The default one is created by calling:--	ddMgr _ TFSCreateDDMgr[zone]-- Thereafter, the following operations are defined on it:--	OpenDD[ddMgr, disk]--		Adds disk to the set of DDs managed by ddMgr.--	LockDD[ddMgr, disk]--		Locks out all other access to the DD on the specified disk.--	buf = ReadDDPage[ddMgr, disk, page]--		Returns a pointer to a copy (in memory) of the specified--		DD page on the specified disk.  The TFSKD is in page 1--		and the bit map is in pages 2 through n (n is at most 5).--		Guarantees that buf will not move until either the next--		ReadDDPage or UnlockDD.  The DD must be locked.--	UnlockDD[ddMgr, disk, na, dirty ]--		Unlocks a DD previously locked.  If dirty is true, marks--		as dirty the page most recently read by ReadDDPage.--	FlushDD[ddMgr, disk]--		Flush any dirty DD pages out to the specified disk.--		The DD must NOT be locked.--	CloseDD[ddMgr, disk]--		Removes disk from the set of DDs managed by ddMgr.--		It is the caller's responsibility to do a FlushDD first.--	DestroyDDMgr[ddMgr]--		Destroys ddMgr.TfsDDmgr: PROGRAMIMPORTS MiscDefs, SegmentDefs, SystemDefs, TridentDefsEXPORTS TridentDefs =BEGIN OPEN SegmentDefs, SystemDefs, TridentDefs;TfsCreateDDmgr: PUBLIC PROCEDURE [] RETURNS [ddMgr: ddMgrPtr] =-- This implementation of the DDMgr has the following properties:-- (1) One page is permanently allocated to serve as a buffer for all DDs.-- (2) There is only a single lock for the entire DDMgr, not one per DD.-- (3) A dirty page is written out only if (a) the buffer is needed for--     another DD page, or (b) an explicit FlushDD is done.BEGIN	ddMgr _ AllocateHeapNode[lDDmgr];						-- allocate storage for the manager	MiscDefs.Zero[ddMgr, lDDmgr];								-- clear it	ddMgr.OpenDD _ Noop;	ddMgr.LockDD _ TfsLockDD;										-- store the procedures	ddMgr.ReadDDPage _ TfsReadDDPage;	ddMgr.UnlockDD _ TfsUnlockDD;	ddMgr.FlushDD _ TfsFlushDD;	ddMgr.CloseDD _ TfsCloseDD;	ddMgr.DestroyDDMgr _ TfsDestroyDDMgr;--	ddMgr.buffer _ AllocateHeapNode[TFSwordsPerPage];--get 1K words w/no overhead 	ddMgr.bufferSegment _SegmentDefs.NewDataSegment[DefaultBase, 4]; 	ddMgr.buffer _ SegmentDefs.SegmentAddress[ddMgr.bufferSegment];	ddMgr.zone _ NIL;														-- not needed?	ddMgr.locked _ FALSE;	ddMgr.dirty _ FALSE;	ddMgr.disk _ NIL;								-- This is a closeDD	RETURN [ddMgr];END;															-- of TfsCreateDDMgr\2b8B138b14B775i81I24f1 12f0 49f1 12f0TfsLockDD: PUBLIC PROCEDURE [ddMgr: ddMgrPtr, disk: tfsdskPtr] =-- Allow only single thread use of the DDBEGIN	WHILE ddMgr.locked DO NULL ENDLOOP;			-- wait until it's free	ddMgr.locked _ TRUE;										-- lock it for our own useEND;															-- of TfsLockDD\2b9BTfsReadDDPage: PUBLIC PROCEDURE [ddMgr: ddMgrPtr, disk: tfsdskPtr, page: INTEGER] RETURNS [buffer: POINTER] =-- If the disk or page number is not current then read it into buffer (writing current page if it's dirty).BEGIN	IF disk # ddMgr.disk OR page # ddMgr.page THEN	BEGIN		IF ddMgr.dirty THEN TransferDDPage[ddMgr, dcWriteD];		ddMgr.disk _ disk;		ddMgr.page _ page;		TransferDDPage[ddMgr, dcReadLD];					-- read in the bit map	END;	RETURN [ddMgr.buffer];END;															-- of TfsReadDDPage\3b13BTfsUnlockDD: PUBLIC PROCEDURE [ddMgr: ddMgrPtr, disk: tfsdskPtr, dirty: BOOLEAN] =-- Unlock the DD and optionally set it dirty regardless of it stateBEGIN	IF dirty THEN ddMgr.dirty _ TRUE;		-- dirty was optional arg	ddMgr.locked _ FALSE;END;															-- of TfsUnlockDD\2b11BTfsFlushDD: PUBLIC PROCEDURE [ddMgr: ddMgrPtr, disk: tfsdskPtr] = -- Write the bit map if its dirtyBEGIN	TfsLockDD[ddMgr, disk];						-- lock the DD	IF ddMgr.dirty THEN TransferDDPage[ddMgr, dcWriteD];	TfsUnlockDD[ddMgr, disk, FALSE];END;															-- of TfsFlushDD\2b10BTfsCloseDD: PUBLIC PROCEDURE [ddMgr: ddMgrPtr, disk: tfsdskPtr] =-- If we're on the right disk, close itBEGIN	IF ddMgr.disk = disk THEN ddMgr.disk _ NIL;END;															-- of TfsCloseDD\2b10BTfsDestroyDDMgr: PUBLIC PROCEDURE [ddMgr: ddMgrPtr] =-- free the storage for the bitmap's buffer, then free the storage for the mgr itselfBEGIN--	FreeHeapNode[ddMgr.buffer];	SegmentDefs.DeleteDataSegment[ddMgr.bufferSegment];	FreeHeapNode[ddMgr];END;															-- of TfsDestroyDDMgr\2b15B133i31I1f1 12f0Noop: PROCEDURE [ptr: POINTER] RETURNS [ddMgr: ddMgrPtr] =-- Dummy proc (but it works)BEGINEND;															-- of Noop\2b4BTransferDDPage: PROCEDURE[ddMgr: ddMgrPtr, action: CARDINAL] =-- prepare a call to TfsActOnPages to read or write the bitmapBEGIN	numChars, page, i: INTEGER;	numcharsPtr: POINTER;	disk: tfsdskPtr;	fpTfsDD: FP;	caS: DESCRIPTOR FOR ARRAY OF POINTER;	daS: DESCRIPTOR FOR ARRAY OF PAGE;	pages: ARRAY [0..6) OF PAGE;						--ARRAY of vDA	numChars _ 2048;	numcharsPtr _ @numChars;	page _ ddMgr.page;	disk _ ddMgr.disk;-- Build an array of disk addresses for the disk descriptor	FOR i IN [0..lTfsBT] DO--		pages[i] _ disk.tfskd.vdadiskDD[i+1];			---- vDA's of DD		pages[i+1] _ disk.tfskd.vdadiskDD[i+1];			-- vDA's of DD	ENDLOOP;	--change necessary because TfsActOnPages uses page as an index	daS _ DESCRIPTOR[@pages, lTfsBT+1];-- FP for the disk descriptor	fpTfsDD _ disk.dsk.fpDiskDescriptor^;	IF page <= 0 OR page >= lTfsDDPreamble + lTfsBT THEN ERROR BadBitMapPage;	ddMgr.dirty _ FALSE;						-- page will be clean if reading or writing	[] _ TfsActOnPages[disk, caS, daS, fpTfsDD, page, page, action, numcharsPtr, action, ddMgr.buffer, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, FALSE, page];END; \2b14B631i62IBadBitMapPage: PUBLIC ERROR = CODE;			-- erroneous bitmap disk addressEND.														-- of TfsDDMgr\3b13B--Last edited on September 1, 1981  2:17 PM by GWiliams--changed ddMgr.buffer to get a large segment rather than allocate from heap--changed TransferDDPage\56i102I