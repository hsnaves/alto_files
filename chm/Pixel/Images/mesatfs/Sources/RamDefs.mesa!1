-- RamDefs.mesa  Last Edited by Johnsson, May 21, 1980  11:04 AMDIRECTORY  PrivateRamDefs;RamDefs: DEFINITIONS =  BEGIN    BootLocusVector: TYPE = PrivateRamDefs.BootLocusVector;    MuImage: TYPE = POINTER TO PrivateRamDefs.PackedMuFile;    LoadRamAndBoot: PROCEDURE [m: MuImage, boot: BOOLEAN _ FALSE, bank: [0..2] _ 0]    RETURNS [constDiffs: CARDINAL];    -- loads the ram from the MuImage, checks the constants and returns number of constant mismatches.  If boot=TRUE, also does a silent boot: first, a silent boot is done to guarantee that the machine is in ground state (everything running in ROM0 - ok for Mesa?) and then, after loading the ram image, another silent boot is done as specified in the blv field of the MuImage.      ReadBlv: PROCEDURE [m: MuImage] RETURNS [BootLocusVector];    NoEtherNetBoard: ERROR;    SilentBoot: PROCEDURE [blv: BootLocusVector];    -- check to see that a silent boot is possible (I.e., that Alto has an EtherNet board), sets boot locus vector and does the StartIO to cause a silent boot.      StartIO: PROCEDURE [ac0: UNSPECIFIED] RETURNS [fromAc0: CARDINAL];    -- Do an SIO with ac0 passed in the Alto AC0.    MuFileAlreadyOpen: ERROR;    SuspiciousPackedMuFile: ERROR;    ReadPackedMuFile: PROCEDURE [name: STRING] RETURNS [theImage: MuImage];    -- Read and swap in a Packed Mu file and check it to increase our confidence that it is a valid MuImage as prepared by the program PackMu.Run.      ReleaseMuImage: PROCEDURE [theImage: MuImage];    -- Release the FileHandle for the current packed MuImage.  IF muSeg#NIL, then swap it out first and get rid of the segment.  Then release the file.      END...