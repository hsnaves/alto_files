--Last changed on June 1, 1982  3:54 PM By Glen Williams--added bufferSegment to DDmgr definition--added another errorDIRECTORY	AltoFileDefs USING [TIME],	SegmentDefs USING [DataSegmentHandle],	StringDefs USING [BcplSTRING];l2999(0,3392)(1,2528)(2,2944)\59i41I2i19ITridentDefs: DEFINITIONS =BEGIN OPEN StringDefs, AltoFileDefs; l2999-- Ram StufftridentMask: CARDINAL = 077766B;			-- Trident microcode in RamnormalMask: CARDINAL = 177776B;			-- back to normall2999(3,5120)\b4B9b1BopenMode: TYPE = {read, create};	--for use by TfsOpenFile-- TFS files		(see Tfs.D)TFSmNDisks: CARDINAL = 1;					-- possible number of disks per bit tableTFSmNTracks: CARDINAL = 815;				-- Number of tracks or cylinders per diskT300mNVTracks: CARDINAL = 383;			-- max tracks for T300 using virtual																	-- disk addressesT80mNHeads: CARDINAL = 5;					-- number of heads, T80T300mNHeads: CARDINAL = 19;				-- number of heads, T300TFSmNSectors: CARDINAL = 9;				-- number of sectors (per track)TFSwordsPerPage: CARDINAL = 1024;				-- words in data block of a sectorPageNum: TYPE = CARDINAL [0..4);WordNumInPage: TYPE = CARDINAL [0..TFSwordsPerPage);PageAndWord: TYPE = CARDINAL[0..4096);TFSlnWordsPerPage: CARDINAL = 10;				-- power of 2 words per pageBitPos: TYPE = CARDINAL [0..16);-- Maximum virtual pages in a file systemT80mNVPages: CARDINAL = TFSmNTracks*T80mNHeads*TFSmNSectors;T300mNVPages: CARDINAL = T300mNVTracks*T300mNHeads*TFSmNSectors;PAGE: TYPE = CARDINAL;									-- CARDINAL plus 2 negativeseofDA: CARDINAL = LAST[CARDINAL];				-- End of File fillInDA: CARDINAL = LAST[CARDINAL]-1;	-- Unknown DiskAddress (DA)-- Bit Table DefinitionslTfsDDPreamble: CARDINAL = 2;			-- Number of pages in DD ahead of BTlTfsBT: CARDINAL = 4;						-- [(T300mNVPages-1) / 2**14] + 1--lTfsBT: CARDINAL = 3;						---- [(T300mNVPages-1) / 2**14] + 1							--the BCPL version comes up with 3l2999\34i24IVDA: TYPE = MACHINE DEPENDENT RECORD			-- virtual disk address	[																			SELECT OVERLAID * FROM		pAndW => 		[pageAndWord: PageAndWord, bitNum: BitPos],		wordNum => 	[pageNum: PageNum,						wordNumInPage: WordNumInPage,						bitPos: BitPos],		ENDCASE];--VDA: TYPE = MACHINE DEPENDENT RECORD			---- virtual disk address--	[																		--	pageNum: [0..3],											---- 2 bits: 12-TfslnWordsPerPage--	wordNum: [0..TFSwordsPerPage),				---- 10 bits: TfslnWordsPerPage--	bitNum:  [0..16)											---- 4 bits: bit number in a word--	];l2999\273i39I4i21I3i20I3i28I4i29I3i35I4i27I3i28I4i29I3i-- variablestfsLock: BOOLEAN;									-- forces (at times) single use of diskl2999-- constantsDAstart: POINTER = LOOPHOLE[420B];				-- Display locationRTC: POINTER TO INTEGER = LOOPHOLE[430B];		-- Real Time ClockpackID: CARDINAL = 0;										-- part of FIDmaxLengthFn: CARDINAL = 39;							-- all OS routines (see altofilesys.d)maxLengthFnInWords: CARDINAL = 20;				-- enough for final "."l2999-- Miscellaneous Data TypesRight: INTEGER = -1;		-- for shiftingLeft: INTEGER = 1;BIT: TYPE = [0..1];BYTE: TYPE = [0..377B];--OneBitArray: TYPE=DESCRIPTOR FOR ARRAY[0..15] OF WORD;OneBitArray: TYPE=DESCRIPTOR FOR ARRAY OF WORD;oneBits: PUBLIC DESCRIPTOR FOR ARRAY OF WORD;AltoType: TYPE = {altoI, altoII, d0};RealTime: TYPE = MACHINE DEPENDENT RECORD [		    high: WORD,    rest: SELECT COMPUTED AltoType FROM      altoI => [low:[0..1777B], fill: [0..77B]],      altoII => [fill1: [0..17B], low: [0..1777B], fill2: [0..3B]],      d0 => [low:[0..1777B], fill: [0..77B]], -- version 3.0      ENDCASE];-- error codesecOsVersion: 				CARDINAL = 2403;ecTfsQueue: 					CARDINAL = 2404;ecNoCreationAbility: CARDINAL = 2405;ecBadAction: 				CARDINAL = 2406;ecBadBtPage: 				CARDINAL = 2407;ecEssentialFile: 		CARDINAL = 2408;ecBadAssignPage: 		CARDINAL = 2409;ecReadOnly:					CARDINAL = 2410;ecDriveHung:					CARDINAL = 2411;ecUnRecovDiskError:	CARDINAL = 2412;ecDiskFull:					CARDINAL = 2413;l2999\322f6 2f0-- Trident hardware related definitions		(see Tfs.D)dcbID: WORD = 122645B;								-- disk command seal-- mask bits for status wordl2999(3,65535)dstRestoreBits: Status = 	[1,1,1,0,0,0,0,0,0,1,0,0,0,0];  --160100BdstErrorBits: Status = 	[1,1,1,1,1,1,1,1,1,1,0,0,1,0]; --177717B; ignore readonly and offset;dstDataLate: Status = 	[0,0,0,0,0,0,0,1,1,0,0,0,0,0]; --600B; last zero is 3 bits widedstCompErr: Status =	[0,0,0,0,0,0,0,0,0,1,0,0,0,0] ;  --100B;dstECCerror: Status =	[0,0,0,0,0,0,0,0,0,0,0,0,1,0] ;--  10B;dstForgotten: Status =	[0,0,0,0,0,0,0,0,0,0,0,0,0,4] ;--  4B;dstTimeout: Status =	[0,0,0,0,0,0,0,0,0,0,0,0,0,2] ;--  2B;dstDone: Status = 	[0,0,0,0,0,0,0,0,0,0,0,0,0,1];--  1B;l2999(1,9088)\58i9I54i41I52i34I52i11I52i10I53i9I51i9I48i-- status word valuesdstErrors: WORD = 177716B;		-- all errors ; ignore ReadOnly and OffsetdstRetryIndefinitely: WORD = 604B;	-- retry these errors without counting them-- Status word valuesdstFree: Status =  [1,1,1,1,1,1,1,1,1,1,1,1,1,7];		-- denotes free CB; set by software--dstFreeStatus: Status = [0,0,0,0,0,0,0,0,0,0,0,0,1,7]; dstZeroStatus: Status = [0,0,0,0,0,0,0,0,0,0,0,0,0,0];dstGoodStatus: Status = [0,0,0,0,0,0,0,0,0,0,0,0,0,1];	-- set after good xferdstBadStatus: Status  = [0,0,0,0,0,0,0,0,0,0,0,0,0,3];dstMinusStatus: Mstatus = [1,1,1,1,1,1,1,1,1,1,1,1,17B];	-- used in TfsStart-- hardware commands, bit assignmentscheckData: WORD = 4000B;writeBit: WORD = 200B;readBit: WORD = 100B;headSelect: WORD = 4;reZero: WORD = 12B;checkReset: WORD = 10B;-- disk hardware commands (see above)		(see Tfs.D)diskRead: WORD = readBit + headSelect;diskWrite: WORD = writeBit + headSelect;diskCheck: WORD = checkData + readBit + headSelect;diskReset: WORD = checkReset;diskRestore: WORD = reZero;diskNoop: WORD = headSelect;-- special constants (see Disks.d, July 13, 1979)diskMagic: WORD = 153000B;		-- "magic" bits to avoid accidents?dcReadHLD: CARDINAL = 0 + diskMagic;	-- Read header, label, datadcReadLD: CARDINAL = 1 + diskMagic;	-- Read label, datadcReadD: CARDINAL = 2 + diskMagic;	-- Read datadcWriteHLD: CARDINAL = 3 + diskMagic;	-- Write header, label, datadcWriteLD: CARDINAL = 4 + diskMagic;	-- Write label, datadcWriteD: CARDINAL = 5 + diskMagic;	-- Write datadcSeekOnly: CARDINAL = 6 + diskMagic;	-- Just seek to spotdcDoNothing: CARDINAL = 7 + diskMagic;	-- No-opdcReadLnD: CARDINAL = 8 + diskMagic;	-- Check header,read label, no datadcReadnD: CARDINAL = 9 + diskMagic;	-- Check header,check label, no datadcWriteLnD: CARDINAL = 10 + diskMagic;	-- Check header, writelabel, no datal2999(1,2528)\174i23I-- Valid combinations of commandsComTable: TYPE = ARRAY [0..10] OF CARDINAL;		-- command tableheaderComds: ComTable = [diskRead, diskCheck, diskCheck, diskWrite, diskCheck, diskCheck, diskNoop, diskNoop, diskCheck, diskCheck, diskCheck];labelComds: ComTable = [diskRead, diskRead, diskCheck, diskWrite, diskWrite, diskCheck, diskNoop, diskNoop, diskRead, diskCheck, diskWrite];dataComds: ComTable = [diskRead, diskRead, diskRead, diskWrite, diskWrite, diskWrite, 0, 0, 0, 0, 0];l2999(3,5120) l2999-- Status bits		(see Tfs.D)Status: TYPE = MACHINE DEPENDENT RECORD	[							-- 12 bits of status plus sector number	seekInc:	BIT _ 0,					-- this needs a restore	headError: BIT _ 0,			-- head must be 0 - 4 or 0 - 18 (T300)	deviceCk: BIT _ 0,				-- many possibilities, see hdw manual	notSelected: BIT _ 0,		-- 1 => powered off or offline	notOnline: BIT _ 0,			-- 1 => test mode or heads not loaded	notReady: BIT _ 0,				-- 1 => 	heads not loaded while seeking	secOvfl:	BIT _ 0,					-- write was in progress at sector pulse	wrLate:	BIT _ 0,					-- mcode didn't run soon enough	rdLate:	BIT _ 0,					-- ditto	compError: BIT _ 0,			-- command failed due to check error	readOnly: BIT _ 0,				-- drive's read only switch is on	offSet:	BIT _ 0,					-- head offset in effect	eccError: BIT _ 0,			-- sector is reported only in 643, eccError only in CB	bit3: [0..7] _ 0	];l2999Mstatus: TYPE = MACHINE DEPENDENT RECORD	[							-- status pointed to by 643	seekInc:	BIT _ 0,					-- this needs a restore	headError: BIT _ 0,			-- head must be 0 - 4 or 0 - 18 (T300)	deviceCk: BIT _ 0,				-- many possibilities, see hdw manual	notSelected: BIT _ 0,		-- 1 => powered off or offline	notOnline: BIT _ 0,			-- 1 => test mode or heads not loaded	notReady: BIT _ 0,				-- 1 => 	heads not loaded while seeking	secOvfl:	BIT _ 0,					-- write was in progress at sector pulse	wrLate:	BIT _ 0,					-- mcode didn't run soon enough	rdLate:	BIT _ 0,					-- ditto	compError: BIT _ 0,			-- command failed due to check error	readOnly: BIT _ 0,				-- drive's read only switch is on	offSet:	BIT _ 0,					-- head offset in effect	sector: [0..17B] _ 0			-- sector is reported only in 643, eccError only in CB	];l2999-- Trident Control Block Format		(see Tfs.D)-- See [ERIE]<Blanchard>Trident>AltoLoc.drawl2999ptr: POINTER TO POINTER = LOOPHOLE[640B];drive: POINTER TO INTEGER = LOOPHOLE[641B];track: POINTER = LOOPHOLE[642B];statusptr: POINTER TO Mstatus = LOOPHOLE[643B];abort: POINTER = LOOPHOLE[644B]; l2999(3,65535)-- Header, label formats on disk		(see Tfs.D)DA: TYPE = MACHINE DEPENDENT RECORD  [						-- hardware disk address  track: INTEGER,		-- [0..814],  not CARDINAL due to TfsDoRecovery  head: BYTE,				-- [0..4] for T80, [0..18] for T300  sector: BYTE			-- [0..9]  ];dAPtr: TYPE = POINTER TO DA;l2999-- Disk header, must be the same as disk address-- See [ERIE]<Blanchard>Trident>DL.drawDH: TYPE = MACHINE DEPENDENT RECORD  [	   track: INTEGER,  head: BYTE,  sector: BYTE  ];lDH: CARDINAL = SIZE[DH];-- Disk label, forms a linked list of sectors (forward and back)-- See [ERIE]<Blanchard>Trident>DL.drawl2999DL: TYPE = MACHINE DEPENDENT RECORD	[		--The last two words must be the next sector address in DH 				-- format (for chaining). *=set by DoDiskCommand				-- # = constant for all pages	fileID: ARRAY[0..lFID) OF WORD,	-- #*	packID: WORD,									-- #*	numChars: CARDINAL,						-- between 0 and charsPerPage inclusive														-- NE charsPerPage on last page only	pageNumber: CARDINAL,					--* page number in file of this page	previous: DA,									-- DA of previous file page or eofDA	next: DA												-- DA of next file page, or eofDA	];lDL: CARDINAL = SIZE[DL];dlPtr: TYPE = POINTER TO DL;l2999-- Disk command block, one of these is used for each sector transfer-- See [ERIE]<Blanchard>Trident>KCB.drawKCB: TYPE = MACHINE DEPENDENT RECORD		-- (see Tfs.D)	[	diskAddress: DA,										-- cylinder, head, sector(2 words)	drive: CARDINAL,	nextKCB: kcbPtr,										-- pointer to next command(for chaining)	id: CARDINAL,											-- seal, init to 122645B										-- following are command blocks for header, label, data	blockH: KCBblock,				-- HEADER	blockL: KCBblock,				-- LABEL	blockD: KCBblock,				-- DATA	endWord: WORD,									-- zero => end of command block	blank: WORD,										-- interrupt bits?	normalWakeups: WORD,	errorWakeups: WORD	];lKCB: CARDINAL = SIZE[KCB];kcbPtr: TYPE = POINTER TO KCB;	l2999-- Command format for each block within a sector.  Used to fill in a CB.-- Used during error recovery for single-block I/O.-- See [ERIE]<Blanchard>Trident>KCB.drawKCBblock: TYPE = MACHINE DEPENDENT RECORD	-- (see Tfs.D)	[	comm: WORD,											-- command	count: CARDINAL,									-- word count to transfer	addr: dlPtr,										-- pointer to memory	ecc0, ecc1: CARDINAL,						-- error correcting code	status: Status										-- status bits (1 word)	];kcblockPtr: TYPE = POINTER TO KCBblock;lKCBblock: CARDINAL = SIZE[KCBblock];l2999l2999-- Command buffer zone: format of a zone used to transfer disk sectors:-- 1 or more.-- * means the field is initialized by InitializeCBStorage; everything else is 		zeroed.-- See [ERIE]<Blanchard>Trident>CBZ.drawCBZ: TYPE = MACHINE DEPENDENT RECORD -- (see Disks.d, July 13, 1979)	[		length: CARDINAL,								-- * length (including CBs) of CBZ	disk: tfsdskPtr,										-- * pointer to disk object (DSK)	daS:DESCRIPTOR FOR ARRAY OF PAGE,		cleanupRoutine: CleanUpRoutType,	-- * either user's or a default	currentPage: INTEGER,						-- * set only by InitializeCBStorage	nextDA: PAGE,									-- set by GetCb upon normal command completion 	errorDA: PAGE,									-- set by GetCb on error(synonym)	errorRtn: ErrorRoutType,					-- * either user's or a default (ERROR)	retry: RetryType,								-- * 	currentNumChars: CARDINAL,	normalWakeups: POINTER,	errorWakeups: POINTER,	errorCount: CARDINAL,	queueHead: POINTER,						-- * points to head for backward compatibility	head: cbPtr,										-- * points to 1st CB on queue (0 => empty)	tail: cbPtr										-- * points to last CB on queue	-- cbS: ARRAY [0..0) OF CB	  			as many CBs as will fit start here	];cbzPtr: TYPE = POINTER TO CBZ;		-- just pointer isn't good enoughlCBZ: CARDINAL = SIZE[CBZ];cbZoneLength: CARDINAL = lCBZ + 6*lCB;			-- 6 CB's needed to run at disk speedErrorRoutType: TYPE = PROCEDURE [addr: POINTER, arg: UNSPECIFIED, ec: CARDINAL];CleanUpRoutType: TYPE = PROCEDURE [disk: tfsdskPtr, cb: cbPtr, cbz: cbzPtr];-- NOTE: The CBZ has been changed so that retry is a SIGNAL type instead of an address to GOTOl2999-- TFS specialization of the disk CBZ,  NOT USED for now (September 14, 1979)TFSCBZ: TYPE = MACHINE DEPENDENT RECORD	[	cbZ: CBZ,											-- standard part of CBZ	cbS: ARRAY [0..0) OF WORD			-- as many CBs as will fit here	];tfscbzPtr: TYPE = POINTER TO TFSCBZ;l2999-- Each CBZ contains a CB for each possible transfer enqueued.  The label must come first followed by the KCB (for chaining).  A free CB must have status = DSTfreeStatus (initialization does that).  * = initialized by InitializeCbStorage; everything else is zeroed.-- See [ERIE]<Blanchard>Trident>CB.drawCB: TYPE = MACHINE DEPENDENT RECORD		-- (see TFS.d) 	[	label: DL,											-- label (10 words)	kcb: KCB,											-- hardware control block (27 words)	truePageNumber: INTEGER,				-- variable part of CB ends here														-- remaining words not zeroed by TfsGetCB	cbz: cbzPtr,										-- * pointer to owning CBZ	vDiskAddress: PAGE,						-- VDA for this transfer (offset = 38)	nextCB: cbPtr									-- * pointer to next CB on queue 	];lCB: CARDINAL = SIZE[CB];					-- length of CB;lVarCb: CARDINAL = lDL+lKCB+1;		-- this is the offset to the CBZ pointercbPtr: TYPE = POINTER TO CB;l2999KDH: TYPE = MACHINE DEPENDENT RECORD	-- (see AltoFileSys.d)	[	nDisks: CARDINAL,								-- Number of disks 	nTracks: CARDINAL,								-- Number of tracks 	nHeads: CARDINAL,								-- Number of heads 	nSectors: CARDINAL,							-- Number of sectors	lastSn: SN,											-- last serial number used on disk	bitTableChanged: WORD,						-- true if bit table currently invalid	diskBTsize: CARDINAL,						-- Number of valid words in disk bit table	defaultVersionsKept: CARDINAL,		-- Default # of file versions retained																	-- 0 implies no multiple version feature	freePages: CARDINAL,							--	blank: ARRAY [0..6) OF UNSPECIFIED	];lKDH: CARDINAL = SIZE[KDH];l2999-- File Descriptors-- File serial numberSN: TYPE = MACHINE DEPENDENT RECORD	-- (see AltoFileSys.d)	[	SELECT OVERLAID * FROM	words =>		[		word1: WORD,		word2: WORD		],	record =>		[		directory: BIT,							-- This file is a directory		random: BIT,									-- Defunct, as is next bit.		nolog: BIT,									-- Don't log transactions on this file		part1: [0..17777B],		part2: CARDINAL		],	ENDCASE	];lSN: CARDINAL = SIZE[SN];				-- Special forms of serial numberfreeSN: SN = [words[177777B, 177777B]];	nullSN: SN = [record[1, 0, 1, 17777B, 177777B]];-- File Pointerl2999FP: TYPE = MACHINE DEPENDENT RECORD	-- (see AltoFileSys.d) 	[	serialNumber: SN,	version: CARDINAL,					-- Defunct	blank: WORD,								-- spare for 2-word disk adddresses	leaderVirtualDA: PAGE			 	];lFP: CARDINAL = SIZE[FP];nullFP: FP = FP[nullSN, 0, 0, eofDA];			-- Special forms of file pointerfreePageFP: FP = FP[freeSN, 177777B, 0, fillInDA];-- File identifierFID: TYPE = MACHINE DEPENDENT RECORD	[	serial: SN,	version: CARDINAL	];lFID: CARDINAL = SIZE[FID];--freePageFID: ARRAY [0..lFID) OF WORD = ALL[177777B];-- Directory (Sysdir) entryl2999\481i55IDV: TYPE = MACHINE DEPENDENT RECORD		-- Directory entry value	[ 	type: [0..77B],									-- 0 => free, 1 => file	length: [0..1777B],							-- of what?	fp: FP,													-- file pointer for this file	name: BcplSTRING									-- file name	];l2999(0,3424)LD: TYPE = MACHINE DEPENDENT RECORD	-- Leader Page	[	created: TIME,	written: TIME,	read: TIME,	name: ARRAY [0..maxLengthFnInWords) OF WORD,	leaderProps: ARRAY [0..210) OF WORD,	spare: ARRAY [0..256-3*lTIME-maxLengthFnInWords-210-2-lFP-lFA) OF WORD,	propertyBegin: [0..377B],	propertyLength: [0..377B],	consecutive: BIT,	blank1: [0..177B],	changeSerial: [0..377B],	dirFp: FP,												-- hint for directory	hintLastPageFa: FA	];lTIME:CARDINAL = 2;									-- length of TIME in AltoFileDefsl2999FA: TYPE = MACHINE DEPENDENT RECORD				-- File address	[	da: PAGE,												-- Virtual disk address for the page	pageNumber: CARDINAL,						-- Page number in the file (origin 0)	charPos: CARDINAL								-- Byte position on the page	];lFA: CARDINAL = SIZE[FA];l2999--   Disk Descriptor-- following records comprise the DSK structure for the Trident-- TFSKD is the local definitions for Trident only-- (KDH to lastPageAlloc are read in from disk at normal startup)TFSKD: TYPE = MACHINE DEPENDENT RECORD 	-- (see Tfs.D)	[	kdh: KDH,										-- standard first part	version: CARDINAL,						-- version #, this disk descriptor	model: CARDINAL,							-- disk model (80 = T-80, 300 = T-300)	packID: WORD,								-- set up when disk initialized															-- Virtual disk addresses of the BitMap	vdadiskDD: ARRAY [1..lTfsBT+1] OF PAGE,	firstVTrack: INTEGER,				-- first track used in file system															-- (INTEGER because of TfsVirtualDA)	nVtracks: CARDINAL,					-- number of tracks used in file system	nTransfers: LONG CARDINAL,		-- total number of transfers on this disk	nErrors: LONG CARDINAL,			-- total number of errors, see TfsGetCb	nECCErrors: LONG CARDINAL,		-- total number of ECC errors encountered	nECCFixes: LONG CARDINAL,		-- total number of times recovery successful	nRestores: LONG CARDINAL,		-- number of "restore" operations done	nUnRecov: LONG CARDINAL,			-- number of unrecoverable errors	nBTErrors: LONG CARDINAL,		-- number of bit table discrepancies	lastPageAlloc: PAGE,					-- last VDA allocated, for biasing search									-- words beyond here are not saved on disk	initmode: CARDINAL,					-- nonzero if permitted to ddMgrPtrte new files	zone: POINTER,								-- zone of this DSK	ddMgr: ddMgrPtr,							-- pointer to DiskDescriptor Manager object	fpTFSSysDir: FP,							-- FP for sysDir	fpTFSDD: FP,									-- FP for disk descriptor	fpTFSWD: FP,									-- FP	wdNameBlk: ARRAY [0..maxLengthFnInWords) OF CHARACTER	-- storage for name	];lTFSKDHeader: CARDINAL = lKDH + 25;--changed from 22 on June 23, 1981  7:07 PMlTFSKD: CARDINAL = SIZE[TFSKD];tfsKDversion: CARDINAL = 2;-- The extended disk object			(see Tfs.d)-- See [ERIE]<Blanchard>Trident>TFSDSK.drawl2999(0,3392)\1767i43ITFSDSK: TYPE = MACHINE DEPENDENT RECORD		[			--Extended version of the disk structure	dsk: DSK,	tfskd: TFSKD	];lTFSDSK: CARDINAL = SIZE[TFSDSK];tfsdskPtr: TYPE = POINTER TO TFSDSK; l2999DSK: TYPE = MACHINE DEPENDENT RECORD		-- (see Tfs.d)	[	ActOnDiskPages: ActOnDiskPagesType, -- (disk, CAs, DAs, fp, firstPage, lastPage,																--  action, lvNumChars, lastAction, fixedCA, 																--  cleanupRoutine, errorRtn)	WriteDiskPages: WriteDiskPagesType,	-- (disk, CAs, DAs, fp, firstPage, lastPage,																--  lastAction, lvNumChars, lastNumChars, 																--  fixedCA, nil, errorRtn)	CreateDiskFile: CreateDiskFileType,			-- (disk, name, fp, dirFp, word1, old)	DeleteDiskPages: DeleteDiskPagesType,			-- (disk, CA, firstDA, fp, firstPage)	AssignDiskPage: AssignDiskPageType,			-- (disk, virtualDA)	ReleaseDiskPage: ReleaseDiskPageType,			-- (disk, virtualDA)	VirtualDiskDA: VirtualDiskDAType,				-- (disk, lvRealDA)	RealDiskDA: RealDiskDAType,							-- (disk, virtualDA, lvRealDA)	fpSysDir: POINTER,											-- -> FP for SysDir	InitializeDiskCBZ: InitializeDiskCBZType,	-- (disk,cbz,firstPage, length, retry,																				--	 errorRtn)	DoDiskCommand: DoDiskCommandType,				-- (disk,cb, ca, da, fp, page, action,																				--	 nextCb)	fpWorkingDir: POINTER,									-- -> FP for working directory	nameWorkingDir: POINTER,							-- -> string name of working dir.	lnPageSize: CARDINAL,							-- ln (base 2) of page size in words	GetDiskCb: GetDiskCbType,					-- (disk, cbz, dontClear, returnIfNoCb)	CloseDisk: CloseDiskType,					-- (disk, dontFree)	spare: UNSPECIFIED,								-- index into times array(WAS spare)	diskKd: POINTER,										-- -> KD (header only)	fpDiskDescriptor: POINTER TO FP,					-- -> FP for disk descriptor	driveNumber: CARDINAL,							-- current driver number (0, 1, ...)	retryCount: CARDINAL,							-- number of retries to attempt	totalErrors: CARDINAL,							-- error count	lengthCBZ: CARDINAL,								-- length of the fixed portion of a CBZ	lengthCB: CARDINAL,								-- length of each CB											-- following are temps	recordTimes: INTEGER,							-- 1 => Record I/O times in caS	recordStatus: INTEGER,							-- 1 => Record status in caS	displayPages: INTEGER							-- 1 => display pages transferred	];lDSK: CARDINAL = SIZE[DSK];l2999\1935i20I41i21I38i21IDDmgr: TYPE = RECORD							-- (see TfsDDmgr.bcpl)	[	OpenDD: OpenDDType,	LockDD: LockDDType,	ReadDDPage: ReadDDPageType,	UnlockDD: UnlockDDType,	FlushDD: FlusDDType,	CloseDD: CloseDDType,	DestroyDDMgr: DestroyDDMgrType,	zone: POINTER,							-- not needed?	buffer: POINTER,						-- bit table buffer	disk: tfsdskPtr,						-- disk that owns current buffer contents  bufferSegment: SegmentDefs.DataSegmentHandle,	--segment handle that holds buffer	page: INTEGER,							-- DD page number of current buffer contents	dirty: BOOLEAN,						-- TRUE if buffer is dirty	locked: BOOLEAN						-- TRUE if DD is locked	];ddMgrPtr: TYPE = POINTER TO DDmgr;nilDdMgrPtr: ddMgrPtr = NIL;lDDmgr: CARDINAL = SIZE[DDmgr];l2999---- PROCEDURE TYPES--ActOnDiskPagesType: TYPE = PROCEDURE [tfsdskPtr, DESCRIPTOR FOR ARRAY OF POINTER, DESCRIPTOR FOR ARRAY OF PAGE, FP, INTEGER, INTEGER, CARDINAL, POINTER, CARDINAL, POINTER, CleanUpRoutType, ErrorRoutType, BOOLEAN, INTEGER] RETURNS [INTEGER];WriteDiskPagesType: TYPE = PROCEDURE [tfsdskPtr, DESCRIPTOR FOR ARRAY OF POINTER, DESCRIPTOR FOR ARRAY OF PAGE, FP, INTEGER, INTEGER, WORD, POINTER, CARDINAL, POINTER, UNSPECIFIED, ErrorRoutType, UNSPECIFIED, INTEGER] RETURNS [INTEGER];CreateDiskFileType: TYPE = PROCEDURE [tfsdskPtr, STRING, POINTER TO FP, POINTER TO FP, WORD, BOOLEAN, POINTER];DeleteDiskPagesType: TYPE = PROCEDURE [tfsdskPtr, POINTER, PAGE, FP, FP, CARDINAL, CARDINAL];AssignDiskPageType: TYPE = PROCEDURE [tfsdskPtr, PAGE, BOOLEAN] RETURNS [PAGE];ReleaseDiskPageType: TYPE = PROCEDURE [tfsdskPtr, VDA];VirtualDiskDAType: TYPE = PROCEDURE [tfsdskPtr, dAPtr] RETURNS [PAGE];RealDiskDAType: TYPE = PROCEDURE [tfsdskPtr, PAGE] RETURNS [DA];	InitializeDiskCBZType: TYPE = PROCEDURE [tfsdskPtr, cbzPtr, INTEGER, CARDINAL, RetryType, ErrorRoutType];DoDiskCommandType: TYPE = PROCEDURE [tfsdskPtr, cbPtr, POINTER, PAGE, FP, INTEGER, CARDINAL, cbPtr];GetDiskCbType: TYPE = PROCEDURE [tfsdskPtr, cbzPtr, BOOLEAN, BOOLEAN] RETURNS[cbPtr];CloseDiskType: TYPE = PROCEDURE [tfsdskPtr, BOOLEAN] RETURNS [tfsdskPtr];---- Types from TfsDDmgr--OpenDDType: TYPE = PROCEDURE [POINTER] RETURNS [ddMgrPtr];LockDDType: TYPE = PROCEDURE [ddMgrPtr, tfsdskPtr];ReadDDPageType: TYPE = PROCEDURE [ddMgrPtr, tfsdskPtr, INTEGER] RETURNS [POINTER];UnlockDDType: TYPE = PROCEDURE [ddMgrPtr, tfsdskPtr, BOOLEAN];FlusDDType: TYPE = PROCEDURE [ddMgrPtr, tfsdskPtr];CloseDDType: TYPE = PROCEDURE [ddMgrPtr, tfsdskPtr];DestroyDDMgrType: TYPE = PROCEDURE [ddMgrPtr];l2999l2999ql2999q-- PROCEDURES----		from TfsBase.mesa--DataFix: PUBLIC PROCEDURE [block: kcblockPtr] RETURNS[result: INTEGER];--TfsInitializeCBStorage: PUBLIC PROCEDURE [disk: tfsdskPtr, cbz: cbzPtr, firstPage: INTEGER, length: CARDINAL, retry: RetryType, errorRtn: ErrorRoutType _ DefaultTfsErrorRtn];--DefaultTfsCleanupRtn: PUBLIC PROCEDURE [disk: tfsdskPtr, cb: cbPtr, cbz: cbzPtr];--NoopTfsCleanupRtn: PUBLIC PROCEDURE [disk: tfsdskPtr, cb: cbPtr, cbz: cbzPtr];--DefaultTfsErrorRtn: PUBLIC PROCEDURE [addr: POINTER, arg: UNSPECIFIED, ec: CARDINAL];--TfsDoDiskCommand: PUBLIC PROCEDURE [disk: tfsdskPtr, cb: cbPtr, cA: POINTER,dA: PAGE, fp: FP, pageNumber: INTEGER, action: CARDINAL, nextCB: cbPtr];--TfsRealDA: PUBLIC PROCEDURE [disk: tfsdskPtr, dA: PAGE]RETURNS [dskAddr: DA];--TfsVirtualDA: PUBLIC PROCEDURE [disk: tfsdskPtr, dskAddr: dAPtr]RETURNS [dA: PAGE];--TfsGetCb: PUBLIC PROCEDURE [disk: tfsdskPtr, cbz: cbzPtr,dontClear, returnIfNoCb: BOOLEAN _ FALSE]  RETURNS [cb: cbPtr];-- returnIfNoCb defaulted. If set to true in call, returns zero if the Cb you set up earlier is not finished yet. -GWTfsDoRecovery:  PUBLIC PROCEDURE [disk: tfsdskPtr, command: CARDINAL,coax: BOOLEAN];--TfsWaitQuiet:	PUBLIC PROCEDURE [awaitIndex: BOOLEAN];--TfsActOnPages: PUBLIC PROCEDURE [disk: tfsdskPtr, caS: DESCRIPTOR FOR ARRAY OF POINTER, daS: DESCRIPTOR FOR ARRAY OF PAGE, fp: FP, firstPage, lastPage: INTEGER, action: CARDINAL, numcharsPtr: POINTER, lastAction: CARDINAL, fixedCA: POINTER, cleanupRoutine: CleanUpRoutType, errorRtn: ErrorRoutType _ DefaultTfsErrorRtn, returnOnCheckError: BOOLEAN, hintLastPage: INTEGER] RETURNS [resPage: INTEGER];--TfsCantCreateDiskFile: PUBLIC PROCEDURE [tfsDsk: tfsdskPtr, name: STRING, filePtr, dirFP: POINTER TO FP, word1: WORD, useOldFP: BOOLEAN, pageBuf: POINTER TO LD];--TfsCantDeletePages: PUBLIC PROCEDURE [tfsDsk: tfsdskPtr, cA: POINTER, firstDA: PAGE, fp: FP, newFP: FP, firstPage, hintLastPage: CARDINAL];--TfsCantAssignDiskPage: PUBLIC PROCEDURE [disk: tfsdskPtr, diskAddr: PAGE, test: BOOLEAN] RETURNS [resPage: PAGE];--TfsCantReleasePage: PUBLIC PROCEDURE [tfsDsk: tfsdskPtr, vda: VDA];------	from TfsStart.mesa--TfsInit: PUBLIC PROCEDURE [initmode: BOOLEAN _ TRUE, driveNumber: CARDINAL _ 0, ddMgr: ddMgrPtr _ nilDdMgrPtr, freshDisk: BOOLEAN_ FALSE] RETURNS [tfsDsk: tfsdskPtr];--initmode=TRUE => create a ddMgr for me--freshDisk=FALSE => find the disk descriptor and read it in--RamBoot: PUBLIC PROCEDURE [bootVector: CARDINAL];----	from TfsWrite.mesa--TfsWritePages: PUBLIC PROCEDURE [disk: tfsdskPtr,caS: DESCRIPTOR FOR ARRAY OF POINTER, daS: DESCRIPTOR FOR ARRAY OF PAGE, fp: FP, firstPage, lastPage: INTEGER, lastAction: WORD, numcharsPtr: POINTER, lastnumChars: CARDINAL, fixedCA: POINTER, dummy1: UNSPECIFIED, errorRtn: ErrorRoutType, dummy2: UNSPECIFIED, hintLastPage: INTEGER]RETURNS [resPage: INTEGER];--TfsAssignDiskPage: PUBLIC PROCEDURE [disk: tfsdskPtr, diskAddr: PAGE, test: BOOLEAN] RETURNS [resPage: PAGE];l2999q\3f6b10f0B30b7B68b22B152f6b4f0 20B60f6b5f0 17B60f6b5f0 18B71b16B133f6b4f0 9B69f6b4f0 12B76b8B114i118bI13B75b13B44f6b1f0 13B390b21B144b18B125b21B96b18B81b7B265b7B71b13B351b17B----		from TfsDDmgr.mesa--TfsCreateDDmgr: PUBLIC PROCEDURE [] RETURNS [ddMgr: ddMgrPtr];--TfsLockDD: PUBLIC PROCEDURE [ddMgr: ddMgrPtr, disk: tfsdskPtr];--TfsReadDDPage: PUBLIC PROCEDURE [ddMgr: ddMgrPtr, disk: tfsdskPtr, page: INTEGER]RETURNS [buffer: POINTER];--TfsUnlockDD: PUBLIC PROCEDURE [ddMgr: ddMgrPtr, disk: tfsdskPtr, dirty: BOOLEAN];--TfsFlushDD: PUBLIC PROCEDURE [ddMgr: ddMgrPtr, disk: tfsdskPtr];--TfsCloseDD: PUBLIC PROCEDURE [ddMgr: ddMgrPtr, disk: tfsdskPtr];--TfsDestroyDDMgr: PUBLIC PROCEDURE [ddMgr: ddMgrPtr];BadBitMapPage: PUBLIC ERROR;				-- erroneous bitmap disk addressl2999q\29b14B52b9B58b13B99b11B74b10B58b10B58b15B39b13B----		from TfsCreate.mesa--TfsCreateFile: PUBLIC PROCEDURE [tfsDsk: tfsdskPtr, name: STRING, filePtr, dirFP: POINTER TO FP, word1: WORD, useOldFP: BOOLEAN, pageBuf: POINTER TO LD];--TfsDeletePages: PUBLIC PROCEDURE [tfsDsk: tfsdskPtr, cA: POINTER, firstDA: PAGE, fp: FP, newFP: FP _ freePageFP, firstPage, hintLastPage: CARDINAL _ 0];TfsReleaseDiskPage: PUBLIC PROCEDURE [tfsDsk: tfsdskPtr, vda: VDA];l2999\30b13B144b14B140b18BTfsDeleteFile: PUBLIC PROCEDURE[tfsDisk: tfsdskPtr, fileName: STRING]		RETURNS[found: BOOLEAN _ FALSE];-- From TfsOpenCheckDirectory: PUBLIC PROCEDURE [fileName: STRING, dirEntry: DV] RETURNS [found: BOOLEAN];TfsOpenFile: PUBLIC PROCEDURE [tfsDisk: tfsdskPtr, fileName: STRING, mode: openMode, fp: POINTER TO FP] RETURNS [leaderPage, firstPage, lastPage: CARDINAL _ 0];----		from TfsClose.mesa--TfsCloseDisk: PUBLIC PROCEDURE [tfsDsk: tfsdskPtr, dontFree: BOOLEAN] RETURNS [result: tfsdskPtr];--l2999\b13B92i17bI14B79b11B180b12B86f6b1B3f0l2999NoMorePages: ERROR;				-- Disk full (TfsAssignDiskPage)BadCommand: ERROR;					-- bad Trident action code (TfsDoDiskCommand)BadQueue: ERROR;						-- bad CBZ queue (TfsGetCb)BadErrorRtn: ERROR;				-- Default error routineCantModDisk: ERROR;				-- Disk writing not allowedDriveHung: ERROR;					-- DoRecovery: tried 17 times to no availRetryType: TYPE = SIGNAL;	-- two occurrences are Aretry and Wretry											-- (TfsGetCb, enabled in TfsActOnPages, TfsWritePages)l2999q\b11B45b10B59b8B42b11B37b11B40b11B53b9BEND.			-- of TridentDefsl2999ql2999--Last changed on September 25, 1981  1:29 PM By Glen Williams--changed InitializeDiskCBZType to drop BOOLEAN argl2999\65i50Il2999l2999l2999l2999