-- File TfsCreate.mesa	last edited August 6, 1982  11:16 AM by GWilliams--tuned up Delete pagesl2963(1792)\73i23IDIRECTORYInlineDefs: FROM "inlinedefs" USING [COPY, BITAND, BITOR, BITNOT],MiscDefs: FROM "miscdefs" USING [Zero, DAYTIME, SetBlock],StringDefs: FROM "stringdefs" USING[AppendChar, BcplSTRING, MesaToBcplString],(0,4798)(1,5433)(2,6068)(3,6703)(4,7338)(5,11818)TridentDefs: FROM "tridentdefs" USING [CheckDirectory, dcReadHLD, dcReadnD, dcWriteD, ddMgrPtr, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, DV, eofDA, fillInDA, FP, freePageFP, lFP, LD, lSN, NoopTfsCleanupRtn, oneBits, PAGE, TfsActOnPages, tfsdskPtr, TfsLockDD, TfsReadDDPage, TfsUnlockDD, TFSwordsPerPage, TfsWritePages, VDA, WordNumInPage];l3633d2998TfsCreate: PROGRAMIMPORTS MiscDefs, TridentDefs, InlineDefs, StringDefsEXPORTS TridentDefs =BEGIN OPEN MiscDefs, TridentDefs, InlineDefs, StringDefs;TfsCreateFile: PUBLIC PROCEDURE [tfsDsk: tfsdskPtr, name: STRING, filePtr, dirFP: POINTER TO FP, word1: WORD, useOldFP: BOOLEAN, pageBuf: POINTER TO LD] =BEGIN-- Create a file by writing the Leader Page and and 1st data page for it.  IF-- useOldFP is TRUE, then use the pages of an existing file, but change the File-- Pointer(FP).  IF pageBuf is not NIL, then it is used as a buffer and the last-- 3/4 of its contents are written onto the Leader Page	buffer: LD;				-- buffer for a leader page	oldFP: FP;	caS: DESCRIPTOR FOR ARRAY OF POINTER;	daS: DESCRIPTOR FOR ARRAY OF PAGE;	pages: ARRAY [-1..3) OF PAGE;--	pagPtr: POINTER TO ARRAY [-1..3) OF PAGE;	da: PAGE;				-- 1st disk address of new file	numCharsPtr: POINTER;	numChars: CARDINAL;	dummy: UNSPECIFIED;-- See if we have been passed a Leader Page buffer	IF pageBuf = NIL THEN pageBuf _ @buffer;		-- Use our own buffer	COPY[filePtr, lFP, @oldFP];		-- Save FP of old file--	Make a new File Pointer	Zero[filePtr, lFP];			-- Clear FP passed to us	filePtr.version _ 1;										IF (tfsDsk.tfskd.kdh.lastSn.part2 _ tfsDsk.tfskd.kdh.lastSn.part2 + 1) = 0 THEN			tfsDsk.tfskd.kdh.lastSn.part1 _ tfsDsk.tfskd.kdh.lastSn.part1 +1;	COPY[@tfsDsk.tfskd.kdh.lastSn, lSN, @filePtr.serialNumber];	filePtr.serialNumber.word1 _ BITOR[filePtr.serialNumber.word1,word1];--	Make an array of disk addresses	pages[-1] _ pages[2] _ eofDA;	pages[0] _ pages[1] _ fillInDA;--	pagPtr _ @pages;--	pagPtr _ pagPtr + 2;	daS _ DESCRIPTOR[@pages[0], 3];--	If we're using an existing file, 'rename' it	IF useOldFP THEN			-- (bitmap won't be affected)	BEGIN		da _ oldFP.leaderVirtualDA;		-- 1st page of file		TfsDeletePages[tfsDsk, pageBuf, da, oldFP, filePtr^, 0, 0];		daS[0] _ da;		-- 1st page, new file (we want pages[0])	END;--	Set up the Leader Page	Zero[pageBuf, 256];		-- Clear 1st 1/4 of the page	pageBuf.created _ DAYTIME[];		-- Store creation date	MesaToBcplString[name, LOOPHOLE[@pageBuf.name]];				-- Make a BCPL string	IF dirFP # NIL THEN COPY[dirFP, lFP, @pageBuf.dirFp];		--Put in directory hint	pageBuf.propertyBegin _ @pageBuf.leaderProps[0] - @pageBuf.created.high;	-- pageBuf.propertyBegin _ 3*lTIME + maxLengthFnInWords;	pageBuf.propertyLength _ LENGTH[pageBuf.leaderProps];--	Write the leader and first data page	numCharsPtr _ @numChars;	IF useOldFP THEN		[] _ TfsActOnPages [tfsDsk, caS, daS, filePtr^, 0, 1, dcWriteD,		numCharsPtr, dcWriteD, pageBuf, NoopTfsCleanupRtn,DefaultTfsErrorRtn,FALSE,0]	ELSE		[] _ TfsWritePages [tfsDsk, caS, daS, filePtr^, 0, 1, dcWriteD,		NIL, 0, pageBuf, dummy, DefaultTfsErrorRtn, dummy, 0];--		[] _ TfsWritePages [tfsDsk, caS, daS, filePtr^, 0, 1, dcWriteD,--		NIL, 0, pageBuf, dummy, DefaultTfsErrorRtn, dummy, 0];	filePtr.leaderVirtualDA _ daS[0];		-- Modify file pointerEND;							-- of TfsCreateFileTfsDeleteFile: PUBLIC PROCEDURE[tfsDisk: tfsdskPtr, fileName: STRING]		RETURNS[found: BOOLEAN _ FALSE]=BEGIN-- Search the file SysDir sequentially for fileName.  If found, delete the name from sysdir and reset all the file's labels to free.	sysBuf: ARRAY [0..1024) OF WORD;		-- Input buffer	overSysPtr, sysPtr: POINTER TO WORD;		-- Pointer to sysBuf	pag: CARDINAL;			-- page counter	tempSiz, siz: CARDINAL;		-- where we are in a page	dirPtr: POINTER TO DV;		-- pointer to directory entry	pages: ARRAY [0..30) OF PAGE;		-- SysDir's pages	dAs: DESCRIPTOR FOR ARRAY OF PAGE;	cAs: DESCRIPTOR FOR ARRAY OF POINTER;	numChars: INTEGER _ 2048;	--TfsActOnPages never writes this # of chars:	numCharsPtr: POINTER _ @numChars;	--	only fills it during read	fpTfsSysdir: FP _ tfsDisk.tfskd.fpTFSSysDir;	-- file pointer for Sysdir	overFlag: BOOLEAN _ FALSE;		-- directory entry overflowed a page	dirEntry: DV;				-- directory entry	dirEntryPtr: POINTER TO DV;		--for resetting type field in buffer-- Build the Array of diskaddresses for SysDir	SetBlock[@pages[0], fillInDA, 29];	dAs _ DESCRIPTOR[@pages[1], 27];	dAs[0] _ 1;	dAs[1] _ 2;-- Fix up the filename STRING, initialize for create mode	IF fileName[fileName.length-1] # '.	 THEN AppendChar[fileName, '.];		-- Argument has been altered, OK?-- Read the first page of Sysdir\1b9B146b13B609i45I673i35I64i44I34i48I234i26I448i40I538b14B98i133I404i22I6i16I36i29I209i34I3i46I98i58I71i33I2i[]_TfsActOnPages[tfsDisk,cAs,dAs,fpTfsSysdir,1,1,dcReadHLD,numCharsPtr,dcReadHLD,@sysBuf, DefaultTfsCleanupRtn, DefaultTfsErrorRtn,FALSE,0];l3633d2998\67v3V-- search Sysdir sequentially for fileName	pag _ 1;				-- page counter	sysPtr _ @sysBuf[0];		-- input Buffer	overFlag _ FALSE;			-- overflow flag-- Two loops: the first handles pages, 2nd directory entries within a page-- N.B.: Rather than read the file of headers, or read the header page for hintLastPage, read on page at a time, letting the called code fill--	in the next disk address until it hits EOFUNTIL pag >= 27 DO	siz _ 0;					-- size of current page	sysPtr _ @sysBuf[0];		-- re-init pointer to buffer	IF overFlag THEN			-- see if we're doing a split entry	BEGIN		COPY[sysPtr, tempSiz, dirPtr];		-- copy in the rest of the entry		siz _ siz + tempSiz;		sysPtr _ sysPtr + tempSiz;		-- point to next entry		found_CheckDirectory[fileName,dirEntry];	-- see if this is it		IF found	THEN EXIT	--save state of overFlag so as to reset correct page.				ELSE overFlag _ FALSE;		-- otherwise reset flag for next iter				END;	DO						-- look at directory entries in a page		COPY[sysPtr, 26, @dirEntry];		-- copy in the next entry		IF dirEntry.length + siz > 1024 THEN 		BEGIN																		-- entry spills onto next page			dirPtr _ @dirEntry + 1024 - siz;			tempSiz _ dirEntry.length-(1024-siz);		-- and amount left over			overSysPtr _ sysPtr;			overFlag _ TRUE;		-- set the overflow flag			EXIT;		--NB: looks like we'll never create an entry on page bounds with						--	this logic. Go read next page		END;		found_CheckDirectory[fileName,dirEntry];	-- check this directory entry		IF found THEN EXIT;		-- finished if TRUE		--fix directory if no good		IF dirEntry.type = 0 AND dirEntry.length =  0 AND siz<TFSwordsPerPage		THEN			{dirEntry.length _ TFSwordsPerPage-siz;	--mal-formed directory, fix up.				 COPY [@dirEntry, TFSwordsPerPage-siz, sysPtr];	--re-set the length			};		sysPtr _ sysPtr + dirEntry.length;		-- point to next entry (source)		siz _ siz + dirEntry.length;		-- add size of next entry		IF siz >= 1024 THEN EXIT;		-- can't have an overflow	ENDLOOP;	IF (found) OR dAs[pag] = eofDA THEN EXIT;	-- finished if TRUE or EOF	pag _ pag + 1;\1i43I107i75I2i186I400i53I248i32I411i29I123i30I53i19I245i26I	[]_TfsActOnPages[tfsDisk,cAs,dAs,fpTfsSysdir,pag,pag,dcReadHLD,numCharsPtr,dcReadHLD,@sysBuf,DefaultTfsCleanupRtn,DefaultTfsErrorRtn,FALSE,0];l3633d2998\73v3VENDLOOP;IF ~found THEN RETURN [FALSE];dirEntryPtr _ LOOPHOLE[sysPtr];IF overFlag	THEN		--the page that has the header is on disk. Read it in.	{pag _ pag-1;	 [] _TfsActOnPages[tfsDisk,cAs,dAs,fpTfsSysdir,pag,pag,dcReadHLD, numCharsPtr, dcReadHLD, @sysBuf,		DefaultTfsCleanupRtn, DefaultTfsErrorRtn, FALSE, 0];	dirEntryPtr _ LOOPHOLE[overSysPtr];	};l2999d2998\93i54I91v3VdirEntryPtr.type _ 0;				--that's all it takes to delete an entry from sysdir.--write the page back into sysdir.[] _ TfsActOnPages[tfsDisk, cAs, dAs, fpTfsSysdir, pag, pag, dcWriteD,  numCharsPtr, dcWriteD, @sysBuf, NoopTfsCleanupRtn,	DefaultTfsErrorRtn, FALSE, 0];TfsDeletePages[tfsDisk, @sysBuf, dirEntry.fp.leaderVirtualDA, dirEntry.fp, freePageFP, 0, 0];END;--of TfsDeleteFile(448)\26i53I1i34I81v3V172i18bITfsDeletePages: PUBLIC PROCEDURE [tfsDsk: tfsdskPtr, cA: POINTER, firstDA: PAGE, fp: FP, newFP: FP _ freePageFP, firstPage, hintLastPage: CARDINAL _ 0] =--	Delete pages starting at firstPage and continue to the end of file.  cA points to-- a page-sized buffer, and newFP, if not NIL, is the 'new' File Pointer to-- install (used by TfsCreateFile).BEGIN	biteSize: CARDINAL = 100;					-- maxpages to delete at once	dasLength: CARDINAL _ biteSize+2;	numChars, lastNumChars: CARDINAL _ 0;	i, lastPageFound: CARDINAL;	pages: ARRAY [0..biteSize + 2) OF PAGE;	dAs: DESCRIPTOR FOR ARRAY OF PAGE;	-- Loop until we bump into eofDA	WHILE firstDA # eofDA	DO		dAs _ DESCRIPTOR[((@pages)+1)-firstPage, dasLength];		SetBlock[@pages[0], fillInDA, biteSize+2];-- fill Array w/fillInDA		dAs[firstPage] _ firstDA;		-- Find the last page in the file		lastNumChars _ 0;(635)\b16B141i197I39i29I183i33I126i25I29i36IlastPageFound _ TfsActOnPages[tfsDsk, NIL, dAs, fp, firstPage, firstPage+ biteSize-1, dcReadnD, @lastNumChars, dcReadnD, cA, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, FALSE, hintLastPage];l4903d4268		--  Write newFP in all the labels (either a real one from TfsCreateFile or 		-- freePageFP.  Data pages are zeroed in case a file is being renamed.		Zero[cA, TFSwordsPerPage];\1i151I[] _ TfsWritePages [tfsDsk, NIL, dAs, newFP, firstPage, lastPageFound, 177777B, NIL, lastNumChars, cA, DefaultTfsCleanupRtn, DefaultTfsErrorRtn, NIL, 0];l4903d4268		-- Alter the bitmap if we are deleting (not renaming) the file.		IF newFP = freePageFP THEN			FOR i IN [firstPage..lastPageFound] DO				TfsReleaseDiskPage[tfsDsk, LOOPHOLE[dAs[i]]];			ENDLOOP;		firstPage _ lastPageFound + 1;		firstDA _ dAs[firstPage];		dasLength _ dasLength + lastPageFound + 1;	ENDLOOP;END;																	-- of TfsDeletePages\1i66ITfsReleaseDiskPage: PUBLIC PROCEDURE [tfsDsk: tfsdskPtr, vda: VDA] =--	Alter the disk's bit map to show that a page has been releasedBEGIN	ddMgr: ddMgrPtr;														-- Disk descriptor manager pointer	bufferPtr: POINTER TO ARRAY [0..1024) OF WORD;			-- POINTER to buffer	mask: WORD;	wa: WordNumInPage;	ddMgr _ tfsDsk.tfskd.ddMgr;			-- Get the DD Manager	TfsLockDD[ddMgr, tfsDsk];				-- Lock access to bitmap--	Get the right bitmap page into memory	bufferPtr _ TfsReadDDPage[ddMgr, tfsDsk, vda.pageNum + 2];--	buffer _ bufferPtr^;--	Turn off the bit corresponding to page being released	wa _ vda.wordNumInPage;										-- Extract word number	mask _ oneBits[vda.bitNum];					-- 1-bit mask: this page	IF BITAND[bufferPtr[wa], mask] # 0 THEN	{		bufferPtr[wa] _ BITAND[bufferPtr[wa], BITNOT[mask]];	-- Turn off the bit		tfsDsk.tfskd.kdh.freePages _ tfsDsk.tfskd.kdh.freePages + 1;	}	ELSE		tfsDsk.tfskd.nBTErrors _ tfsDsk.tfskd.nBTErrors + 1;	-- error-- Note that the bit table is dirty (needs to be written).	TfsUnlockDD[ddMgr, tfsDsk, TRUE];	-- ddMgr, diskobject, dirtyEND;														-- of TfsReleasePageEND.														-- of TfsCreate(448)\2b18B406i41I60i24I1i57I371i59I-- File TfsCreate.mesa	last edited July 31, 1981  6:23 PM by GWilliams	