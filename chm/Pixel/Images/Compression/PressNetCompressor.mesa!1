-- File:  PressNetCompressor.mesa: Routines for sending a file to a printing server.e1(1792)\i-- Last Edited:  February 26, 1982  5:04 PM   By:  GWilliams e1\i--Keep times.DIRECTORYe1\2i11IImageDefs USING [StopMesa],l4269d3634e1k72(635)InlineDefs USING [BITAND, BITOR, BITSHIFT, BITXOR--, LowHalf--],l4269d3634e1k72\49i13IIODefs USING[CR, NUL, ReadChar, ReadLine, SP, TAB, WriteChar, --WriteDecimal,-- WriteLine, WriteString],l4269d3634e1k72\62i17IMiscDefs USING [SetBlock],l4269d3634e1k72PressCompressDefs USING[CloseDecompressor, CompareLines, CompressSpec, CompressSpecRec, Color, GetNibble, NextLine, NibbleRange, NibbleRunSpec, NibbleSpecType, OpenDecompressor, RunState],l4269d3634e1k72\24f5 33f0 38f5 21f0 44f5 18f0PressDefs USING [PageG, PressPassword],l4269d3634e1k72PressNetDefs,l4269d3634e1k72Real USING [--Float,-- InitReals],l4269d3634e1k72\12i10ISegmentDefs USING[DataSegmentHandle, DefaultBase, DeleteDataSegment, DeleteFileSegment, FileHandle, FileNameError, FileSegmentHandle, NewDataSegment, NewFile, NewFileSegment, OldFileOnly, Read, SegmentAddress, SwapIn, SwapOut, Unlock],l4269d3634e1k72StreamDefs USING[NewByteStream, NewWordStream, DiskHandle, ReadBlock, StreamHandle, SetPosition, StreamPosition, WriteAppend],l4269d3634e1k72StringDefs USING [AppendChar, EquivalentString, StringToDecimal, AppendString, UpperCase],l4269d3634e1k72TimeDefs USING [CurrentDayTime, PackedTime],l4269d3634e1k72WF USING [FWF1, FWF3, FWF4--WF1, WF4--],l4269d3634e1k72\26i12IWFReal USING [InitWFReals];l4269d3634e1k72e1(1792)\bPressNetCompressor: PROGRAMe1\b18BIMPORTS InlineDefs, ImageDefs, IODefs, MiscDefs, PressCompressDefs, Real, SegmentDefs, StreamDefs, StringDefs, TimeDefs, WF, WFReall4904d3634e1k72(635)EXPORTS PressCompressDefsl4904d3634e1k72 =l3633e1(1792)l3633d2998e1BEGIN OPEN ImageDefs, InlineDefs, IODefs, MiscDefs, PressCompressDefs, PressDefs, Real, SegmentDefs, StreamDefs, StringDefs, TimeDefs, WF, WFReal;l3633d2998e1decompressP: BOOLEAN _ FALSE;	--decompress the data and check it for consistencyreportP: BOOLEAN _ TRUE;timingsP: BOOLEAN _ TRUE;pauseP: BOOLEAN _ TRUE; --pause for operator input if errornibbleSize: CARDINAL = 7;remTable: PUBLIC ARRAY [0..nibbleSize] OF CARDINAL _	[0, 1, 3B, 7B, 17B, 37B, 77B, 177B];	--the 177B is for masking on the sink sideAqSwitches: TYPE=RECORD[	length: INTEGER,	options: ARRAY[1..9]OF Option,	num: INTEGER];Option: TYPE = RECORD[c: CHARACTER, value: BOOLEAN];Switches: TYPE = POINTER TO AqSwitches;headerBufferSeg: FileSegmentHandle;	--to hold page one of Press.bitsheaderFh: FileHandle;headerAddress: POINTER TO ARRAY [0..1024) OF WORD;headerInCore: BOOLEAN _ FALSE;filename: STRING _ [200];numPages: CARDINAL;	--# of printed pages (or separations)pageGArray: POINTER TO ARRAY [1..93] OF PageG;atomCount, runCount, runLengthCount: LONG INTEGER;putBackChar: CHARACTER _ NUL;	--for ReadCommandFile--logfile stufflogFile: DiskHandle;comH: StreamHandle;timeStarted, timeDone: PackedTime;CompressErrCode: TYPE = {badBitsFile, fileNotFound, notEnoughScans, noImage, noError};compressAbort: ERROR[compressErrCode: CompressErrCode] = CODE;--ProcsSinkEncoding: PROC[nib: NibbleRunSpec]=BEGIN	WITH nib SELECT FROM		run => {runCount _ runCount + 1; runLengthCount _ runLengthCount + nibbleCt};		atom => atomCount _ atomCount + 1;	ENDCASE;	IF decompressP THEN GetNibble[nib];END;--SinkEncodingCompressorDriver: PUBLIC PROC[]=--Raises no signals or errorsBEGIN	proceed, empty: BOOLEAN;	compressSpec: CompressSpec _ @ compressSpecRec;	compressSpecRec: CompressSpecRec;	i, wordsRead: CARDINAL;	h: DiskHandle;	srcASeg, srcBSeg: DataSegmentHandle;	srcA, srcB, flipper: POINTER TO ARRAY OF WORD;--"flipper" for flipping srcA&srcB	gotFileP: BOOLEAN _ FALSE;	realsInited: BOOLEAN _ FALSE;--file positioning stuff	roundedBytesPerBand, totalBands, bandNum, bitPage: LONG CARDINAL;totalWordsRead: LONG INTEGER;	scanNum, scanLineLength--in 16-bit words--, arrayLength: CARDINAL;	streamPosition: StreamPosition;--scan line info	bandWidth: CARDINAL = 16;	localState: CompressErrCode _ noError;BEGIN	[proceed, empty] _ ReadCommandFile[filename];	IF ~proceed THEN GOTO getOut;	UNTIL gotFileP DO		IF empty THEN			{WriteString["Filename to read: "];			ReadLine[filename]; WriteChar[CR]};		empty _ TRUE;		h _ NewWordStream[filename, Read!FileNameError=>			{WriteString["Can't find file: "L]; WriteString[filename]; WriteChar[CR];			LOOP};			];	--open bits file.		gotFileP _ TRUE;		ENDLOOP;	IF reportP THEN {InitReals[]; InitWFReals[]};	GetPageGs[!compressAbort => GOTO exit];	OpenLog[filename];	atomCount _ runCount _ totalWordsRead _ runLengthCount _ 0;	--keep count on a per file basis	FOR  i IN [1..numPages]	DO		--set up for this page		IF ~(pageGArray[i].LastBand > pageGArray[i].FirstBand)			THEN {localState _ noImage; GOTO exit};		scanLineLength _ pageGArray[i].BitWc;		bitPage _ pageGArray[i].BitPage;		totalBands _ (pageGArray[i].LastBand - pageGArray[i].FirstBand) + 1;		roundedBytesPerBand _ ((scanLineLength * bandWidth + 1023)/1024) * 1024 * 2;--bytes in band, rounded up to 1K bound			--the scan line length may change from page to page.		arrayLength _ scanLineLength + 1;		srcASeg _ NewDataSegment[DefaultBase, (arrayLength+255)/256];		srcA _ SegmentAddress[srcASeg];		srcBSeg _ NewDataSegment[DefaultBase, (arrayLength+255)/256];		srcB _ SegmentAddress[srcBSeg];			IF decompressP THEN				OpenDecompressor[scanLineLength, nibbleSize];	--let the destination get buffers		SetBlock[srcB, 0, arrayLength];		--start the first scan with all zero's			timeStarted _ CurrentDayTime[];		FOR bandNum IN [0..totalBands)  	-- Use the Press.bits format for getting scan lines		DO			streamPosition _ bandNum*roundedBytesPerBand+(2048 * bitPage);			SetPosition[h, streamPosition];	--now positioned to first word of band.				FOR scanNum IN [0..bandWidth)			DO				IF h.endof[h] THEN {localState _ notEnoughScans; GOTO exit};			--alternate buffers on fill				wordsRead _ ReadBlock[h, srcA, scanLineLength];				totalWordsRead _ totalWordsRead + wordsRead;				flipper _ srcA; srcA _srcB; srcB _ flipper;				compressSpec^ _ [src1: srcA, src2: srcB, sink: SinkEncoding, srcLen: scanLineLength, nibbleSize: 7];				Compressor[compressSpec];				IF decompressP THEN NextLine[];				IF decompressP THEN [] _ CompareLines[srcB];			ENDLOOP;	--FOR scanNum IN [0..bandWidth]		ENDLOOP;	--FOR bandNum: CARDINAL IN [0..totalBands)		DeleteDataSegment[srcASeg];		DeleteDataSegment[srcBSeg];		timeDone _ CurrentDayTime[];		ReportStats[totalWordsRead, atomCount, runCount];		IF decompressP THEN CloseDecompressor[];	ENDLOOP;--this is the page loop	--close file streams, etc here.	h.destroy[h];	Unlock[headerBufferSeg];	SwapOut[headerBufferSeg];	DeleteFileSegment[headerBufferSeg];	headerInCore _ FALSE;	CloseLog[];EXITSexit => {		 SELECT localState FROM			badBitsFile => WriteLine["Doesn't look like a Press.bits format file"L];--ERROR			fileNotFound => NULL;			notEnoughScans => {WriteLine["Input file ended before all scans were processed."L];				DeleteDataSegment[srcASeg];				DeleteDataSegment[srcBSeg];};			ENDCASE;		h.destroy[h];		IF headerInCore THEN			{Unlock[headerBufferSeg];			SwapOut[headerBufferSeg];			DeleteFileSegment[headerBufferSeg];			headerInCore _ FALSE;};		};getOut=> NULL;END;END;--of CompressorDriverCompressor: PROC[cSpec: CompressSpec]=--takes two src's and xor's them, destroying one of them--it passes the nibbles to a call-back routine{	i, byte, mask: CARDINAL;	runCt: CARDINAL _ 0;	curLoc: CARDINAL _ 0;    pos: CARDINAL _ 6;--the first 7-bit byte ends 6 bits into first word from left.	src1: POINTER TO ARRAY OF WORD _ cSpec.src1;	src2: POINTER TO ARRAY OF WORD _ cSpec.src2;	runState: RunState _ random;	increment: BOOLEAN _ FALSE;	srcLen: CARDINAL _ cSpec.srcLen;			--length of data, spare loc not included	srcLenBits: CARDINAL _ srcLen*16;	lastDataLoc: CARDINAL _ srcLen - 1;			--src1[lastDataLoc] is last data item	nibbleCount: CARDINAL _ (srcLenBits/cSpec.nibbleSize) + 1;  --# of nibbles to pull out	NextNibble: PROC [high, low: WORD] RETURNS [nibble: WORD]=	{		SELECT pos FROM			6 => {increment _ FALSE; pos _ 13; nibble _ BITSHIFT [high, -9]; GOTO exit};			13 => {increment _ FALSE; pos _ 4; nibble _ BITSHIFT [high, -2]; GOTO exit};			4 => {increment _ TRUE; pos _ 11; nibble _ BITOR [BITSHIFT [high, 5], BITSHIFT [low, -11]]; GOTO exit};			11 => {increment _ FALSE; pos _ 2; nibble _ BITSHIFT [high, -4]; GOTO exit};			2 => {increment _ TRUE; pos _ 9; nibble _ BITOR [BITSHIFT [high, 3], BITSHIFT [low, -13]]; GOTO exit};			9 => {increment _ FALSE; pos _ 0; nibble _ BITSHIFT [high, -6]; GOTO exit};			0 => {increment _ TRUE; pos _ 7; nibble _ BITOR [BITSHIFT [high, 1], BITSHIFT [low, -15]]; GOTO exit};			7 => {increment _ FALSE; pos _ 14; nibble _ BITSHIFT [high, -8]; GOTO exit};			14 => {increment _ FALSE; pos _ 5; nibble _ BITSHIFT [high, -1]; GOTO exit};			5 => {increment _ TRUE; pos _ 12; nibble _ BITOR [BITSHIFT [high, 6], BITSHIFT [low, -10]]; GOTO exit};			12 => {increment _ FALSE; pos _ 3; nibble _ BITSHIFT [high, -3]; GOTO exit};			3 => {increment _ TRUE; pos _ 10; nibble _ BITOR [BITSHIFT [high, 4], BITSHIFT [low, -12]]; GOTO exit};			10 => {increment _ FALSE; pos _ 1; nibble _ BITSHIFT [high, -5]; GOTO exit};			1 => {increment _ TRUE; pos _ 8; nibble _ BITOR [BITSHIFT [high, 2], BITSHIFT [low, -14]]; GOTO exit};			8 => {increment _ FALSE; pos _ 15; nibble _ BITSHIFT [high, -7]; GOTO exit};			15 => {increment _ TRUE; pos _ 6; nibble _ high; GOTO exit};			ENDCASE;	EXITS	exit => RETURN[BITAND[nibble, 177B]];	};--NextNibble	FOR i IN [0..lastDataLoc] DO src1[i] _ BITXOR[src1[i], src2[i]]; ENDLOOP;	--make overflow word match the last nibble's signature	mask _ remTable[(srcLenBits MOD nibbleSize)];	IF (BITAND [src1[lastDataLoc], mask] = mask) THEN src1[srcLen] _ 177777B ELSE src1[srcLen] _ 0;	FOR i IN [1..nibbleCount]	 DO	   byte _ NextNibble[src1[curLoc], src1[curLoc+1]];	   IF increment THEN curLoc _ curLoc + 1;	SELECT byte FROM	   0=>	SELECT runState FROM			   random =>	{runState _ zeros; runCt _ 1};			   zeros	=>	{IF (runCt _ runCt + 1) = LAST[NibbleRange]								THEN {cSpec.sink[[0, run[black, runCt]]]; runCt _ 0}};			   ones	=>	{runState _ zeros; cSpec.sink[[0, run[white, runCt]]]; runCt _ 1};			ENDCASE;	   177B=> SELECT runState FROM			   random =>	{runState _ ones; runCt _ 1};			   zeros   =>	{ runState _ ones; cSpec.sink[[0, run[black, runCt]]]; runCt _ 1};			   ones    =>	{IF (runCt _ runCt + 1) = LAST[NibbleRange]								THEN {cSpec.sink[[0, run[white, runCt]]]; runCt _ 0}};			ENDCASE;	   ENDCASE =>  SELECT runState FROM			   random =>  {cSpec.sink[[0, atom[byte]]];};	--send another byte of randomness			   zeros   =>  { runState _ random; cSpec.sink[[0, run[black, runCt]]]; cSpec.sink[[0, atom[byte]]]};			   ones    => { runState _ random; cSpec.sink[[0, run[white, runCt]]]; cSpec.sink[[0, atom[byte]]]};			ENDCASE;	 ENDLOOP;	--FOR i IN [1..nibbleCount]	--flush any leftover state	SELECT runState FROM		zeros => cSpec.sink[[0, run[black, runCt]]];		ones  => cSpec.sink[[0, run[white, runCt]]];		ENDCASE;};GetPageGs: PROC[]=BEGIN	headerFh _ NewFile[filename, Read, OldFileOnly!	FileNameError => {WriteString["File "L]; WriteString[filename]; WriteString[" is required"L];							compressAbort[fileNotFound];};]; 	headerBufferSeg _ NewFileSegment[headerFh, DefaultBase, 4, ];--point to one page; default access, 1K	SwapIn[headerBufferSeg];--get it into core	headerAddress _ LOOPHOLE[SegmentAddress[headerBufferSeg]];--find out where it is	headerInCore _ TRUE;		numPages _ headerAddress[0];	IF headerAddress[3] # PressPassword THEN GOTO inconsistentFile;	pageGArray _ LOOPHOLE[@headerAddress[4]]; EXITSinconsistentFile => {Unlock[headerBufferSeg];						SwapOut[headerBufferSeg];						DeleteFileSegment[headerBufferSeg];						headerInCore _ FALSE;						compressAbort[badBitsFile]};END;--GetPageGReportStats: PROC[wordsRead, atoms, runs: LONG INTEGER]=BEGINbytesRead: LONG INTEGER _ wordsRead*2;totalSpecs: LONG INTEGER _ atoms +  runs;bytesReadRl, atomsRl, runsRl, compressionFactorRl, totalSpecsRl, averageRun: REAL;tTime: PackedTime _ timeDone - timeStarted;totalTime: LONG INTEGER _ tTime;	IF ~reportP THEN GOTO getOut;	bytesReadRl _ bytesRead;	atomsRl _ atoms;	runsRl _ runs;	totalSpecsRl _ atoms + runs;	compressionFactorRl _ (totalSpecsRl / bytesReadRl) * 100.0;	averageRun _ (runLengthCount/runs);	FWF4[logFile, "%ld bytes read: %ld were runs and %ld were atoms, for a total of %ld specification bytes*n", @bytesRead, @runs, @atoms, @totalSpecs];	FWF3[logFile, "Average run length (runLengthCount/runCount): (%ld/%ld) = %7.1f.*n", @runLengthCount, @runs, @averageRun];	FWF1[logFile, "The data was compressed to %7.3f%% of orignial volume.*n", @compressionFactorRl];	FWF1[logFile, "Total seconds: %ld.*n", @totalTime];	PutString[logFile, "Decompression was "];	PutLine[logFile, (IF decompressP THEN "enabled." ELSE "disabled.")];EXITSgetOut => NULL;END;--ReportStatsOpenLog: PROC[file: STRING]=BEGINlogName: STRING _ [100];	IF ~reportP THEN GOTO getOut;	logName.length _ 0;	FOR i: CARDINAL IN [0..file.length) DO		IF file[i] = '. THEN EXIT ELSE AppendChar[logName, file[i]];		ENDLOOP;	AppendString[logName, ".CLog"L];	IF decompressP THEN AppendChar[logName, 'D];	logFile _ NewByteStream[logName, WriteAppend];	PutString[logFile, "Input file was: "L];	PutString[logFile, file];	PutCR[logFile]; PutCR[logFile];EXITSgetOut => NULL;END;--of OpenLogCloseLog: PROC[]=BEGIN	IF reportP THEN logFile.destroy[logFile];END;--of CloseLogPutString: PROC[sH: DiskHandle, s: STRING]=BEGIN	FOR i: CARDINAL IN [0..s.length) DO sH.put[sH, s[i]] ENDLOOP;END;--of PutStringPutLine: PROC[sH: DiskHandle, s: STRING]=BEGIN	PutString[sH, s];	PutCR[sH];END;PutCR: PROC[sH: DiskHandle]=BEGIN	sH.put[sH, CR];END;--of PutCRReadCommandFile: PROC[file: STRING] RETURNS[okToProceed: BOOLEAN _ FALSE, empty: BOOLEAN _ FALSE]=--Raises no signals or errorsBEGIN	errorNote: STRING _ "Switches are U[ncompress],D[ebug],T[imings],R[eport],P[ause on errors]. Grammar is PressCompress</switches>* filename command*";	swIndex: INTEGER _ 1;	aqSwitches: AqSwitches_[0, [[NUL, TRUE], [NUL, TRUE], [NUL, TRUE], [NUL, TRUE], [NUL, TRUE], [NUL, TRUE], [NUL, TRUE], [NUL, TRUE], [NUL, TRUE]], -1];	switches: Switches = @aqSwitches; BEGIN	command: STRING _ [20];	switches.length _ 0;	ReadComInit[];-- open Com.cm etc.	UNTIL ReadCom[command, switches]--returns eof	DO		FOR swIndex IN [1..switches.length] DO			SELECT switches.options[swIndex].c FROM					'U => decompressP _ switches.options[swIndex].value;					'D => NULL;					'T => timingsP _ switches.options[swIndex].value;					'R => reportP _ switches.options[swIndex].value;					'P => pauseP _ switches.options[swIndex].value;				ENDCASE => GOTO illegalComSwitch;		ENDLOOP;--Grammar:  PressCompress/<single-letter switches>* filename com*	IF EquivalentString[command, "Mesa.Image"] THEN command.length _ 0;	IF EquivalentString[command, "PressCompress.bcd"] THEN command.length _ 0;	IF command.length # 0 AND file.length = 0 THEN AppendString[file, command];--look for other commands here	IF FALSE THEN GOTO illegalCom;--placeholder for future commands	ENDLOOP;	IF file.length=0 THEN GOTO noCom;	comH.destroy[comH];--close file	okToProceed _ TRUE;EXITSillegalComSwitch => {WriteString["Illegal Switch: "];				WriteChar[switches.options[swIndex].c];				WriteLine[""];				WriteLine["Type any key to finish"];				IF pauseP THEN []_ReadChar[]; comH.destroy[comH];};illegalCom => {WriteLine["Illegal command Line"];				WriteLine[errorNote];				WriteLine["Type any key to finish"];				IF pauseP THEN []_ReadChar[]; comH.destroy[comH];};noCom => 	okToProceed _ empty _ TRUE;END;--for EXITS to be able to see switchesEND;--of ReadCommandFileReadCom: PROC[com: STRING, sw: Switches] RETURNS[eof: BOOLEAN _ FALSE]=--This routine is called repeatedly until it returns true.--Raises no Errors or Signals{	c: CHARACTER _ NUL;	nm: STRING _ [10];	com.length _ 0;	nm.length _ 0;	sw^ _ [0, [[NUL, TRUE], [NUL, TRUE], [NUL, TRUE], [NUL, TRUE], [NUL, TRUE], [NUL, TRUE], [NUL, TRUE], [NUL, TRUE], [NUL, TRUE]], -1];	UNTIL comH.endof[comH] DO		--get command		c _ GetChar[];		SELECT c FROM			CR, '/ => EXIT;			SP, TAB => {IF com.length#0 THEN EXIT ELSE LOOP}; --elim leading spaces			IN ['a..'z] => AppendChar[com, UpperCase[c]];			ENDCASE => AppendChar[com,c];	ENDLOOP;	IF c = '/ THEN		{UNTIL comH.endof[comH] DO			c_ GetChar[];			SELECT c FROM				'/, TAB => LOOP;				SP, CR => EXIT;				'- => sw.options[sw.length+1].value _ FALSE;				IN ['a..'z] => {sw.length _ sw.length + 1;							sw.options[sw.length].c _ UpperCase[c]};				IN ['A..'Z] => {sw.length _ sw.length + 1;							sw.options[sw.length].c _ c;};			ENDCASE =>  EXIT;		ENDLOOP;		}	ELSE					--look for a number		{UNTIL comH.endof[comH] DO			SELECT c FROM				CR => EXIT;				SP, TAB => {c_GetChar[]; LOOP};				IN ['0..'9] => AppendChar[nm, c];			ENDCASE => {putBackChar _ c; EXIT};--save other chars for later scan			c_GetChar[];		ENDLOOP;		}; 	IF nm.length # 0 THEN sw.num _ StringToDecimal[nm];	IF com.length =0 AND comH.endof[comH] THEN eof _ TRUE;};--ReadComReadComInit: PROC[]={	comH _ NewByteStream["Com.cm", Read];};--ReadComInitGetChar: PROC[]RETURNS[ch: CHARACTER]={	IF putBackChar # NUL	THEN {ch _ putBackChar; putBackChar _ NUL}	 ELSE ch _ comH.get[comH];};--GetChar--initilization code (again, for testing only)CompressorDriver[];ImageDefs.StopMesa[];END. -- PressNetCompressor.mesal2999e7k72(635)\30i51I75i36I26b8B74f5 6f0 3f5i42f0I1f5i1f0bI10B81b8B121i32I151i37I128i39I77b15B72b15B50i7bI14B181f5 37f0 4i14I1b17B17i30I242i34I61i24I122i19I60i15I426i17I201i32I32i22I325i39I4i53I236f5 70f0 1i2f5 31f0I35i39I71i52I73i1I32i40I112i25I54i3I228f5 85f0 12i31I12i42I145f5 43f0 9i23I3i31I260i7I385i21bI12B31i102I93i61I188i40I75i37I62i26I3b10B1553i12I79i55I967i33I233i28I3i27I129b13B263i39I26i18I60i22I360i8bI13B477i1I35i1I566i13bI9B478i13bI9B63i14bI10B108i14bI11B75b6B51i11bI16B84i30I438i19I35i13I375i66I222i30I32i33I538i38I6i20bI1B2b7B65i89I239i15I104i22I489i19I175i33I145i11bI12B67b7B129i9I1b1Bi48I21f1 10f0 16i27I-- Last Edited:  February 12, 1982  5:44 PM   By:  GWilliams e1(1792)\i--This is a program that runs stand-alone. It reads a file input to a prompt and generates a stream of compressed data. SinkEncoding is now used as a call-back procedure that gets each byte.-- Last Edited:  February 22, 1982  10:10 AM   By:  GWilliams e1\2i188I1i--In order to test this compressor, I am defining new routines to take the output passed through the CompressSpecRec.sink routine, and rebuilds the image being compressed. This is done on a scan-line basis. I.e., compress the line, decompress it, then compare it to the original. All the code added to accomplish this task will be in font 5: Timesroman 8. All original code is font 0: Helvetica 8. Amendment: I've decided to put as much "sink" code into another module (PressNetDecompressor.mesa) as possible. This is because of possible future distributed processing.-- Last Edited:  February 22, 1982  5:07 PM   By:  GWilliams e1\2i395I1i170I1i--Compiling.-- Last Edited:  February 24, 1982  9:56 AM   By:  GWilliams e1\2i10I1i--Importing atomCt and runCt, will use floating point and wf to output statistics.-- Last Edited:  February 24, 1982  3:18 PM   By:  GWilliams e1\2i80I1i--Now write report on a log file of name <Inputfile.cLog>.-- Last Edited:  February 26, 1982  10:11 AM   By:  GWilliams e1\2i56I1i--Report average run length.-- Last Edited:  February 26, 1982  3:38 PM   By:  GWilliams e1\2i26I1i--Now try com.cm for filename and switches first.(635)\2i47I1i1I