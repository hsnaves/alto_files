// IfsBackupCmd2.bcpl -- operator interface for backup system// Copyright Xerox Corporation 1979, 1980, 1981// Last modified October 4, 1981  4:12 PM by Taftget "Ifs.decl"get "IfsSystemInfo.decl"get "IfsFiles.decl"get "IfsBackup.decl"external[// outgoing proceduresBackupStatus; BackupChange; BackupEnable; BackupDisableBackupRepeat; BackupDontRepeat// incoming proceduresGetString; GetNumber; BeginDefaultPhrase; EndDefaultPhraseEnableCatch; EndCatch; SelectKeywordCreateKeywordTable; DestroyKeywordTable; InsertKeyword; GetKeywordGetCreateParams; DestroyCreateParams; CreateIFS; CloseIFSVFileReadPage; VFileWritePage; LockCell; UnlockCellParseDate; WritePackedDT; PutTemplateFree; Ws; Wss; Wns; Errors; MoveBlock; Mul; Div; Zero; IFSPrintError// incoming staticsinfoVMD; sysZone; dsp; backupRunning]//----------------------------------------------------------------------------let BackupEnable(cs) be BackupOnOff(true)//----------------------------------------------------------------------------//----------------------------------------------------------------------------and BackupDisable(cs) be BackupOnOff(false)//----------------------------------------------------------------------------//----------------------------------------------------------------------------and BackupOnOff(value) be//----------------------------------------------------------------------------[Ws(" (backup system)")let bi = VFileWritePage(infoVMD, biPage)bi>>BI.okToGo = value]//----------------------------------------------------------------------------and BackupRepeat(cs) be//----------------------------------------------------------------------------[Wss(cs, " (backups more recent than) ")let timeBackupAfter = vec 1GetDate(cs, timeBackupAfter)MoveBlock(lv VFileWritePage(infoVMD, biPage)>>BI.timeBackupAfter, timeBackupAfter, 2)]//----------------------------------------------------------------------------and BackupDontRepeat(cs) be//----------------------------------------------------------------------------[SelectKeyword(cs, "Repeat")Ws(" (backups)")Zero(lv VFileWritePage(infoVMD, biPage)>>BI.timeBackupAfter, 2)]//----------------------------------------------------------------------------and BackupStatus(cs) be//----------------------------------------------------------------------------[let bi = VFileReadPage(infoVMD, biPage)LockCell(lv bi)PutTemplate(dsp, "*nBackup system is $S and $S.", (bi>>BI.okToGo? "enabled", "disabled"), (backupRunning? "running", "waiting"))if bi>>BI.inProgress then   PutTemplate(dsp, "*n$S working on file $S.",    (backupRunning? "Presently", "Interrupted while"), lv bi>>BI.pathName)PutTemplate(dsp, "*nBackup scheduled between $P and $P.", WritePackedDT, lv bi>>BI.timeStart, WritePackedDT, lv bi>>BI.timeStop)if bi>>BI.timeBackupAfter.h ne 0 then   PutTemplate(dsp, "*nWill repeat backups more recent than $P.",    WritePackedDT, lv bi>>BI.timeBackupAfter)for i = 0 to numBFSD-1 do   [   let bfsd = lv bi>>BI.bfsd^((bi>>BI.iBFSD+i) rem numBFSD)   if bfsd>>BFSD.state eq bfsdEmpty loop   PutTemplate(dsp, "*nFile system $S is ", lv bfsd>>BFSD.id)   switchon bfsd>>BFSD.state into      [      case bfsdUsable:         [         Ws("available to backup system; ")         PutTemplate(dsp,          (bfsd>>BFSD.refresh? "to be re-initialized.", "$ED free pages."),          lv bfsd>>BFSD.freePages)         endcase         ]      case bfsdInUse:         [ Ws("presently in use by backup system"); endcase ]      case bfsdUsed:         [         Ws("no longer usable by backup system*n --")         IFSPrintError(dsp, bfsd>>BFSD.errorCode)         endcase         ]      ]   ]UnlockCell(lv bi)]//----------------------------------------------------------------------------and BackupChange(cs) be//----------------------------------------------------------------------------[Wss(cs, " (backup parameters)*nStart next backup at: ")let bi = nilif EnableCatch(cs) then [ UnlockCell(lv bi); EndCatch(cs) ]bi = VFileWritePage(infoVMD, biPage)LockCell(lv bi)let timeStart = vec 1DefaultDate(cs, lv bi>>BI.timeStart)GetDate(cs, timeStart)Wss(cs, "*nStop next backup at: ")let timeStop = vec 1DefaultDate(cs, lv bi>>BI.timeStop)GetDate(cs, timeStop)Wss(cs, "*nInterval between backup runs (hours): ")let timeInterval = vec 1DefaultNumber(cs, Div(lv bi>>BI.timeInterval, 3600, timeInterval))Mul(0, GetNumber(cs), 3600, timeInterval)Wss(cs, "*nFull file system dump period (days): ")let fullPeriod = vec 1DefaultNumber(cs, Div(lv bi>>BI.fullPeriod, 3600, fullPeriod)/24)Mul(0, GetNumber(cs)*24, 3600, fullPeriod)MoveBlock(lv bi>>BI.timeStart, timeStart, 2)MoveBlock(lv bi>>BI.timeStop, timeStop, 2)MoveBlock(lv bi>>BI.timeInterval, timeInterval, 2)MoveBlock(lv bi>>BI.fullPeriod, fullPeriod, 2)bi>>BI.version = biVersion  //signal that BI is kosher nowUnlockCell(lv bi)]//----------------------------------------------------------------------------and GetDate(cs, time) be//----------------------------------------------------------------------------[let DateBreak(cs, char) = char eq $*n % char eq $*033let str = GetString(cs, DateBreak, Wss, "date and time (dd-mmm-yy hh:mm)")let ok = ParseDate(str, time)Free(sysZone, str)unless ok do Errors(cs, 0)]//----------------------------------------------------------------------------and DefaultDate(cs, time) be//----------------------------------------------------------------------------[if time!0 ne 0 then   [   BeginDefaultPhrase(cs)   WritePackedDT(cs, time)   EndDefaultPhrase(cs)   ]]//----------------------------------------------------------------------------and DefaultNumber(cs, num) be//----------------------------------------------------------------------------[if num ne 0 then   [   BeginDefaultPhrase(cs)   Wns(cs, num)   EndDefaultPhrase(cs)   ]]