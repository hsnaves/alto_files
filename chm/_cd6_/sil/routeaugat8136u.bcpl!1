//routeaugat8136u.bcpl// Board-specific Route routines for the Augat 8136 Universal wire-wrap board// last modified by E. McCreight, November 12, 1978  6:54 PM// all co-ordinates are described with respect to the bottom or// wiring side of the board. LevelTransform fixes these as necessary.get "route.defs"static[(635)\f1maxICs = 300; maxGroup = $C; boardInterfaceVersion = interfaceVersiondeltaYPerGroup; xOfRow1l4269\f1]let DeclareInitialNets(BuildTWNet, BuildTermNet, BuildConnector) be[\f1deltaYPerGroup = 108xOfRow1 = 49*4BuildConnector("E", 26*(maxGroup-$A+1), EPinPos)BuildConnector("C", 26*(maxGroup-$A+1), CPinPos)BuildTWNet("GND", 6*4*(maxGroup-$A+1), GNDPinPos)BuildTWNet("VCC", 6*4*(maxGroup-$A+1), VCCPinPos)l4269\f1]and ZeroTablePoint(point) = selecton point into[\f1case 0: "Augat8136U" // board typecase 1: "E1"case 2: "E13"case 3: "E14"case 4: "E26"default: emptyl4269\f1]and LevelTransform(level, x, y, px, py, pName, pPullComponents, pWire; numargs na) = valof[\f1DefaultArgs(lv na, -1, 0, 0, lv na, lv na, lv na, lv na, lv na)switchon level into[l4269\f1case TopLevel:l5539\f1@px = x@py = 96+108*(maxGroup-$A)-y@pName = "Component side"@pPullComponents = true@pWire = falseresultis truel6809\f1case BottomLevel:l5539\f1@px = x@py = y@pName = "Wiring side"@pPullComponents = false@pWire = trueresultis truel6809\f1default: resultis falsel5539\f1]l4269\f1]and EPinPos(icinst, pin, px, py) = valof[\f1if (pin ls 1) % (pin gr 26*(maxGroup-$A+1)) then resultis illegalpin = pin-1let group = pin/26pin = pin rem 26let row = pin/13let col = 12-(pin rem 13)@py = group*deltaYPerGroup+4*col+20@px = xOfRow1+36-row*4resultis absolutel4269\f1]and CPinPos(icinst, pin, px, py) = valof[\f1if (pin ls 1) % (pin gr 26*(maxGroup-$A+1)) then resultis illegalpin = pin-1let group = pin/26pin = pin rem 26let row = pin/13let col = 12-(pin rem 13)@py = group*deltaYPerGroup+4*col+20@px = xOfRow1+24-row*4resultis absolutel4269\f1]and GNDPinPos(icinst, pin, px, py, pInfo; numargs na) = valof[\f1DefaultArgs(lv na, -4, lv na)@pInfo = noDisconnect+noReconnect+TopLevelif pin le 0 then resultis illegalif pin le 6*4*(maxGroup-$A+1) then[l4269\f1pin=pin-1let group = pin/(6*4)pin = pin rem (6*4)let GndCol = pin/6let GndRow = pin rem 6@px = 24+32*GndRow@py = group*deltaYPerGroup+24*GndCol+16resultis absolutel5539\f1]resultis illegall4269\f1]and VCCPinPos(icinst, pin, px, py, pInfo; numargs na) = valof[\f1DefaultArgs(lv na, -4, lv na)@pInfo = noDisconnect+noReconnect+BottomLevelif pin le 0 then resultis illegalif pin le 6*4*(maxGroup-$A+1) then[l4269\f1pin=pin-1let group = pin/(6*4)pin = pin rem (6*4)let VccCol = pin/6let VccRow = pin rem 6@px = 8+32*VccRow@py = group*deltaYPerGroup+24*VccCol+16resultis absolutel5539\f1]resultis illegall4269\f1]and FindCoordFromString(s, px, py, vop1, hop1; numargs na) = valof[ // vop1 is the "vertical offset" from pin 1, that is, the offset along the 0.1"// spacing; hop1 is the "horizontal offset" from pin 1. In a standard 16-pin// DIP, for pin 2 vop1=4 and hop1=0, and for pin 16, vop1=0 and hop1=12. For// this board, vop1 grows in the -x direction, and hop1 grows in the -y direction.\f1DefaultArgs(lv na, -3, 0, 0)let next = 1let alph = s>>str.char^nextif alph eq $# then [ next = next+1; alph = s>>str.char^next ]if alph ls $A % alph gr maxGroup then resultis illegallet group = alph-$Aalph = s>>str.char^(next+1)if alph ls $A % alph gr $J % alph eq $I then resultis illegallet col = alph eq $J? 8, alph-$Alet row = 0for i=next+2 to s>>str.length do[l4269\f1let c = s>>str.char^iif (c ls $0) % (c gr $9) then resultis illegalrow = 10*row+(c-$0)l5539\f1]row = row-1unless OffsetLegal(row, 1, 0, 49) do resultis illegal@py = group*deltaYPerGroup+12*col+hop1@px = xOfRow1-4*row-vop1resultis absolutel4269\f1]and FindIndexFromCoord(x, y, picclass, pPinNo; numargs na) = valof[\f1manifest[l4269\f1firstEPin = 1firstGNDPin = firstEPin+52firstVCCPin = firstGNDPin+24firstDipPin = firstVCCPin+24firstUnusedPin = firstDipPin+450l5539\f1]if x eq -1 & y eq -1 then resultis firstUnusedPin+(firstUnusedPin-1)*(maxGroup-$A)DefaultArgs(lv na, -2, lv na, lv na)unless OffsetLegal(x, 4, 0, 58)& OffsetLegal(y, 4, 0, 24+27*(maxGroup-$A)) do resultis 0x = x/4y = y/4let group = y/27y = y rem 27let groupBase = group*(firstUnusedPin-1)if x gr 49 then // ..cable or edge pin[l4269\f1x = x-54y = y-5unless OffsetLegal(x,1,0,4)& x rem 3 ne 2 & OffsetLegal(y,1,0,12) do resultis 0resultis groupBase+(x-(x+1)/3)*13+y+firstEPinl5539\f1]if y rem 3 eq 0 then // ..Dip socket pin[l4269\f1let yRepeat = y/3resultis groupBase+50*yRepeat+x+firstDipPinl5539\f1]y = y-4x = x-2if y rem 6 ne 0 % x rem 4 ne 0 then resultis 0let yRepeat = y/6if x rem 8 eq 0 then // ..VCC pinl4269\f1[l4269\f1@picclass = MustFindNamee("VCC", typeIcclass)@pPinNo = 6*4*group+6*yRepeat+x/8+1resultis groupBase+6*yRepeat+x/8+firstVCCPinl5539\f1]// otherwise, must be a GND pinx = x-4@picclass = MustFindNamee("GND", typeIcclass)@pPinNo = 6*4*group+6*yRepeat+x/8+1resultis groupBase+6*yRepeat+x/8+firstGNDPinl4269\f1]\f1