#altoconsts23.mu;	get definitions,constant allocations;On each MRT, decrement the ScanWait counter;	when =0, do a scanner start pulse, and reset counter to ITTIME;	(if counter=0 on entry, just do a reset);;	If the scanner is running, also check for input words, and smash;	them into  ScanBuffer;Dispatch definitions:!17,20,ret,,,,,,,,MRT,,,,,PART;!20,1,START;	return address for emulator restart!37,1,TRAP1;;!120,1,MUL;	!124,20,BLT,BLKS,,,,,,,,,,MUL,DIV,,BITBLT;PART: TASK;	:PART;;REGISTERS USED BY NOVA EMULATOR$AC0	$R3;   ac's are backwards because the hardware supplies		;   the complement address when addressing from ir$AC1	$R2;$AC2	$R1;$AC3	$R0;$NWW	$R4;$SAD	$R5;$PC	$R6;$XREG	$R7;$MTEMP	$R25;$LastL	$R40; not a real S register, but rather L gated to the bus$ScanWait $R14;$ScanBuffer	$R15;$ScanData	$R16;$StoreCount	$R17;;halftone uses: 10,36,5,7;available constants: 177024,25,26,34,40,42$177024	$177024;$177026	$177026;;$Outport	$177016 ;$SafeLoc	$177023;$StepLoc	$177020$420	$420;	417 is StepState$ScanCBHead	$736;	and 737 is Startcommand$ScanTime	$526;$10000	$10000;$4000	$4000;$400	$400;$StatusDONE	$177777;$StatusDATALATE	$177776;;Clock (in refresh task) R11,R37;Ethernet R12,R13;Display controller: R20-R30;Disk Controller: R31-R34;Available: R5rett:	TASK;	most general return (Return&TASK)retn:	NOP;	return, do nop first (prev inst has task)ret:	SWMODE;	:START;	back to ROM!17,20,f0,f1,f2;	,f3,f4,f5,f6,f7,f10,f11,f12,f13,f14,f15,f16,f17;TRAP1: 	SINK_DISP,BUS;	"or" low-order 8 bits of IR into "NEXT"dispatch:	NOP,:f0;;funny locations for stepper control branch%1,1777,520,fstep0;%1,1777,521,fstep1;%1,1777,522,fstep2;%1,1777,523,fstep3;%1,1777,1520,bstep0;%1,1777,1521,bstep1;%1,1777,1522,bstep2;%1,1777,1523,bstep3;;--------------------------------------------------------------------; f2: set RMR;--------------------------------------------------------------------f2: RMR _ AC0,:rett;;--------------------------------------------------------------------; f0: stuffs appropriate S registers with global variables;--------------------------------------------------------------------$jctr		$R41;	counter for repeating/deleting pts in x dir$black		$R42;	minimum value of data $range	$R43;	max-min$outpts	$R44;	number of points to put out per line$inpts		$R45;	number of input points per line$s1		$R46;	vector for storing error propogation$Screen	$R47;$Screenx	$R50;	indexed output pointer$CascadeRight$R51;	error propogation to the right (R Reg for initial shift)$distance	$R52;$yctr		$R53;	counter for repeating/deleting lines in y dir$CascadeDiag	$R54;	error propogation diagonally right$bitOffset	$R55;  bit number of first output bit in first output word (0=leftmost)$temp		$R56;$lineCtr	$R57;	tell user how many lines have gone out;Init(inpts,black,range,outpts,s1,bitOffset,nil,screen,distance)f0: MAR_L_AC0;	NOP;	L_MD,TASK;	inpts_L;	MAR_L_AC0+1;	AC0_L;	L_MD,TASK;	black_L;	MAR_L_AC0+1;	AC0_L;	L_MD,TASK;	range_L;	MAR_L_AC0+1;	AC0_L;	L_MD,TASK;	outpts_L;	T_outpts;	L_0-T;	yctr_L,TASK;	jctr_L;	MAR_L_AC0+1;	AC0_L;	L_MD,TASK;	s1_L;	MAR_L_AC0+1;	AC0_L;	L_MD,TASK;	bitOffset_L;	MAR_L_AC0+1;	AC0_L;	L_MD,TASK;	Screen_L;	NOP;	TASK RETURNS HERE: next instruction uses ALU_SReg	L_Screen-1,TASK;	Screenx_L;	MAR_L_AC0+1;	AC0_L;	L_MD,TASK;	distance_L,:ret;;--------------------------------------------------------------------; f1: does the halftone, updates globals;--------------------------------------------------------------------$val		$R36;	R reg for shift: value of next data point stored here$error		$R7;	R register for shift (XREG: temp only)$error1	$R5;	R register for shift: error rshift 1 (SAD: temp only)$s1x		$R10;	R register for ALU action after TASK: address of next word in s1$GETS	$R60;	address of next sample point in datavec$xctr		$R61;	loop counter across x for reading input points$emask	$R62;	sign bit propogation for shifts$byteptr	$R63;$CurrentBits	$R64;$BitCount	$R65;!1,2,jdone,jloop;!1,2,xloop,xdone;!1,2,xloopL,xloopR;!1,2,ndone,nloop;!1,2,pos,neg;!1,2,NoPut,PutWord;;while yctr ls 0 dof1:	L_0-1;	lineCtr_L;prloop:	L_yctr;	L_lineCtr+1,SH<0;	lineCtr_L,:ndone;nloop:	L_inpts,TASK;	xctr_L;	L_AC0,TASK;	GETS_L;	;NOTE: error in from s1!0 is 1/4 range, so we multiply by 4 to keep the first line honest	;CascadeRight=(s1!0)*2	MAR_L_s1;	L_s1-1;		we increment on the first store	s1x_L;	L_MD;	MTEMP_L LSH 1;	L_MTEMP;	MTEMP_L LSH 1;	L_MTEMP,TASK;	CascadeRight_L;	L_0;	CurrentBits_L;	CascadeDiag_L,TASK;	byteptr_L;;read the initial word, and mask out the bits from bitOffset on (unless bit Offset = 0)!1,2,getPriorBits,noPriorBits;	L_T_bitOffset;	L_20-T,SH=0;	BitCount_L,:getPriorBits;		1,2,getPriorBits,noPriorBitsgetPriorBits:	L_BitCount-1;	T_LastL;	MAR_MASKTAB+T;	NOP;	L_MD;	XMAR_Screenx+1;	T_LastL;	L_MD AND NOT T,TASK;	CurrentBits_L;noPriorBits:	L_T_0;	;for i=1 to x do	;let val=(GETS(picfile)-black) lshift 2xloop:  L_ONE XOR T;	byteptr_L,SH=0;	MAR_GETS,:xloopL;xloopL: T_177400;	L_MD AND T;	AC1_L LCY 8;	L_AC1,:GETdone;xloopR: L_GETS+1;	GETS_L;	T_377;	L_MD AND T;GETdone:T_black;	L_LastL-T,TASK;	val_L LSH 1;	L_val,TASK;	val_L LSH 1;!1,2,SetBit,NoSetBit;		;while jctr ls 0 do	L_jctr;whilej:	T_val,SH<0;	L_CascadeRight-T,:jdone;	;test (CascadeRight-val) ls 0 then [ error=error+range] or SetBit()jloop: 	error_L,SH<0;	T_range,:SetBit;NoSetBit:	L_error+T;SetBitReturn:	error_L,SH<0;!1,2,checkOvPos,checkOvNeg;T_range,:checkOvPos;checkOvNeg:L_error+T;L_error,SH<0,TASK;!1,2,noNegOverflow,NegOverflow;NOP,:noNegOverflow;NegOverflow: T_range;L_0-T,:neg;checkOvPos:L_error-T;L_error,SH<0;!1,2,PosOverflow,noPosOverflow;T_0,:PosOverflow;PosOverflow: L_range,:noPosOverflow;noNegOverflow:	L_error;neg:	T_ONE;	;error=error rshift 1	//arithmetic shiftnoPosOverflow:	error_L MRSH 1,:pos;	;error1=error rshift 1	//arithmetic shiftpos:	L_error,TASK;	*************************************************	error1_L MRSH 1;	;s1!index=CascadeDiag+error1T_error1;	MAR_L_s1x+1;	s1x_L;	L_CascadeDiag+T,TASK;	********************************************	MD_LastL;	;CascadeRight=s1!index+error	;CascadeDiag=error1L_error1;	MAR_s1x+1;	CascadeDiag_L;	T_error;		TASK here  bombs	L_MD+T;	CascadeRight_L;	L_BitCount-1;	BitCount_L,SH=0;	T_inpts,:NoPut;PutWord:L_Screenx+1;Screenx_L;XMAR_Screenx;	MAR_L_Screenx+1;;	Screenx_L;	L_20;	BitCount_L,TASK;	************************************************************	MD_CurrentBits;	L_0;	CurrentBits_L;	T_inpts;NoPut:	L_jctr+T;	no task here: SH not preserved	jctr_L,:whilej;jdone:  T_outpts;	L_jctr-T,TASK;	jctr_L;	NOP;	TASK RETURNS HERE: next instruction uses ALU_SReg	L_xctr-1;	xctr_L,SH=0;	T_byteptr,:xloop;xdone:	T_distance;	L_Screen+T,TASK;	Screen_L;;put out last word,reset ScreenX;if BitCount=20 then done;otherwise, read previous value of Screenx!1; mask out the first (20-BitCount) bits; OR in CurrentBits; write out !1,2,workHard,easyTimeTime;	T_BitCount;	L_17-T;	L_BitCount-1,SH<0;	T_LastL,:workHard;		!1,2,workHard,easyTimeTime;workHard: MAR_MASKTAB+T;	first pick up the mask	NOP;	L_MD,TASK;	temp_L;	XMAR_Screenx+1;	now, the previous value	T_temp;	L_MD AND T;		XMAR_Screenx+1;	and store it  back	T_CurrentBits;	L_LastL OR T;	LastL has (prev contents)&mask	MD_LastL;easyTimeTime: L_Screen-1,TASK;	Screenx_L;	T_inpts;	L_yctr+T,TASK;	yctr_L,:prloop;ndone: T_outpts;	L_yctr-T,TASK;	yctr_L;	L_lineCtr,TASK;	AC0_L,:retn;;---------------------------------------------------------------;setbit turns the bit (index&#17) on.;---------------------------------------------------------------!37,40,GetBit,GetB1,GetB2,GetB3,GetB4,GetB5,GetB6,GetB7,GetB10,GetB11,GetB12,GetB13,GetB14,GetB15,GetB16,GetB17,GetB20;	;CurrentBits=CurrentBits % (#100000 rshift (index&#17))SetBit: SINK_BitCount,BUS;	BitCount is between 20 and 1	T_CurrentBits,:GetBit;GetBit:	NOP;GetB20:  L_100000 OR T,TASK,:HaveBit;GetB17:  L_40000 OR T,TASK,:HaveBit;GetB16:  L_20000 OR T,TASK,:HaveBit;GetB15:  L_10000 OR T,TASK,:HaveBit;GetB14:  L_4000 OR T,TASK,:HaveBit;GetB13:  L_2000 OR T,TASK,:HaveBit;GetB12:  L_1000 OR T,TASK,:HaveBit;GetB11:  L_400 OR T,TASK,:HaveBit;GetB10:  L_200 OR T,TASK,:HaveBit;GetB7:  L_100 OR T,TASK,:HaveBit;GetB6:  L_40 OR T,TASK,:HaveBit;GetB5:  L_20 OR T,TASK,:HaveBit;GetB4:  L_10 OR T,TASK,:HaveBit;GetB3:  L_4 OR T,TASK,:HaveBit;GetB2:  L_2 OR T,TASK,:HaveBit;GetB1:  L_ONE OR T,TASK,:HaveBit;HaveBit: CurrentBits_L;	L_error,:SetBitReturn;;--------------------------------------------------------------------; MRT: do start pulses off MRT task, for constant timing;--------------------------------------------------------------------;MEMORY REFRESH TASK AND MOUSE HANDLER!17,20,TX0,TX6,TX3,TX2,TX8,TX5,TX1,TX7,TX4,,,,,,,;!1,2,DOTIMER,NOTIMER;!1,2,NOTIMERINT,TIMERINT;!1,2,DOCUR,NOCUR;!1,2,SHOWC,WAITC;!1,2,SPCHK,NOSPCHK;!1,2,NOCLK,CLOCK;!1,1,MRTLAST;!1,2,CNOTLAST,CLAST;$CLOCKTEMP$R11;$REFZERO     $7774;  REFRESH ZERO$REFIIMSK    $7777; REFRESH MASK$R37			$R37;$CURX	$R20;$CURDATA	$R21;$YPOS	$R27;;		* * * A T T E N T I O N * * *;There are two versions of the Memory refresh code:;	AltoIIMRT4K.mu 		for refreshing 4K chips;	AltoIIMRT16K.mu		for refreshing 16K chips;first time initializationMRT:	MAR _ ScanTime;	L_0;	ScanBuffer_L;	StoreCount_L; 	L_MD;	MAR _ 420-1;	ScanWait_L;	MD _ StoreCount;;On each MRT, decrement the ScanWait counter;	when =0, do a scanner start pulse, and reset counter to ITTIME;	(if counter=0 on entry, just do a reset);;	If the scanner is running, also check for input words, and smash;	them into  ScanBuffer!1,2,ScannerOn,ScannerOff;!1,2,checkInput,startScan;!1,2,haveHead,noHead;!1,2,haveCurrent,noCurrent;!1,2,doMouse,doWord;MRTloop: L_ScanWait-1,BUS=0;	1MAR_ScanTime,:ScannerOn; !1,2,ScannerOn,ScannerOff	2ScannerOn: NOP,SH=0;	3ScanWait_L,:checkInput;	!1,2,checkInput,startScan;	4;unless StoreCount is 0, read bytes and decrement StoreCount;between MAR_StepLoc and L_MD you need:;	5 NOPs if running at -11 volts;	6 NOPs if running at -10 volts!1,2,doCount,noCount;!1,2,oddByte,evenByte;!1,2,read1,done1;!1,2,doMouse1,doWord1;!1,2,haveBuffer1,noBuffer1;!1,2,read2,done2;!1,2,doMouse2,doWord2;!1,2,read3,done3;!1,2,doMouse3,doWord3;!1,2,haveBuffer3,noBuffer3;!1,2,doMouse4,done4;!1,2,StoreCountZero,noCountMouse;checkInput: T _ StoreCount,BUS=0;	5	T _ StoreCount,:doCount;	!1,2,doCount,noCount;	6doCount: MAR_177024-1;		SafeLoc;	7	L _ ONE AND T;	BUSODD doesn't work for MRT	8	T _ 377,SH=0;	9	L _ MD,:oddByte;	!1,2,oddByte,evenByte;	10;on even: must reset MAR to enable flop to toggle for stepevenByte: L _ MD AND T,SH<0,TASK;	11	ScanData _ L LCY 8,:doMouse;	!1,2,doMouse,doWord;	12doWord:	MAR_T_20;	13	MAR_177000+T;	StepLoc;	must allow 6 cycles before reading from XBus	14	L _ StoreCount - 1;	15	StoreCount _ L,SH=0,TASK;	16	NOP,:read1;	!1,2,read1,done1;	17read1: MAR_177024-1;	in case TASK was taken	18		NOP;	19		T_377;	20		L_MD;	21oddByte: T _ MD.T,SH<0;	22	T _ ScanData OR T,:doMouse1;	!1,2,doMouse1,doWord1;	23doWord1:	MAR_ScanBuffer+1,BUS=0;	24	L_ALLONES XOR T,:haveBuffer1; !1,2,haveBuffer1,noBuffer1;	25haveBuffer1:	ScanData_L,TASK;	2x	MD _ ScanData;	2x	MAR_T_20;	2x	MAR_177000+T;	StepLoc;	must allow 5 cycles before reading from XBus	2x	L _ StoreCount - 1;	3x	StoreCount _ L,SH=0;	3x	L_ScanBuffer+1,:read2;	!1,2,read2,done2;	3xnoBuffer1:	MAR_T_20;	2x	MAR_177000+T;	StepLoc;	must allow 5 cycles before reading from XBus	2x	L _ StoreCount - 1;	3x	StoreCount _ L,SH=0;	3x	L_0,:read2;	!1,2,read2,done2;	3xread2: MAR_177024-1;	in case TASK was taken;	3x		ScanBuffer_L;	3x		T_377;	3x		L_MD;	3x	L _ MD AND T,SH<0;	3x	ScanData _ L LCY 8,:doMouse2;	!1,2,doMouse2,doWord2;	3xdoWord2:	MAR_T_20;	3x	MAR_177000+T;	StepLoc;	must allow 5 cycles before reading from XBus	40	L _ StoreCount - 1;	4x	StoreCount _ L,SH=0,TASK;	4x	NOP,:read3;	!1,2,read3,done3;	43read3: MAR_177024-1;	in case TASK was taken;	4x		NOP;	4x		T_377;	4x		L_MD;	4x	T _ MD.T,SH<0;	4x	T _ ScanData OR T,:doMouse3;	!1,2,doMouse3,doWord3;	4xdoWord3:	MAR_ScanBuffer+1,BUS=0;	5x	L_ALLONES XOR T,:haveBuffer3; !1,2,haveBuffer3,noBuffer3;	5xhaveBuffer3:	ScanData_L,TASK;	5x	MD _ ScanData;	5x	MAR_T_20;	5x	MAR_177000+T;	StepLoc;	must allow 5 cycles before reading from XBus	5x	L _ StoreCount - 1;	5x	StoreCount _ L;	5x	L_ScanBuffer+1,SH=0,TASK;	ScanBuffer_L,:doMouse4;	!1,2,doMouse4,done4;noBuffer3:	MAR_T_20;	5x	MAR_177000+T;	StepLoc;	must allow 5 cycles before reading from XBus	5x	L _ StoreCount - 1;	5x	StoreCount _ L,SH=0,TASK;	NOP,:doMouse4;	!1,2,doMouse4,done4;;make ScanBuffer non-zero (in case of no buffer)done1: L_ALLONES,:done;	18done2: L_ALLONES,:done;	33done3: L_ALLONES,:done;	44done4: L_ALLONES,:done;	59done: ScanBuffer_L,:noMouse;	60;come here when storecount is exhausted;if ScanBuffer = 0 then NOP (wait for next START time to examine CBHead);	otherwise, mark current head "DONE", dequeue, and do next command;	(adjacent reads allow windowing, and stepper wants to go before next START);need to do something if requested read was odd number of bytesnoCount: SINK_ScanBuffer,BUS=0;	7	MAR_ScanCBHead,:StoreCountZero;	!1,2,StoreCountZero,noCountMouse;	8StoreCountZero:	NOP;	9	NOP;	1x	L_MD+1,BUS=0;	1x!1,2,ScanCBHeadOK,ScanCBHead0;	driver may have zeroed ScanCBHead	ScanBuffer_L,:ScanCBHeadOK;ScanCBHead0: NOP,:noCurrent;ScanCBHeadOK:	MAR _ ScanBuffer + 1;		NOP;		TASK;		MD _ StatusDONE;		MAR _ ScanBuffer - 1;		NOP;		NOP;		L _ MD;	--link		MAR _ ScanCBHead;		MTEMP_L,L_0;	5x	ScanBuffer_L,TASK;		MD_MTEMP,:noCurrent;	startScan:L_MD;	5;quick like a bunny pulse start, then (whew!) you can TASKMAR_ScanCBHead+1;	StartCommand	6T _ 10;	get ready for faking 177016	7ScanWait_L; 	8L_MD;	9MAR_177026-T;	Outport;	10T_200;	11ScanData_L;	12MD_ScanData,L_ScanData OR T;<0><START><SkipCount>;	START=7	13T_10;	1xMAR_177026-T;	Outport;	1xMTEMP _ L,TASK;	<1><START><SkipCount>;	16-17MD_MTEMP;	1xT _ 10;	19MAR_ 177026-T;	Outport;	2xNOP;	2x	SINK_ScanBuffer,BUS=0;	22MD_ScanData,:haveCurrent;	!1,2,haveCurrent,noCurrent;	23;there is a current scan buffer: mark it DataLate, clear CB queuehaveCurrent: MAR _ ScanCBHead;	22	NOP;	23	NOP;	24	L_MD+1,BUS=0,TASK;	25!1,2,HeadOK,Head0;	driver may have zeroed ScanCBHead	ScanBuffer _ L,:
HeadOK;	!1,2,HeadOK,Head0;	2xHeadOK:	MAR _ ScanBuffer;	2x	NOP;	28	TASK;	29	MD _ StoreCount;	30	MAR _ ScanBuffer + 1;	31	NOP;	32	TASK;	3x	MD _ StatusDATALATE;	3xHead0:	L_0;	3x	MAR _ ScanCBHead;	3x	ScanBuffer _ L;	3x	StoreCount _ L;	3x	MD _ ScanBuffer,:doMouse;	39;check for available input buffernoCurrent: MAR_ScanCBHead;	24L_0;	25StoreCount_L;	2xL_MD,BUS=0;	2xScanBuffer_L,:haveHead;	!1,2,haveHead,noHead;	2x;ScanCB structure:;	link;	command (Read,Delay,Forward,Back);	status/count (negative = status, pos=count);	buffer!3,4,CommandREAD,CommandDELAY,CommandFORWARD,CommandBACK;haveHead: 	MAR_L_ScanBuffer+1;	29	ScanBuffer_L;	3x	T _ 10;	3x	SINK_MD,BUS;	3x	L _ 177026-T,:CommandREAD;	3x!1,2,realBuffer,dummyBuffer;CommandREAD: MAR _ L _ ScanBuffer+1;	34	ScanBuffer _ L;	35	NOP;	36	L_MD;	3x	MAR _ ScanBuffer + 1;	3x	StoreCount _ L;	doesn't work for odd scan counts	3x	NOP;	40	L _ MD-1,BUS=0,TASK;	4x	ScanBuffer _ L,:realBuffer;	42dummyBuffer: L_0;	43	ScanBuffer_L,:noMouse;	44;DELAY: wait until next start pulse (just throw command away)CommandDELAY: NOP,:dequeueCB;	35$521	$521;$523	$523;;	MOTORCTL=5;<00000000><ENABLE><MOTORCTL><xxxx>	;0101xxxx = disabled = 120 (521 available)CommandBACK:	MAR _ 420-1;	MTEMP_L;	set up to be Outport=177016	SINK _ MD,BUS;	MAR_MTEMP,:bstep0;	Outport;	34;sequence is: 1,0,2,3	bstep0:L_523-1,:stepDone;	#522	bstep1:L_521-1,:stepDone;	#520	bstep2:L_523,:stepDone;	#523	bstep3:L_521,:stepDone;	#521CommandFORWARD:	MAR _ 420-1;	MTEMP_L;	set up to be Outport=177016	SINK _ MD,BUS;	MAR_MTEMP,:fstep0;	Outport;	34;sequence is: 3,2,0,1	fstep0:L_521,:stepDone;		#521	fstep1:L_523,:stepDone;		#523	fstep2:L_521-1,:stepDone;	#520	fstep3:L_523-1,:stepDone;	#522stepDone: ScanData_L;	MD_ScanData;	<0><MOTORCTL><StepState>	T_200;	MAR_MTEMP;	L_ScanData OR T;	ScanData_L;	MD _ ScanData;	<1><MOTORCTL><StepState>	MAR_MTEMP;	L_ScanData XOR T;	ScanData_L;	MD _ ScanData;	<0><MOTORCTL><StepState>	MAR _ 420-1;	store updated value	TASK;	MD_ScanData,:dequeueCB;;take CB off queue, mark DONE, store ScanData into OutportdequeueCB: MAR _ ScanBuffer + 1;	43	NOP;	44	TASK;	4x	MD _ StatusDONE;	4x	MAR _ ScanBuffer - 1;		NOP;		NOP;		L _ MD;	--link		MAR _ ScanCBHead;	5x	MTEMP_L,L_0;	5x	ScanBuffer_L,TASK;	5x	MD_MTEMP,:noMouse;	59ScannerOff: NOP;	3NOP;	4L_MD;	5ScanWait_L,:doMouse;	6realBuffer: MAR_ R37,:MRTA;	43noHead: MAR_ R37,:doMousex;	29doMouse1: MAR_ R37,:doMousex;	24doMouse2: MAR_ R37,:doMousex;	39doMouse3: MAR_ R37,:MRTA;	50doMouse4: MAR_ R37,:MRTA;doMouse5: MAR_ R37,:MRTA;	59noCountMouse: MAR_ R37,:doMousex;	9;special code for long MRT cycles: don't update mousenoMouse: MAR_R37,:MRTA;	63doMouse:MAR_ R37;		**FIRST REFRESH CYCLE**	40doMousex:	SINK_ MOUSE, BUS;	MOUSE DATA IS ANDED WITH 17BMRTA:	L_ T_ -2, :TX0;		DISPATCH ON MOUSE CHANGE	42,64TX0:	L_ R37 AND NOT T, T_ R37;INCREMENT CLOCK	65	T_ 3+T+1, SH=0;		IE. T_ T +4.  IS INTV TIMER ON?	66	L_REFIIMSK AND T,:DOTIMER;[DOTIMER,NOTIMER]ZERO HIGH 4 BITS	67NOTIMER: R37_ L; 		STORE UPDATED CLOCK	68(better have timer off)NOTIMERINT: T_ 2;		NO STATE AT THIS POINT IN PUBLIC REGS	69	MAR_ R37 XOR T,T_ R37;	**SECOND REFRESH CYCLE**	70	L_ REFZERO AND T;	ONLY THE CLOKCK BITS, PLEASE	71	SH=0, TASK;		TEST FOR CLOCK OVERFLOW	72	:NOCLK;			[NOCLK,CLOCK]	73NOCLK:	T _ 200;	81	MAR_ R37 XOR T;		**THIRD FEFRESH CYCLE**	82	L_ CURX, BLOCK;		CLEARS WAKEUP REQUEST FF	8x	T_ 2 OR T, SH=0;	NEED TO CHECK CURSOR?	8x	MAR_ R37 XOR T, :DOCUR;	**FOURTH REFRESH CYCLE**	85NOCUR:	CURDATA_ L, TASK;	86MRTLAST:CURDATA_ L, :MRTloop;	END OF MAIN LOOP	90DOTIMER:R37_ L;			STORE UPDATED CLOCKL_0;	if we ever get here, swat break at 0PC_L;	MAR_ EIALOC;		INTERVAL TIMER/EIA INTERFACE	L_ 2 AND T;	SH=0, L_ T_ REFZERO.T;	***V3 CHANGE (USED TO BE BIAS)	CURDATA_L, :SPCHK;	CURDATA_ CURRENT TIME WITHOUT CONTROL BITSSPCHK:	SINK_ MD, BUS=0, TASK;	CHECK FOR EIA LINE SPACINGSPIA:	:NOTIMERINT, CLOCKTEMP_ L;NOSPCHK:L_MD;			CHECK FOR TIME = NOW	MAR_TRAPDISP-1;		CONTAINS TIME AT WHICH INTERRUPT SHOULD HAPPEN	MTEMP_L;		IF INTERRUPT IS CAUSED,	L_ MD-T;		LINE STATE WILL BE STORED	SH=0, TASK, L_MTEMP, :SPIA;TIMERINT:MAR_ ITQUAN;		STORE THE THING IN CLOCKTEMP AT ITQUAN	L_ CURDATA;	R37_ L;	T_NWW;			AND CAUSE AN INTERRUPT ON THE CHANNELS 	MD_CLOCKTEMP;		SPECIFIED BY ITQUAN+1	L_MD OR T, TASK;	NWW_L,:NOTIMERINT;CLOCK:	MAR_ CLOCKLOC;	R37 OVERFLOWED. UPDATE CLOCK	74	NOP;	75-76	L_ MD+1;	7x	MAR_ CLOCKLOC;	7x	MTEMP_ L, TASK;	79	MD_ MTEMP, :NOCLK;	80DOCUR:	L_ T_ YPOS;	CHECK FOR VISIBLE CURSOR ON THIS SCAN	86	SH < 0, L_ 20-T-1; ***x13 change: the constant 20 was 17	87	SH<0, L_ 2+T, :SHOWC;	88WAITC:	YPOS_ L, L_ 0, TASK, :MRTLAST;	89SHOWC:	MAR_ CLOCKLOC+T+1, :CNOTLAST;	89CNOTLAST:	T_ CURX, :CURF;	90CLAST:	T_ 0;	90CURF:	YPOS_ L, L_ T;	91	CURX_ L;	92	L_ MD, TASK;	93	CURDATA_ L, :MRTloop;;AFTER THIS DISPATCH, T WILL CONTAIN XCHANGE, L WILL CONTAIN YCHANGE-1TX1:	L_ T_ ONE +T, :M00;		Y=0, X=1			43TX2:	L_ T_ ALLONES, :M00;		Y=0, X=-1			43TX3:	L_ T_ 0, :M00;			Y=1, X= 0			43TX4:	L_ T_ ONE AND T, :M00;		Y=1, X=1			43TX5:	L_ T_ ALLONES XOR T, :M00;	Y=1, X=-1			43TX6:	T_ 0, :M00;			Y= -1, X=0			43TX7:	T_ ONE, :M00;			Y= -1, X=1			43TX8:	T_ ALLONES, :M00;		Y= -1, X= -1			43M00:	MAR_ MOUSELOC;		START THE FETCH OF THE COORDINATES	44	MTEMP_ L;			YCHANGE -1	45-46	L_ MD+ T;			X+ XCHANGE	47	T_ MD;				Y	48	T_ MTEMP+ T+1;			Y+ (YCHANGE-1) + 1	49	MTEMP_ L, L_ T;	50	MAR_ MOUSELOC;		NOW RESTORE THE UPDATED COORDINATES	51	CLOCKTEMP_ L;	52-53	MD_ MTEMP, TASK;54	MD_ CLOCKTEMP, :MRTA;55(635)\f1 2060f0 52f1 7154f0 173f1 69i1I14i1I