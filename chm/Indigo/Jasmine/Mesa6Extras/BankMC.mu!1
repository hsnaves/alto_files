;Alto microcode file, incorporating jasmine, halftoning, and long pointer ops;Free Registers (bold if it stays around):;careful: low regs used by MUL,DIV;1,2,3,5,7,14,41-47,51,55-57,(60-67 = stack),71-77#AltoConsts23.MU;!17,20,Emulator,L1,L2,L3,L4,L5,L6,L7,MRT,L11,L12,L13,L14,L15,L16,L17;%1,1777,120,MUL;%1,1777,121,DIV;%1,1777,40,mulret1;%1,1777,41,divret1;%1,1777,42,mulret2;%1,1777,43,divret2;%1,1777,440,Read;%1,1777,441,Write;;halftone stuff%1,1777,442,print;%1,1777,443,init;%1,1777,444,interpolate;;defined under Misc.: %1,1777,453,scream; --super fast 4 bit stuff;ReadLong,WriteLong%1,1777,445,ReadLong;%1,1777,446,WriteLong;;MoveBlock (BLT)%1,1777,447,BLT;%1,1777,450,SetBlock;;Misc.%1,1777,451,GetTime;%1,1777,452,DoRun;%1,1777,453,scream; --super fast 4 bit halftone%1,1777,454,Shift2;%1,1777,477,SetBLV;;funny locations for stepper control branch%1,1777,520,fstep0;%1,1777,521,fstep1;%1,1777,522,fstep2;%1,1777,523,fstep3;%1,1777,1520,bstep0;%1,1777,1521,bstep1;%1,1777,1522,bstep2;%1,1777,1523,bstep3;#XMesaRAM.MU;;-----------------------------------------------------------------; MISC - Miscellaneous instructions specified by alpha;	alpha=11 => RCLK has been handled by ROM;	T contains alpha on arrival at MISC in RAM;-----------------------------------------------------------------; Precisely one of the following lines must be commented out.MISC:		L_0, SWMODE, :Setstkp;			dummy MISC implementation;#MesaMisc.mu;						real implementation$START	$L004020,0,0;Emulator: SWMODE;L1: NOP,:START;	location 20= Nova emulator start (StartIO from NovaCode);L2: TASK,:L2;L3: TASK,:L3;L4: TASK,:L4;L5: TASK,:L5;L6: TASK,:L6;L7: TASK,:L7;L11: TASK,:L11;L12: TASK,:L12;L13: TASK,:L13;L14: TASK,:L14;L15: TASK,:L15;L16: TASK,:L16;L17: TASK,:L17;;one of the next two lines must be commented out#JasmineMC.MU;;MRT: TASK,:MRT;;#xhalftone.mu;#D0Halftone.mu;;#DoRunMC.MU;;#MiscMC.MU;SetBLV: L_0;	stkp_L,SWMODE;	RMR_stk0,:romnextA;;SetBlock[dest,destBank,value,nwords];SetBlock: MAR _ 177740;NOP;L _ MD,TASK;temp _ L;MAR _ 177740;NOP,TASK;MD _ stk1;;now, rearrange nwords to count down to 0T_stk3;L _ stk0+T;stk0_L;L _ 0 - T;stk3 _ L;!1,2,moreSetBlock,doneSetBlock;contSetBlock: T _ stk3,BUS=0;XMAR _ stk0 + T,:moreSetBlock;moreSetBlock: L_stk3+1;stk3_L,TASK;MD _ stk2,:contSetBlock;doneSetBlock: MAR _ 177740;L _ 0;stkp _ L,SWMODE;MD _ temp,:romnextA;;MoveBlock[dest,destBank,src,srcBank,nwords];BLT: L_stk1,TASK;temp2 _ L LSH 1;MAR _ 177740;L _ temp2;temp2 _ L LSH 1;L _ MD,TASK;temp _ L;MAR _ 177740;T _ stk3;L _ temp2 + T,TASK;MD _ LREG;;now, rearrange nwords to count down to 0!1,2,bothEven,destEvenSrcOdd;!1,2,destEven,destOdd;!1,2,destOddSrcEven,bothOdd;T _ stk4;L _ stk0 + T,BUSODD;stk0 _ L,:destEven;destEven: L _ stk2 + T,BUSODD;stk2 _ L,:bothEven;destOdd: L _ stk2 + T,BUSODD;stk2 _ L,:destOddSrcEven;!1,2,MoreBLTEE,BLTDoneEE;!1,2,MoreBLTOO,BLTDoneOO;!1,2,MoreEE,PerhapsDoneEE;!1,2,MoreBLT,BLTDone;bothOdd: L _ 0 - T;stk4 _ L,SH=0,TASK;NOP,:MoreBLTOO;MoreBLTOO: L _ T _ stk4;XMAR _ stk2 + T;L _ stk4 + 1;stk4 _ L;L _ MD;MAR _ stk0 + T;SINK _ stk4,BUS=0,TASK;MD _ LREG,:MoreBLTEE;bothEven: L _ 0-T;stk4 _ L,SH=0,TASK;NOP,:MoreBLTEE;MoreBLTEE: L _ T _ stk4;ContBLTEE: XMAR _ stk2 + T;stk4 _ L;L _ 2 + T;stk5 _ L,ALUCY;L _ MD,:MoreEE;MoreEE: T _ MD,TASK;temp2 _ L,L _ T;	*****M preserved across taskT _ stk4;MAR _ stk0 + T;T _ stk5;MD _ temp2;MD _ LREG,L _ T,:ContBLTEE;PerhapsDoneEE: temp2 _ L,L _ T,:PerhapsDone;PerhapsDone: MAR _ stk0 + T;L _ LREG + 1;stk4 _ L,SH=0,TASK;MD _ temp2,:MoreBLT;destOddSrcEven: NOP;destEvenSrcOdd: L _ 0-T;stk4 _ L,SH=0,TASK;NOP,:MoreBLT;	!1,2,MoreBLT,BLTDone;;and the tight ass loopMoreBLT: T _ stk4;XMAR _ stk2 + T;L _ stk4 + 1;stk4 _ L;L _ MD;MAR _ stk0 + T;SINK _ stk4,BUS=0,TASK;MD _ LREG,:MoreBLT;	!1,2,MoreBLT,BLTDone;BLTDoneEE: NOP,:BLTDone;BLTDoneOO: NOP,:BLTDone;BLTDone: MAR _ 177740;L _ 0;stkp _ L,SWMODE;MD _ temp,:romnextA;;Read[address,bank] RETURNS [value];!7,10,r0,r1,r2,r3;Read: MAR _ 177740;	--bank register for task 0 (emulator)L_stkp - 1;stkp _ L;L _ MD;MAR _ 177740;	--hardware registers don't do double word, or exchangeSINK _ stkp,BUS;temp _ L,TASK,:r0;r1: MD _ stk1;XMAR _ stk0;NOP;L _ MD;MAR _ 177740;stk0 _ L,SWMODE,:r0;r2: MD _ stk2;XMAR _ stk1;NOP;L _ MD;MAR _ 177740;stk1 _ L,SWMODE,:r0;r3: MD _ stk3;XMAR _ stk2;NOP;L _ MD;MAR _ 177740;stk2 _ L,SWMODE,:r0;r0: MD _ temp,:romnextA;;Write[address,bank,value];Write: MAR _ 177740;	--bank register for task 0 (emulator)L _ 0;stkp _ L;L_MD;MAR _ 177740;temp _ L,TASK;MD _ stk1;XMAR _ stk0;TASK;MD _ stk2;MAR _ 177740;SWMODE;MD _ temp,:romnextA;;ReadLong[address,bank] RETURNS [2 word value];(635)\f1 96b4B68b2B32b5B90b115B3682b37B471b28B199b!7,10,rL0,,rL2,rL3,rL4,rL5;ReadLong: MAR _ 177740;	--bank register for task 0 (emulator)NOP;L_MD;MAR _ 177740;SINK _ stkp,BUS;temp _ L,TASK,:rL0;rL2: MD _ stk1;XMAR _ stk0;NOP;L _ MD;XMAR _ stk0 + 1;stk0 _ L;L _ MD;MAR _ 177740;stk1 _ L,SWMODE,:rL0;rL3: MD _ stk2;XMAR _ stk1;NOP;L _ MD;XMAR _ stk1 + 1;stk1 _ L;L _ MD;MAR _ 177740;stk2 _ L,SWMODE,:rL0;rL4: MD _ stk3;XMAR _ stk2;NOP;L _ MD;XMAR _ stk2 + 1;stk2 _ L;L _ MD;MAR _ 177740;stk3 _ L,SWMODE,:rL0;rL5: MD _ stk4;XMAR _ stk3;NOP;L _ MD;XMAR _ stk3 + 1;stk3 _ L;L _ MD;MAR _ 177740;stk4 _ L,SWMODE,:rL0;rL0: MD _ temp,:romnextA;;WriteLong[address,bank,val1,val2];WriteLong: MAR _ 177740;	--bank register for task 0 (emulator)L _ 0;stkp _ L;L_MD;!1,2,WriteLongDouble,WriteLongSingle;MAR _ 177740;SINK _ stk0,BUSODD;temp _ L,TASK,:WriteLongDouble;WriteLongDouble: MD _ stk1;XMAR _ stk0;NOP;MD _ stk2,TASK;MD _ stk3,: WriteLongDone;WriteLongSingle: MD _ stk1;XMAR _ stk0;TASK;MD _ stk2;XMAR _ stk0 + 1;TASK;MD _ stk3;WriteLongDone: MAR _ 177740;SWMODE;MD _ temp,:romnextA;\f1 637b36B