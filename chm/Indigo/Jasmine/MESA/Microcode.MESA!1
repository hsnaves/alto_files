--functions for Alto and D0 MicrocodeDIRECTORY	AltoMicrocodeDefs: FROM "AltoMicrocodeDefs",	D0MicrocodeDefs: FROM "D0MicrocodeDefs",	MiscDefs: FROM "MiscDefs" USING [DestroyFakeModule],	MemoryOps: FROM "MemoryOps" USING [GetMemoryConfig,MachineType],	Mopcodes: FROM "Mopcodes" USING [zMISC],	RamDefs: FROM "RamDefs",	SegmentDefs: FROM "SegmentDefs" USING		[FileSegmentAddress,FileSegmentHandle,SwapIn,SwapOut,Unlock];Microcode: PROGRAM IMPORTS AltoMicrocodeDefs, D0MicrocodeDefs, MemoryOps, MiscDefs, RamDefs, SegmentDefs EXPORTS AltoMicrocodeDefs, D0MicrocodeDefs =BEGINLRJBlock: TYPE = RECORD [	VersionID: CARDINAL,	--current version is 0	AllOnes: CARDINAL,	--high order 12 bits must be all ones	CheckSum: CARDINAL, --unused	StartAddr: CARDINAL ];EndBlock: LRJBlock _ [0,177777B,0,0];LoadRamAndJump: PROCEDURE [LONG POINTER, BOOLEAN] =	MACHINE CODE BEGIN	Mopcodes.zMISC,3;	END;LoadRamAndJumpArg: PROCEDURE [UNSPECIFIED, LONG POINTER, BOOLEAN] =	MACHINE CODE BEGIN	Mopcodes.zMISC,3;	END;LoadRamAndJumpRslt: PROCEDURE [LONG POINTER, BOOLEAN] RETURNS [UNSPECIFIED] =	MACHINE CODE BEGIN	Mopcodes.zMISC,3;	END;LoadRamAndJumpArgRslt: PROCEDURE [UNSPECIFIED, LONG POINTER, BOOLEAN] RETURNS [UNSPECIFIED] =	MACHINE CODE BEGIN	Mopcodes.zMISC,3;	END;JumpRam: PUBLIC PROCEDURE [RAMAddress: [0..7777B]] =BEGINEndBlock.StartAddr _ RAMAddress;LoadRamAndJump[@EndBlock,TRUE];END;JumpRamArg: PUBLIC PROCEDURE [RAMAddress: [0..7777B],Argument: UNSPECIFIED] =BEGINEndBlock.StartAddr _ RAMAddress;LoadRamAndJumpArg[Argument,@EndBlock,TRUE];END;JumpRamRslt: PUBLIC PROCEDURE [RAMAddress: [0..7777B]] RETURNS [UNSPECIFIED] =BEGINEndBlock.StartAddr _ RAMAddress;RETURN[LoadRamAndJumpRslt[@EndBlock,TRUE]];END;JumpRamArgRslt: PUBLIC PROCEDURE [RAMAddress: [0..7777B],Argument: UNSPECIFIED]	RETURNS [UNSPECIFIED] =BEGINEndBlock.StartAddr _ RAMAddress;RETURN[LoadRamAndJumpArgRslt[Argument,@EndBlock,TRUE]];END;z18591l3008(635)\f1 584b9B177b8B31b14B84b17B97b18B106b21B119b7B122b11B156b12B156b15B--Kludge to make sure module is started from altoLoadRam: PUBLIC PROCEDURE =BEGINEND; uImageFile: SegmentDefs.FileSegmentHandle;uCode: POINTER;offset: CARDINAL;machine: MemoryOps.MachineType _ MemoryOps.GetMemoryConfig[].AltoType;IF machine IN [AltoIIXM..D0] THEN	BEGIN	[uImageFile,offset] _ 	 	MiscDefs.DestroyFakeModule[LOOPHOLE[		  (IF machine = D0 THEN D0MicrocodeDefs.MicrocodeImage			ELSE AltoMicrocodeDefs.MicrocodeImage)]];	SegmentDefs.SwapIn[uImageFile];	uCode _ SegmentDefs.FileSegmentAddress[uImageFile]+offset;	IF machine = D0 THEN LoadRamAndJump[uCode,FALSE]	ELSE [] _ RamDefs.LoadRamAndBoot[LOOPHOLE[uCode-20B],FALSE];	SegmentDefs.Unlock[uImageFile];	SegmentDefs.SwapOut[uImageFile];	END;END.\f1b57B