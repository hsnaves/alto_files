-- FILE:  RamDefs.mesa  Last Edited by Swinehart, March 15, 1980  4:19 PMz20320l3316d2998(0,65535)(14,10795)DIRECTORYz20320l3316d2998x0e6PrivateRamDefs: FROM "PrivateRamDefs";z20320l3951d3633x0RamDefs: DEFINITIONS =z20320l3316d2998x0e6BEGIN -- module bodyz20320l3316d2998x0e1-- C O M P I L E - T I M E   C O N S T A N T S   A N D   T Y P E Sz20320l3316d2998x0e10k80\3b63BBootLocusVector: TYPE = PrivateRamDefs.BootLocusVector;z20320l3316d2998x0e6k80\24i15IMuImage: TYPE = POINTER TO PrivateRamDefs.PackedMuFile;z20320l3316d2998x0e6k80\27i15I-- T H E   I N T E R F A C Ez20320l3316d2998x0e6k80\3b25BLoadRamAndBoot: PROCEDURE[m: MuImage, boot: BOOLEAN,bank: [0..2]_0] RETURNS [constDiffs: CARDINAL];-- loads the ram from the MuImage, checks the constants and returns number of constant mismatches.  If boot=TRUE, also does a silent boot: first, a silent boot is done to guarantee that the machine is in ground state (everything running in ROM0 - ok for Mesa?) and then, after loading the ram image, another silent boot is done as specified in the blv field of the MuImage.  On 3K RAM machines, loads image into whichever microcode RAM bank is specified.  Caution: if bank#0 AND boot, destroys locations 0 and 1 in bank 0.z20320l3316d2998x0e6jk80\b14BReadBlv: PROCEDURE[m: MuImage] RETURNS [BootLocusVector] = INLINEz20320l3316d2998x0e6jk80\b7BBEGIN RETURN [m.blv] END;z20320l3951d3633jk80NoEtherNetBoard: ERROR;z20320l3316d2998x0e6jk80\b15BSilentBoot: PROCEDURE[blv: BootLocusVector];-- check to see that a silent boot is possible (I.e., that Alto has an EtherNet board), sets boot locus vector and does the StartIO to cause a silent boot.z20320l3316d2998x0e6jk80\b10BStartIO: PROCEDURE[ac0: UNSPECIFIED] RETURNS[fromAc0: CARDINAL];-- Do an SIO with ac0 passed in the Alto AC0.z20320l3316d2998x0e6jk80\b7BMuFileAlreadyOpen: ERROR;z20320l3316d2998x0e6jk80\b17BSuspiciousPackedMuFile: ERROR;z20320l3316d2998x0jk80\b22BReadPackedMuFile: PROCEDURE[name: STRING] RETURNS[theImage: MuImage];-- Read and swap in a Packed Mu file and check it to increase our confidence that it is a valid MuImage as prepared by the program PackMu.Run.z20320l3316d2998x0e6jk80\b16BReleaseMuImage: PROCEDURE[theImage: MuImage]; -- Release the FileHandle for the current packed MuImage.  IF muSeg#NIL, then swap it out first and get rid of the segment.  Then release the file.z20320l3316d2998x0e6jk80\b14BRamConfiguration: TYPE= {rom1ram0, rom1ram1, rom2ram1, rom1ram3};z20320l3316d2998x0e6jk80\b16BReadRamConfiguration: PROCEDURE RETURNS [RamConfiguration];z20320l3316d2998x0e6jk80\b20BEND.  --RamDefsz20320l3316d2998x0e6k80Edit Logz20320l3392d2998e28c\b8BRemark: Sturgis:  5-Jun-79 18:26:33: any comments earlier than October 1, 1978 placed in the Juniper History Log.l3776d2998e5(635)\b6BChanged by Mitchell: October 29, 1979  3:10 PMadded ReadBlv procedure.l3776d2998e5Changed by Mitchell: DTAcrTypel3776d2998e5Changed by Swinehart: bank argument to LoadRamAndBoot, add RamConfiguration type, ReadRamConfiguration procedurel3776d2998e5