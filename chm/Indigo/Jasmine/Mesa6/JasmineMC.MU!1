;modifications for MESA:;	remove #altoconsts23.mu;	external file must predefine MRT correctly!!!!;	remove halftoning stuff;	remove bcpl interface stuff;	change R register allocation;On each MRT, decrement the ScanWait counter;	when =0, do a scanner start pulse, and reset counter to ITTIME;	(if counter=0 on entry, just do a reset);;	If the scanner is running, also check for input words, and smash;	them into  ScanBuffer;REGISTERS USED BY NOVA EMULATOR$AC0	$R3;   ac's are backwards because the hardware supplies		;   the complement address when addressing from ir$AC1	$R2;$AC2	$R1;$AC3	$R0;$NWW	$R4;$SAD	$R5;$PC	$R6;$XREG	$R7;$MTEMP	$R25;$LastL	$R40; not a real S register, but rather L gated to the bus$ScanWait $R14;$ScanBuffer	$R13;	watch out!! this is used with the ethernet$ScanData	$R11;	watch out!! this is used with the ethernet$StoreCount	$R12;	watch out!! this is CLOCKTEMP;available constants: 177024,25,26,34,40,42$177024	$177024;$177026	$177026;;$Outport	$177016 ;$SafeLoc	$177023;$StepLoc	$177020$420	$420;	417 is StepState$ScanCBHead	$736;	and 737 is Startcommand$ScanTime	$526;$10000	$10000;$4000	$4000;$400	$400;$StatusDONE	$177777;$StatusDATALATE	$177776;;Clock (in refresh task) R11,R37;Ethernet R12,R13;Display controller: R20-R30;Disk Controller: R31-R34;Available: R5;--------------------------------------------------------------------; MRT: do start pulses off MRT task, for constant timing;--------------------------------------------------------------------;MEMORY REFRESH TASK AND MOUSE HANDLER!17,20,TX0,TX6,TX3,TX2,TX8,TX5,TX1,TX7,TX4,,,,,,,;!1,2,DOTIMER,NOTIMER;!1,2,NOTIMERINT,TIMERINT;!1,2,DOCUR,NOCUR;!1,2,SHOWC,WAITC;!1,2,SPCHK,NOSPCHK;!1,2,NOCLK,CLOCK;!1,1,MRTLAST;!1,2,CNOTLAST,CLAST;$CLOCKTEMP$R11;$REFZERO     $7774;  REFRESH ZERO$REFIIMSK    $7777; REFRESH MASK$R37			$R37;$CURX	$R20;$CURDATA	$R21;$YPOS	$R27;;		* * * A T T E N T I O N * * *;There are two versions of the Memory refresh code:;	AltoIIMRT4K.mu 		for refreshing 4K chips;	AltoIIMRT16K.mu		for refreshing 16K chips;first time initializationMRT:	MAR _ ScanTime;	L_0;	ScanBuffer_L;	StoreCount_L; 	L_MD;	MAR _ 420-1; initialize StepState	ScanWait_L;	MD _ StoreCount;;On each MRT, decrement the ScanWait counter;	when =0, do a scanner start pulse, and reset counter to ITTIME;	(if counter=0 on entry, just do a reset);;	If the scanner is running, also check for input words, and smash;	them into  ScanBuffer!1,2,ScannerOn,ScannerOff;!1,2,checkInput,startScan;!1,2,haveHead,noHead;!1,2,haveCurrent,noCurrent;!1,2,doMouse,doWord;MRTloop: L_ScanWait-1,BUS=0;	1MAR_ScanTime,:ScannerOn; !1,2,ScannerOn,ScannerOff	2ScannerOn: NOP,SH=0;	3ScanWait_L,:checkInput;	!1,2,checkInput,startScan;	4;unless StoreCount is 0, read bytes and decrement StoreCount;between MAR_StepLoc and L_MD you need:;	5 NOPs if running at -11 volts;	6 NOPs if running at -10 volts!1,2,doCount,noCount;!1,2,oddByte,evenByte;!1,2,read1,done1;!1,2,doMouse1,doWord1;!1,2,haveBuffer1,noBuffer1;!1,2,read2,done2;!1,2,doMouse2,doWord2;!1,2,read3,done3;!1,2,doMouse3,doWord3;!1,2,haveBuffer3,noBuffer3;!1,2,doMouse4,done4;!1,2,StoreCountZero,noCountMouse;checkInput: T _ StoreCount,BUS=0;	5	T _ StoreCount,:doCount;	!1,2,doCount,noCount;	6doCount: MAR_177024-1;		SafeLoc;	7	L _ ONE AND T;	BUSODD doesn't work for MRT	8	T _ 377,SH=0;	9	L _ MD,:oddByte;	!1,2,oddByte,evenByte;	10;on even: must reset MAR to enable flop to toggle for stepevenByte: L _ MD AND T,SH<0,TASK;	11	ScanData _ L LCY 8,:doMouse;	!1,2,doMouse,doWord;	12doWord:	MAR_T_20;	13	MAR_177000+T;	StepLoc;	must allow 6 cycles before reading from XBus	14	L _ StoreCount - 1;	15	StoreCount _ L,SH=0,TASK;	16	NOP,:read1;	!1,2,read1,done1;	17read1: MAR_177024-1;	in case TASK was taken	18		NOP;	19		T_377;	20		L_MD;	21oddByte: T _ MD.T,SH<0;	22	T _ ScanData OR T,:doMouse1;	!1,2,doMouse1,doWord1;	23doWord1:	MAR_ScanBuffer+1,BUS=0;	24	L_ALLONES XOR T,:haveBuffer1; !1,2,haveBuffer1,noBuffer1;	25haveBuffer1:	ScanData_L,TASK;	2x	MD _ ScanData;	2x	MAR_T_20;	2x	MAR_177000+T;	StepLoc;	must allow 5 cycles before reading from XBus	2x	L _ StoreCount - 1;	3x	StoreCount _ L,SH=0;	3x	L_ScanBuffer+1,:read2;	!1,2,read2,done2;	3xnoBuffer1:	MAR_T_20;	2x	MAR_177000+T;	StepLoc;	must allow 5 cycles before reading from XBus	2x	L _ StoreCount - 1;	3x	StoreCount _ L,SH=0;	3x	L_0,:read2;	!1,2,read2,done2;	3xread2: MAR_177024-1;	in case TASK was taken;	3x		ScanBuffer_L;	3x		T_377;	3x		L_MD;	3x	L _ MD AND T,SH<0;	3x	ScanData _ L LCY 8,:doMouse2;	!1,2,doMouse2,doWord2;	3xdoWord2:	MAR_T_20;	3x	MAR_177000+T;	StepLoc;	must allow 5 cycles before reading from XBus	40	L _ StoreCount - 1;	4x	StoreCount _ L,SH=0,TASK;	4x	NOP,:read3;	!1,2,read3,done3;	43read3: MAR_177024-1;	in case TASK was taken;	4x		NOP;	4x		T_377;	4x		L_MD;	4x	T _ MD.T,SH<0;	4x	T _ ScanData OR T,:doMouse3;	!1,2,doMouse3,doWord3;	4xdoWord3:	MAR_ScanBuffer+1,BUS=0;	5x	L_ALLONES XOR T,:haveBuffer3; !1,2,haveBuffer3,noBuffer3;	5xhaveBuffer3:	ScanData_L,TASK;	5x	MD _ ScanData;	5x	MAR_T_20;	5x	MAR_177000+T;	StepLoc;	must allow 5 cycles before reading from XBus	5x	L _ StoreCount - 1;	5x	StoreCount _ L;	5x	L_ScanBuffer+1,SH=0,TASK;	ScanBuffer_L,:doMouse4;	!1,2,doMouse4,done4;noBuffer3:	MAR_T_20;	5x	MAR_177000+T;	StepLoc;	must allow 5 cycles before reading from XBus	5x	L _ StoreCount - 1;	5x	StoreCount _ L,SH=0,TASK;	NOP,:doMouse4;	!1,2,doMouse4,done4;;make ScanBuffer non-zero (in case of no buffer)done1: L_ALLONES,:done;	18done2: L_ALLONES,:done;	33done3: L_ALLONES,:done;	44done4: L_ALLONES,:done;	59done: ScanBuffer_L,:noMouse;	60;come here when storecount is exhausted;if ScanBuffer = 0 then NOP (wait for next START time to examine CBHead);	otherwise, mark current head "DONE", dequeue, and do next command;	(adjacent reads allow windowing, and stepper wants to go before next START);need to do something if requested read was odd number of bytesnoCount: SINK_ScanBuffer,BUS=0;	7	MAR_ScanCBHead,:StoreCountZero;	!1,2,StoreCountZero,noCountMouse;	8StoreCountZero:	NOP;	9	NOP;	1x;	T_MD+1,BUS=0;	1x;!1,2,ScanCBHeadOK,ScanCBHead0;	driver may have zeroed ScanCBHead;	MAR_0+T+1,:ScanCBHeadOK;!1,2,ScanCBHeadOK,ScanCBHead0;Done stamp	1x;ScanCBHeadOK:	L_T;	1x;	MTEMP_L;	1x;	MD_StatusDONE;	15;	MAR_MTEMP-1;	Unlink	1x	L_MD+1,BUS=0;	1x!1,2,ScanCBHeadOK,ScanCBHead0;	driver may have zeroed ScanCBHead	ScanBuffer_L,:ScanCBHeadOK;ScanCBHead0: NOP,:noCurrent;ScanCBHeadOK:	MAR _ ScanBuffer + 1;		NOP;		TASK;		MD _ StatusDONE;		MAR _ ScanBuffer - 1;		NOP;		NOP;	1x	L_MD;	1x	MAR_ScanCBHead;	2x;	NOP;	21;	MTEMP_L,TASK;	2x	MTEMP_L,L_0;	5x	ScanBuffer_L,TASK;		MD_MTEMP,:noCurrent;	23startScan:L_MD;	5;quick like a bunny pulse start, then (whew!) you can TASKMAR_ScanCBHead+1;	StartCommand	6T _ 10;	get ready for faking 177016	7ScanWait_L; 	8L_MD;	9MAR_177026-T;	Outport;	10T_200;	11ScanData_L;	12MD_ScanData,L_ScanData OR T;<0><START><SkipCount>;	START=7	13T_10;	1xMAR_177026-T;	Outport;	1xMTEMP _ L,TASK;	<1><START><SkipCount>;	16-17MD_MTEMP;	1xT _ 10;	19MAR_ 177026-T;	Outport;	2xNOP;	2x	SINK_ScanBuffer,BUS=0;	22MD_ScanData,:haveCurrent;	!1,2,haveCurrent,noCurrent;	23;there is a current scan buffer: mark it DataLate, clear CB queuehaveCurrent: MAR _ ScanCBHead;	22	NOP;	23	NOP;	24	L_MD+1,BUS=0,TASK;	25!1,2,HeadOK,Head0;	driver may have zeroed ScanCBHead	ScanBuffer _ L,:
HeadOK;	!1,2,HeadOK,Head0;	2xHeadOK:	MAR _ ScanBuffer;	2x	NOP;	28	TASK;	29	MD _ StoreCount;	30	MAR _ ScanBuffer + 1;	31	NOP;	32	TASK;	3x	MD _ StatusDATALATE;	3xHead0:	L_0;	3x	MAR _ ScanCBHead;	3x	ScanBuffer _ L;	3x	StoreCount _ L;	3x	MD _ ScanBuffer,:doMouse;	39;check for available input buffernoCurrent: MAR_ScanCBHead;	24L_0;	25StoreCount_L;	2xL_MD,BUS=0;	2xScanBuffer_L,:haveHead;	!1,2,haveHead,noHead;	2x;ScanCB structure:;	link;	command (Read,Delay,Forward,Back);	status/count (negative = status, pos=count);	buffer!3,4,CommandREAD,CommandDELAY,CommandFORWARD,CommandBACK;haveHead: 	MAR_L_ScanBuffer+1;	29	ScanBuffer_L;	3x	T _ 10;	3x	SINK_MD,BUS;	3x	L _ 177026-T,:CommandREAD;	3x!1,2,realBuffer,dummyBuffer;CommandREAD: MAR _ L _ ScanBuffer+1;	34	ScanBuffer _ L;	35	NOP;	36	L_MD;	3x	MAR _ ScanBuffer + 1;	3x	StoreCount _ L;	doesn't work for odd scan counts	3x	NOP;	40	L _ MD-1,BUS=0,TASK;	4x	ScanBuffer _ L,:realBuffer;	42dummyBuffer: L_0;	43	ScanBuffer_L,:noMouse;	44;DELAY: wait until next start pulse (just throw command away)CommandDELAY: NOP,:dequeueCB;	35$521	$521;$523	$523;;	MOTORCTL=5;<00000000><ENABLE><MOTORCTL><xxxx>	;0101xxxx = disabled = 120 (521 available)CommandBACK:	MAR _ 420-1;	MTEMP_L;	set up to be Outport=177016	SINK _ MD,BUS;	MAR_MTEMP,:bstep0;	Outport;	34;sequence is: 1,0,2,3	bstep0:L_523-1,:stepDone;	#522	bstep1:L_521-1,:stepDone;	#520	bstep2:L_523,:stepDone;	#523	bstep3:L_521,:stepDone;	#521CommandFORWARD:	MAR _ 420-1;	MTEMP_L;	set up to be Outport=177016	SINK _ MD,BUS;	MAR_MTEMP,:fstep0;	Outport;	34;sequence is: 3,2,0,1	fstep0:L_521,:stepDone;		#521	fstep1:L_523,:stepDone;		#523	fstep2:L_521-1,:stepDone;	#520	fstep3:L_523-1,:stepDone;	#522stepDone: ScanData_L;	MD_ScanData;	<0><MOTORCTL><StepState>	T_200;	MAR_MTEMP;	L_ScanData OR T;	ScanData_L;	MD _ ScanData;	<1><MOTORCTL><StepState>	MAR_MTEMP;	L_ScanData XOR T;	ScanData_L;	MD _ ScanData;	<0><MOTORCTL><StepState>	MAR _ 420-1;	store updated value	TASK;	MD_ScanData,:dequeueCB;;take CB off queue, mark DONE, store ScanData into OutportdequeueCB: MAR _ ScanBuffer + 1;	43	NOP;	44	TASK;	4x	MD _ StatusDONE;	4x	MAR _ ScanBuffer - 1;	4x	NOP;	4x	NOP;	49	L _ MD;	--link	50	MAR _ ScanCBHead;	5x	MTEMP_L,L_0;	5x	ScanBuffer_L,TASK;	5x	MD_MTEMP,:noMouse;	59ScannerOff: NOP;	3;NOP;	4L_MD;	5ScanWait_L,:doMouse;	6realBuffer: MAR_ R37,:MRTA;	43noHead: MAR_ R37,:doMousex;	29doMouse1: MAR_ R37,:doMousex;	24doMouse2: MAR_ R37,:doMousex;	39doMouse3: MAR_ R37,:MRTA;	50doMouse4: MAR_ R37,:MRTA;doMouse5: MAR_ R37,:MRTA;	59noCountMouse: MAR_ R37,:doMousex;	9;special code for long MRT cycles: don't update mousenoMouse: MAR_R37,:MRTA;	63doMouse:MAR_ R37;		**FIRST REFRESH CYCLE**	40doMousex:	SINK_ MOUSE, BUS;	MOUSE DATA IS ANDED WITH 17BMRTA:	L_ T_ -2, :TX0;		DISPATCH ON MOUSE CHANGE	42,64TX0:	L_ R37 AND NOT T, T_ R37;INCREMENT CLOCK	65	T_ 3+T+1, SH=0;		IE. T_ T +4.  IS INTV TIMER ON?	66	L_REFIIMSK AND T,:DOTIMER;[DOTIMER,NOTIMER]ZERO HIGH 4 BITS	67NOTIMER: R37_ L; 		STORE UPDATED CLOCK	68(better have timer off)NOTIMERINT: T_ 2;		NO STATE AT THIS POINT IN PUBLIC REGS	69	MAR_ R37 XOR T,T_ R37;	**SECOND REFRESH CYCLE**	70	L_ REFZERO AND T;	ONLY THE CLOKCK BITS, PLEASE	71	SH=0, TASK;		TEST FOR CLOCK OVERFLOW	72	:NOCLK;			[NOCLK,CLOCK]	73NOCLK:	T _ 200;	81	MAR_ R37 XOR T;		**THIRD FEFRESH CYCLE**	82	L_ CURX, BLOCK;		CLEARS WAKEUP REQUEST FF	8x	T_ 2 OR T, SH=0;	NEED TO CHECK CURSOR?	8x	MAR_ R37 XOR T, :DOCUR;	**FOURTH REFRESH CYCLE**	85NOCUR:	CURDATA_ L, TASK;	86MRTLAST:CURDATA_ L, :MRTloop;	END OF MAIN LOOP	90DOTIMER:R37_ L;			STORE UPDATED CLOCKL_0;	if we ever get here, swat break at 0PC_L;	MAR_ EIALOC;		INTERVAL TIMER/EIA INTERFACE	L_ 2 AND T;	SH=0, L_ T_ REFZERO.T;	***V3 CHANGE (USED TO BE BIAS)	CURDATA_L, :SPCHK;	CURDATA_ CURRENT TIME WITHOUT CONTROL BITSSPCHK:	SINK_ MD, BUS=0, TASK;	CHECK FOR EIA LINE SPACINGSPIA:	:NOTIMERINT, CLOCKTEMP_ L;NOSPCHK:L_MD;			CHECK FOR TIME = NOW	MAR_TRAPDISP-1;		CONTAINS TIME AT WHICH INTERRUPT SHOULD HAPPEN	MTEMP_L;		IF INTERRUPT IS CAUSED,	L_ MD-T;		LINE STATE WILL BE STORED	SH=0, TASK, L_MTEMP, :SPIA;TIMERINT:MAR_ ITQUAN;		STORE THE THING IN CLOCKTEMP AT ITQUAN	L_ CURDATA;	R37_ L;	T_NWW;			AND CAUSE AN INTERRUPT ON THE CHANNELS 	MD_CLOCKTEMP;		SPECIFIED BY ITQUAN+1	L_MD OR T, TASK;	NWW_L,:NOTIMERINT;CLOCK:	MAR_ CLOCKLOC;	R37 OVERFLOWED. UPDATE CLOCK	74	NOP;	75-76	L_ MD+1;	7x	MAR_ CLOCKLOC;	7x	MTEMP_ L, TASK;	79	MD_ MTEMP, :NOCLK;	80DOCUR:	L_ T_ YPOS;	CHECK FOR VISIBLE CURSOR ON THIS SCAN	86	SH < 0, L_ 20-T-1; ***x13 change: the constant 20 was 17	87	SH<0, L_ 2+T, :SHOWC;	88WAITC:	YPOS_ L, L_ 0, TASK, :MRTLAST;	89SHOWC:	MAR_ CLOCKLOC+T+1, :CNOTLAST;	89CNOTLAST:	T_ CURX, :CURF;	90CLAST:	T_ 0;	90CURF:	YPOS_ L, L_ T;	91	CURX_ L;	92	L_ MD, TASK;	93	CURDATA_ L, :MRTloop;;AFTER THIS DISPATCH, T WILL CONTAIN XCHANGE, L WILL CONTAIN YCHANGE-1TX1:	L_ T_ ONE +T, :M00;		Y=0, X=1			43TX2:	L_ T_ ALLONES, :M00;		Y=0, X=-1			43TX3:	L_ T_ 0, :M00;			Y=1, X= 0			43TX4:	L_ T_ ONE AND T, :M00;		Y=1, X=1			43TX5:	L_ T_ ALLONES XOR T, :M00;	Y=1, X=-1			43TX6:	T_ 0, :M00;			Y= -1, X=0			43TX7:	T_ ONE, :M00;			Y= -1, X=1			43TX8:	T_ ALLONES, :M00;		Y= -1, X= -1			43;old code using CLOCKTEMP;M00:	MAR_ MOUSELOC;		START THE FETCH OF THE COORDINATES	44;	MTEMP_ L;			YCHANGE -1	45-46;	L_ MD+ T;			X+ XCHANGE	47;	T_ MD;				Y	48;	T_ MTEMP+ T+1;			Y+ (YCHANGE-1) + 1	49;	MTEMP_ L, L_ T;	50;	MAR_ MOUSELOC;		NOW RESTORE THE UPDATED COORDINATES	51;	CLOCKTEMP_ L;	52-53;	MD_ MTEMP, TASK;54;	MD_ CLOCKTEMP, :MRTA;55;new code without CLOCKTEMPM00:	MAR_ MOUSELOC;		START THE FETCH OF THE COORDINATES	44	MTEMP_ L;			YCHANGE -1	45-46	L_ MD+ T;			X+ XCHANGE	47	T_ MD;				Y	48MAR_MOUSELOC;	49	T_ MTEMP+ T+1;			Y+ (YCHANGE-1) + 1	50	MTEMP_ L, L_ T;	51MD_MTEMP;	52	MAR_ MOUSELOC+1;		NOW RESTORE THE UPDATED COORDINATES	53	MTEMP_ L,TASK;	54-55	MD_ MTEMP, :MRTA;56(635)\f1 731b318B28b97B751f0 173f1 69bi1BI14bi1BI481b8B882b4B81b4B112b4B2409b237B286b29B