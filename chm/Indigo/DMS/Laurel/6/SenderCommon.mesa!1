-- SenderCommon.mesa-- Edited by Levin, October 16, 1980  5:07 PM-- Edited by Schroeder, March 13, 1981  1:15 PM-- Edited by Brotz, November 13, 1980  9:08 PMDIRECTORY  Ascii,  DMSTimeDefs,  exD: FROM "ExceptionDefs",  gsD: FROM "GlobalStorageDefs",  intCommon: FROM "intCommon",  LaurelSendDefs,  MailParse,  ovD: FROM "OverviewDefs",  -- PupDefs, --  -- RetrieveDefs, --  String,  TimeDefs;SenderCommon: PROGRAM  IMPORTS DMSTimeDefs, exD, gsD, intC: intCommon,    LaurelSendDefs, -- PupDefs, RetrieveDefs, -- String, TimeDefs  EXPORTS LaurelSendDefs =BEGIN OPEN LaurelSendDefs;DeliverBody: PUBLIC PROCEDURE [netMail: BOOLEAN, fromField: BOOLEAN,  SendBlock: PROCEDURE[POINTER, CARDINAL]] =BEGINblockSize: CARDINAL = 512;bodyBlock: POINTER TO PACKED ARRAY [0..blockSize) OF CHARACTER;flushStart: CARDINAL _ 0;charsInBodyBlock: CARDINAL _ 0;lastBodyChar: CHARACTER;PrepareDateField: PROCEDURE =  BEGIN  OPEN DMSTimeDefs;  timeString: STRING = [40];  PutString["Date: "L];  MapPackedTimeToTimeZoneString[LOOPHOLE[TimeDefs.CurrentDayTime[]],                      timeString, IF netMail THEN arpaMsg ELSE laurelMsg];  PutString[timeString];  PutChar[Ascii.CR];  END;  -- of PrepareDateField --PrepareOriginatorField: PROCEDURE =  BEGIN  PutString[IF fromField THEN "Sender: "L ELSE "From: "L];  PutString[intC.user.name];  IF NOT netMail OR NOT String.EquivalentString[intC.user.registry, "PA"L]    THEN BEGIN      PutChar['.];      PutString[intC.user.registry];      END;  IF netMail    THEN{PutString[" at "L]; PutString[intC.arpaGatewayHostNames[0]]};--   IF RetrieveDefs.MailboxState[intC.retrieveHandle] IN [unknown .. cantAuth]--     THEN BEGIN OPEN PupDefs;--       msg: STRING _ [22+2*(3+1)+1];--       pa: PupAddress;--       GetPupAddress[@pa, "ME"L];--       pa.socket _ [0, 0];--       String.AppendString[msg, " (not authenticated: "L];--       AppendPupAddress[msg, pa];--       String.AppendChar[msg, ')];--       PutString[msg];--       END;  PutChar[Ascii.CR];  END;  -- of PrepareOriginatorField --SendBodyBlock: PROCEDURE =  BEGIN  SendBlock[bodyBlock, charsInBodyBlock];  AbortPoint[];  charsInBodyBlock _ 0;  END;  -- of SendBodyBlock --PutChar: PROCEDURE[ch: CHARACTER] =  BEGIN  IF charsInBodyBlock = blockSize THEN SendBodyBlock[];  bodyBlock[charsInBodyBlock] _ lastBodyChar _ ch;  charsInBodyBlock _ charsInBodyBlock+1;  END;  -- of SendBodyBlock --PutString: PROCEDURE[s: STRING] =  BEGIN  IF charsInBodyBlock+s.length > blockSize THEN SendBodyBlock[];  FOR i: CARDINAL IN [0..s.length) DO    bodyBlock[charsInBodyBlock+i] _ s[i]    ENDLOOP;  charsInBodyBlock _ charsInBodyBlock+s.length;  lastBodyChar _ s[s.length-1];  END;  -- of PutString --OutputMessage: PROCEDURE =  BEGIN  c: CHARACTER;  DO    c _ ReadChar[];    IF c=MailParse.endOfInput THEN EXIT;    PutChar[c];    ENDLOOP;  IF lastBodyChar ~= Ascii.CR THEN PutChar[Ascii.CR];  IF charsInBodyBlock > 0 THEN SendBodyBlock[];  END;  -- of OutputMessage ---- main body of DeliverBodybodyBlock _ gsD.GetMemoryPages[1];BEGIN ENABLE UNWIND => gsD.ReturnMemoryPages[1, bodyBlock];  exD.AppendStringToExceptionLine["."L, 1];  InitReadChar[];  PrepareDateField[];  PrepareOriginatorField[];  OutputMessage[];  exD.DisplayExceptionStringOnLine[NIL,2]; --cancel DEL to abort message  AbortPoint[];  END;gsD.ReturnMemoryPages[1, bodyBlock];END;  -- DeliverBody --ReportRejectedRecipients: PUBLIC PROCEDURE [rejected: CARDINAL,  nameList: STRING, nameListFull: BOOLEAN] =BEGINexD.ClearExceptionsRegion[];EDecimal[rejected];EString[" invalid name"L];IF rejected > 1 THEN EString["s"L];EString[" ("L];EString[nameList ! exD.ExceptionLineOverflow => CONTINUE];IF NOT nameListFull THEN EString[")"L ! exD.ExceptionLineOverflow => CONTINUE];AskUser[exD.nil, NIL];ReportProgress[exD.nil, "Continuing delivery .."L, TRUE];END; --of ReportRejectedRecipientsReportDelivery: PUBLIC PROCEDURE [chars, goodOther, totalOther: CARDINAL,  goodList: CARDINAL _ 0, totalList: CARDINAL _ 0] =BEGINsStr: STRING = "s"L;ofStr: STRING = " of "L;exD.ClearExceptionsRegion[];EDecimal[chars];EString[" character message sent to "L];IF totalList # 0 THEN BEGIN  EDecimal[goodList];  IF goodList < totalList THEN BEGIN    EString[ofStr];    EDecimal[totalList];    END;  EString[" public list"L];  IF NOT (goodList = 1 AND totalList = 1) THEN EString[sStr];  IF totalOther # 0 THEN EString[" + "L];  END;IF totalOther # 0 THEN BEGIN  EDecimal[goodOther];  IF goodOther < totalOther THEN BEGIN    EString[ofStr];    EDecimal[totalOther];    END;  IF totalList # 0 THEN EString[" other"L];  EString[" recipient"L];  IF NOT (goodOther = 1 AND totalOther = 1) THEN EString[sStr];  END;EString["."L];END; --of ReportDeliveryEDecimal: PROCEDURE[n: CARDINAL] = {exD.AppendDecimalToExceptionLine[n, 1]};EString: PROCEDURE[s: STRING] = {exD.AppendStringToExceptionLine[s, 1]};END.  -- of SenderCommon --(635)\f1