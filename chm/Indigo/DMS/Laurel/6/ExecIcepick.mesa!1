-- File: ExecIcepick.mesa-- edited by Levin,  November 25, 1980  4:46 PM.-- edited by Brotz, November 19, 1980  9:45 AM.DIRECTORY  displayCommon: FROM "DisplayCommon",  dsD: FROM "DisplayDefs",  exD: FROM "ExceptionDefs",  inD: FROM "InteractorDefs",  intCommon: FROM "intCommon",  Inline,  LaurelExecImpDefs,  StreamDefs;ExecIcepick: PROGRAM  IMPORTS disC: displayCommon, dsD, exD, intC: intCommon, Inline, StreamDefs  EXPORTS LaurelExecImpDefs  SHARES dsD =BEGINOPEN LaurelExecImpDefs;Movie: PUBLIC PROCEDURE [villain: STRING] =BEGINpCursor: POINTER TO ARRAY [0 .. 15] OF CARDINAL = LOOPHOLE[431B];icePick: ARRAY [0 .. 15] OF CARDINAL _ [000016B, 000037B, 000037B, 000077B, 000376B, 000770B, 000760B, 000360B,  000540B, 001000B, 002000B, 004000B, 010000B, 020000B, 040000B, 100000B];startX, cornerX, centerX: dsD.ScreenXCoord;startY, cornerY, centerY: dsD.ScreenYCoord;clock: CARDINAL;MoveCursor: PROCEDURE [sx, sy, fx, fy, delay: CARDINAL] =BEGINdx: INTEGER _ SELECT TRUE FROM sx = fx => 0, sx < fx => 8, ENDCASE => -8;dy: INTEGER _ SELECT TRUE FROM sy = fy => 0, sy < fy => 8, ENDCASE => -8;UNTIL dsD.cursorY^ = fy DO  dsD.cursorX^ _ dsD.cursorX^ + dx;  dsD.cursorY^ _ dsD.cursorY^ + dy;  clock _ inD.realTimeClock^;  UNTIL inD.realTimeClock^ - clock >= delay DO ENDLOOP;  ENDLOOP;END;  -- of MoveCursor --BlackHole: PROCEDURE [bitmap: dsD.BitMapPtr, width, height: CARDINAL] =  BEGIN  leftX, topY: CARDINAL _ 0;  BBTableSpace: TYPE = ARRAY[0 .. SIZE[dsD.Bbt]] OF WORD;  moveTable, clearTable: BBTableSpace;  moveBBT: dsD.BbtPtr _ AlignedBBTable[@moveTable];  clearBBT: dsD.BbtPtr _ AlignedBBTable[@clearTable];  AlignedBBTable: PROCEDURE [p: POINTER TO BBTableSpace] RETURNS [dsD.BbtPtr] =  BEGIN RETURN[LOOPHOLE[p + Inline.BITAND[p, 1]]]; END;  moveBBT^ _ dsD.Bbt    [func: dsD.replace + dsD.source,    dbca: bitmap, dbmr: (width+15)/16, dlx: , dty: ,    dw: , dh: , sbca: bitmap, sbmr: (width+15)/16,    slx: , sty: ];  clearBBT^ _ dsD.Bbt    [func: dsD.replace + dsD.gray,    dbca: bitmap, dbmr: (width+15)/16, dlx: , dty: ,    dw: , dh: , sbca: , sbmr: ,    slx: , sty: , gray: [0, 0, 0, 0]];  IF width MOD 2 = 1 THEN    BEGIN    clearBBT.dw _ 1; clearBBT.dh _ height;    clearBBT.dlx _ leftX + (width _ width - 1); clearBBT.dty _ topY;    dsD.BitBlt[clearBBT];    END;  IF height MOD 2 = 1 THEN    BEGIN    clearBBT.dw _ width; clearBBT.dh _ 1;    clearBBT.dlx _ leftX; clearBBT.dty _ topY + (height _ height - 1);    dsD.BitBlt[clearBBT];    END;  DO    dx, dy: CARDINAL;    SELECT TRUE FROM      width = 0 OR height = 0 => EXIT;      width > height => {dx _ 4; dy _ 2};      width < height => {dx _ 2; dy _ 4};      ENDCASE => {dx _ 2; dy _ 2};    moveBBT.dw _ width/2 - dx; moveBBT.dh _ height/2 - dy;    moveBBT.dlx _ leftX + dx; moveBBT.dty _ topY + dy;    moveBBT.slx _ leftX; moveBBT.sty _ topY;    dsD.BitBlt[moveBBT];    moveBBT.dlx _ moveBBT.dlx + moveBBT.dw;    moveBBT.slx _ moveBBT.dlx + dx;    dsD.BitBlt[moveBBT];    moveBBT.dty _ moveBBT.dty + moveBBT.dh;    moveBBT.sty _ moveBBT.dty + dy;    dsD.BitBlt[moveBBT];    moveBBT.dlx _ leftX + dx;    moveBBT.slx _ leftX;    dsD.BitBlt[moveBBT];    clearBBT.dw _ width; clearBBT.dh _ dy;    clearBBT.dlx _ leftX; clearBBT.dty _ topY;    dsD.BitBlt[clearBBT];    clearBBT.dty _ topY + height - dy;    dsD.BitBlt[clearBBT];    clearBBT.dw _ dx; clearBBT.dh _ height;    clearBBT.dty _ topY;    dsD.BitBlt[clearBBT];    clearBBT.dlx _ leftX + width - dx;    dsD.BitBlt[clearBBT];    leftX _ leftX + dx; width _ width - 2*dx;    topY _ topY + dy; height _ height - 2*dy;    ENDLOOP;  END;  -- of BlackHole ---- First, invert screen except for exceptions region.disC.patchDCBPtr^ _ dsD.DCB  [next: intC.exceptionsRegion.dcb,  resolution: high,  background: black,  indenting: intC.mailCommandRegion.dcb.indenting,  width: dsD.bmWidth,  bitmap: disC.bitMapPtr,  height: (intC.exceptionsRegion.topY - intC.mailCommandRegion.topY) / 2];disC.firstDCB.background _ black;disC.firstDCB.next _ disC.patchDCBPtr;dsD.ClearRectangle[inD.leftMargin, inD.rightMargin,              intC.exceptionsRegion.topY, intC.exceptionsRegion.topY + dsD.lineHeight];-- Set ice pick.centerX _ inD.leftMargin + 8 * dsD.bmWidth;centerY _ (intC.exceptionsRegion.topY + intC.mailCommandRegion.topY) / 2 - 15;startX _ cornerX _ centerX + 48;cornerY _ centerY - 48;startY _ cornerY + 320;StreamDefs.CursorTrack[FALSE];dsD.ChangeCursor[invisibleCursor];dsD.cursorX^ _ startX;dsD.cursorY^ _ startY;Inline.COPY[from:@icePick, to: pCursor, nwords: 16];exD.DisplayExceptionString["Arrghh!  THE ICE PICK!!"L];-- Move to center along trajectory.MoveCursor[startX, startY, cornerX, cornerY, 2];MoveCursor[cornerX, cornerY, centerX, centerY, 1];-- Display bad bcd message.exD.DisplayExceptionString[villain];-- invert rest of screen.intC.exceptionsRegion.dcb.background _ black;-- Suck in screen.BlackHole[bitmap: disC.bitMapPtr, width: dsD.bmWidth * 16,        height: disC.patchDCBPtr.height * 2];-- Blacken exceptions Region.exD.ClearExceptionsRegion[];-- Pregnant pause.clock _ inD.realTimeClock^;UNTIL inD.realTimeClock^ - clock >= 250 DO ENDLOOP;-- Last look at exceptions regionintC.exceptionsRegion.dcb.background _ white;-- Die.exD.SysBug[];END;  -- of Movie --END.  -- of ExecIcepick --z20461x0(635)\f1