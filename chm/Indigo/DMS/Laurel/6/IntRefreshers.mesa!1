-- file:  IntRefreshers.mesa-- edited by Brotz, January 15, 1981  5:12 PM-- edited by Schroeder, August 1, 1978  11:43 AM-- edited by Levin, February 7, 1980  5:44 PMDIRECTORY	displayCommon: FROM "DisplayCommon",	dsD: FROM "DisplayDefs",	inD: FROM "InteractorDefs",	InlineDefs: FROM "InlineDefs",	intCommon: FROM "IntCommon",	tsD: FROM "TOCSelectionDefs",	ovD: FROM "OverviewDefs",	vmD: FROM "VirtualMgrDefs";IntRefreshers: PROGRAM	IMPORTS disC: displayCommon, dsD, inD, InlineDefs, intC: intCommon, tsD	EXPORTS inD	SHARES inD = PUBLICBEGINOPEN inD;-- Purpose: handles user interactions including the display, keyboard and mouse.  This--   division gathers together commands and their arguments and is responsible for the display--   of all error messages.TextHouseRefresher: PROCEDURE [hp: HousePtr] =-- Repaints one simple text house on the display screen, according to the parameters--   contained in hp^.BEGINIF NOT disC.bitMapReady THEN RETURN;dsD.ClearRectangle[hp.leftX,  hp.rightX,  hp.topY,  hp.bottomY];IF hp.usePicture THEN dsD.PaintPicture[hp.leftX, hp.topY, hp.picture, dsD.paint]ELSE BEGIN  SELECT hp.fixedEdge FROM    left => hp.rightX _ hp.leftX + dsD.GetStringWidth[hp.text, hp.typeface];    right => hp.leftX _ hp.rightX - dsD.GetStringWidth[hp.text, hp.typeface];    ENDCASE;  [] _ dsD.PutStringInBitMap[hp.leftX, hp.topY, hp.text, hp.typeface];  END;END;  -- of TextHouseRefresher --BracketsHouseRefresher: PROCEDURE [hp: HousePtr] =-- Repaints one brackets command house on the display screen.BEGINOPEN dsD;curX, limX, x: ScreenXCoord;i: CARDINAL;ClearRectangle[hp.leftX,  hp.rightX,  hp.topY,  hp.bottomY];curX _ PutCharInBitMap['{, hp.leftX, hp.topY, boldFace];limX _ (IF hp.nextHouse = NIL OR hp.nextHouse.lineNumber # hp.lineNumber			THEN inD.rightMargin ELSE hp.nextHouse.leftX) -			GetStringWidth[" } "L, boldFace];		-- space before bracket is for caretIF GetStringWidth[hp.text, plainFace]+curX <= limX THEN	curX _ PutStringInBitMap[curX, hp.topY, hp.text, hp.typeface]ELSE	BEGIN	FOR i IN [0..5] DO		curX _ PutCharInBitMap[hp.text[i], curX, hp.topY, plainFace];		ENDLOOP;	curX _ x _ PutStringInBitMap[curX, hp.topY, "..."L, plainFace];	FOR i _ hp.text.length-1, i-1 DO		IF (x _ GetCharRightX[hp.text[i], x]) > limX THEN EXIT;		ENDLOOP;	FOR i IN [i + 1 .. hp.text.length - 1] DO		curX _ PutCharInBitMap[hp.text[i], curX, hp.topY, plainFace];		ENDLOOP;	END;hp.rightX _ PutCharInBitMap['}, curX, hp.topY, boldFace];END;  -- of BracketsHouseRefresher --FreePagesHouseRefresher: PROCEDURE [count: CARDINAL] =-- Repaints the free pages house with count on the display screen.BEGINtext: STRING _ intC.freePagesHouse.text;remainder, i, j: CARDINAL;FOR i DECREASING IN [0 .. 5) DO	[count, remainder] _ InlineDefs.DIVMOD[count, 10];	text[i] _ '0 + remainder;	IF count = 0 THEN		BEGIN		FOR j IN [0 .. i) DO text[j] _ ' ; ENDLOOP;		EXIT;		END;	ENDLOOP;TextHouseRefresher[intC.freePagesHouse];END;  -- of FreePagesHouseRefresher --NullHouseRefresher: PROCEDURE [hp: HousePtr] =-- Place-holder.BEGINEND;  -- of NullHouseRefresher --TOCTextPainter: PROCEDURE [tnp: TOCTextNbrPtr] =-- Paints the TOC text neighborhood starting with the first selected entry.BEGINendLineNumber: CARDINAL;line: LinePtr;index: vmD.TOCIndex;IF ~intC.haveMailFile THEN RETURN;intC.TOCRegion.dcb.width _ 0;index _ tsD.FirstSelectedEntry[];IF index = 0 THEN index _ 1;DisplayTOCTail[tnp, tnp.lines, index, 1];IF tnp.nLines > 0 AND tnp.firstLineOffScreen.state = empty THEN	BEGIN  -- scroll End of messages down to bottom line on screen.	endLineNumber _ 1;	FOR line _ tnp.lines, line.nextLine UNTIL line.state = end DO		endLineNumber _ endLineNumber + 1;		ENDLOOP;	ScrollDownTOC[tnp.lines.y + (tnp.nLines - endLineNumber) * dsD.lineHeight, tnp];	END;intC.TOCRegion.dcb.width _ dsD.bmWidth;UpdateTOCThumbLine[];END;  -- of TOCTextPainter --END.  -- of IntRefreshers --z20461(529)\f1