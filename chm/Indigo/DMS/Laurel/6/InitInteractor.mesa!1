-- file:  InitInteractor-- edited by Brotz, April 9, 1981  2:08 PM-- edited by Levin, April 14, 1981  3:41 PM-- edited by Schroeder, Wednesday Nov. 5, 1980 2:59 pm PSTDIRECTORY	AltoDefs,	displayCommon: FROM "DisplayCommon",	DMSTimeDefs,	drD: FROM "LaurelDriverDefs",	dsD: FROM "DisplayDefs",	exD: FROM "ExceptionDefs",	inD: FROM "InteractorDefs",	Inline,	intCommon: FROM "IntCommon",	lsD: FROM "LaurelStateDefs",	ovD: FROM "OverviewDefs",	String;InitInteractor: PROGRAM 	IMPORTS disC: displayCommon, drD, dsD, exD, inD, Inline, intC: intCommon,		lsD, ovD, String	EXPORTS inD =BEGINOPEN inD, lsD;-- Global constants --commandIndent: CARDINAL = 0;interCommandSpacing: CARDINAL = 15;preBracketSpacing: CARDINAL = 7;maxCommandString: CARDINAL = 30;endOfMessageString: STRING;BuildScreenStructures: PUBLIC PROCEDURE =-- Builds all data structures that support the display.  All constant fields will be filled in;--   actual x,y screen coordinates will not.-- Side effects: intCommon region and house pointers are filled in.  DisplayCommon firstDCB--   is filled in to point to a spacer DCB, which in turn is linked to all other DCB's.BEGIN-- Call each region builder in turn, linking the regions and their DCB's in a chain.rp: RegionPtr;dcbPtr: dsD.DCBptr;s: STRING _ "End of Message."L;endOfMessageString _ lsD.AllocateStateString[s.length];String.AppendString[endOfMessageString, s];intC.linePoolPtr _ AllocateLinePool[];disC.firstDCB _ dcbPtr _ NewDCB[];rp _ intC.regions _ InitMailCommandRegion[];dcbPtr _ dcbPtr.next _ rp.dcb;rp _ rp.nextRegion _ InitTOCRegion[];dcbPtr _ dcbPtr.next _ rp.dcb;rp _ rp.nextRegion _ InitTOCCommandRegion[];dcbPtr _ dcbPtr.next _ rp.dcb;rp _ rp.nextRegion _ InitDMRegion[];dcbPtr _ dcbPtr.next _ rp.dcb;rp _ rp.nextRegion _ InitCMCommandRegion[];dcbPtr _ dcbPtr.next _ rp.dcb;rp _ rp.nextRegion _ InitCMRegion[];dcbPtr _ dcbPtr.next _ rp.dcb;rp _ rp.nextRegion _ InitExceptionsRegion[];dcbPtr _ dcbPtr.next _ rp.dcb;disC.patchDCBPtr _ NewDCB[];BuildSwappableMenus[];END;  -- of BuildScreenStructures --InitMailCommandRegion: PROCEDURE RETURNS [rp: RegionPtr] =-- Allocates and partially fills in the mailCommandRegion.BEGINnp: NbrPtr _ intC.mailCommandNbr _ LOOPHOLE[InitMailCommandNbr[]];np.nextNbr _ InitTOCThumbLineNbr[];intC.mailCommandRegion _ rp _ AllocateStateNode[SIZE[Region]];rp^ _ Region	[nextRegion: NIL,	dcb: NewDCB[],	regionType: mailCommandRegion,	topY: 0,	bottomY: 0,	cursorShape: bullsEye,	nbrs: np];END;  -- of InitMailCommandRegion --InitTOCRegion: PROCEDURE RETURNS [rp: RegionPtr] =-- Allocates and partially fills in the TOCRegion.BEGINnp: NbrPtr _ InitTOCTextNbr[];intC.TOCRegion _ rp _ AllocateStateNode[SIZE[Region]];rp^ _ Region	[nextRegion: NIL,	dcb: NewDCB[],	regionType: tocRegion,	topY: 0,	bottomY: 0,	cursorShape: bullsEye,	nbrs: np];END;  -- of InitTOCRegion --InitTOCCommandRegion: PROCEDURE RETURNS [rp: RegionPtr] =-- Allocates and partially fills in the TOCCommandRegion.BEGINnp: NbrPtr _ InitBoundaryLineNbr[rightMargin - 16, bullsEye];np.nextNbr _ InitTOCDMBoundaryPadNbr[];np.nextNbr.nextNbr _ intC.tocCommandNbr _ LOOPHOLE[InitTOCCommandNbr[]];np.nextNbr.nextNbr.nextNbr _ InitDMThumbLineNbr[];intC.TOCCommandRegion _ rp _ AllocateStateNode[SIZE[Region]];rp^ _ Region	[nextRegion: NIL,	dcb: NewDCB[],	regionType: tocCommandRegion,	topY: 0,	bottomY: 0,	cursorShape: bullsEye,	nbrs: np];END;  -- of InitTOCCommandRegion --InitDMRegion: PROCEDURE RETURNS [rp: RegionPtr] =-- Allocates and partially fills in the DMRegion.BEGINnp: NbrPtr _ InitDMTextNbr[];intC.DMRegion _ rp _ AllocateStateNode[SIZE[Region]];rp^ _ Region	[nextRegion: NIL,	dcb: NewDCB[],	regionType: dmRegion,	topY: 0,	bottomY: 0,	cursorShape: charArrow,	nbrs: np];END;  -- of InitDMRegion --InitCMCommandRegion: PROCEDURE RETURNS [rp: RegionPtr] =-- Allocates and partially fills in the CMCommandRegion.BEGINnp: NbrPtr _ InitBoundaryLineNbr[rightMargin - 16, bullsEye];np.nextNbr _ InitDMCMBoundaryPadNbr[];np.nextNbr.nextNbr _ intC.cmCommandNbr _ LOOPHOLE[InitCMCommandNbr[]];np.nextNbr.nextNbr.nextNbr _ InitCMThumbLineNbr[];intC.CMCommandRegion _ rp _ AllocateStateNode[SIZE[Region]];rp^ _ Region	[nextRegion: NIL,	dcb: NewDCB[],	regionType: cmCommandRegion,	topY: 0,	bottomY: 0,	cursorShape: bullsEye,	nbrs: np];END;  -- of InitCMCommandRegion --InitCMRegion: PROCEDURE RETURNS [rp: RegionPtr] =-- Allocates and partially fills in the CMRegion.BEGINnp: NbrPtr _ InitCMTextNbr[];intC.CMRegion _ rp _ AllocateStateNode[SIZE[Region]];rp^ _ Region	[nextRegion: NIL,	dcb: NewDCB[],	regionType: cmRegion,	topY: 0,	bottomY: 0,	cursorShape: charArrow,	nbrs: np];END;  -- of InitCMRegion --InitExceptionsRegion: PROCEDURE RETURNS [rp: RegionPtr] =-- Allocates and partially fills in the ExceptionsRegion.BEGINnp: NbrPtr _ InitBoundaryLineNbr[rightMargin, charArrow];np.nextNbr _ InitExceptionsNbr[];intC.exceptionsRegion _ rp _ AllocateStateNode[SIZE[Region]];rp^ _ Region	[nextRegion: NIL,	dcb: NewDCB[],	regionType: exceptionsRegion,	topY: 0,	bottomY: 0,	cursorShape: charArrow,	nbrs: np];END;  -- of InitExceptionsRegion --InitBoundaryLineNbr: PROCEDURE [right: dsD.ScreenXCoord, cursorShape: dsD.CursorShape]	RETURNS [np: NbrPtr] =-- Allocates and partially fills in a BoundaryLineNbr.BEGINnp _ AllocateStateNode[SIZE[Nbr]];np^ _ Nbr	[nextNbr: NIL,	nLines: 0,	topY: 0,	bottomY: 0,	leftX: leftMargin,	rightX: right,	cursorShape: cursorShape,	nbrVariant: boundaryLine		[nbrTracker: BoundaryLineNbrTracker]];END;  -- of InitBoundaryLineNbr --InitTOCDMBoundaryPadNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in a BoundaryPadNbr.BEGINnp _ intC.tocdmBoundaryPadNbr _ AllocateStateNode[SIZE[Nbr]];np^ _ Nbr	[nextNbr: NIL,	nLines: 0,	topY: 0,	bottomY: 0,	leftX: rightMargin - 16,	rightX: rightMargin,	cursorShape: scroll,	nbrVariant: boundaryPad		[command: MoveTOCDMBoundary,		nbrTracker: BoundaryPadNbrTracker]];END;  -- of InitTOCDMBoundaryPadNbr --InitDMCMBoundaryPadNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in a BoundaryPadNbr.BEGINnp _ intC.dmcmBoundaryPadNbr _ AllocateStateNode[SIZE[Nbr]];np^ _ Nbr	[nextNbr: NIL,	nLines: 0,	topY: 0,	bottomY: 0,	leftX: rightMargin - 16,	rightX: rightMargin,	cursorShape: scroll,	nbrVariant: boundaryPad		[command: MoveDMCMBoundary,		nbrTracker: BoundaryPadNbrTracker]];END;  -- of InitDMCMBoundaryPadNbr --InitTOCThumbLineNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in a BoundaryLineNbr.BEGINnp _ intC.tocThumbLineNbr _ AllocateStateNode[SIZE[Nbr]];np^ _ Nbr	[nextNbr: NIL,	nLines: 0,	topY: 0,	bottomY: 0,	leftX: leftMargin,	rightX: rightMargin - 2,	cursorShape: bullsEye,	nbrVariant: thumbLine		[exists: FALSE,		length: 0,		start: 0,		end: 0,		selection: 0,		startX: leftMargin+4,		endX: leftMargin+4,		selectionX: leftMargin+4,		command: ThumbTOC,		nbrTracker: ThumbLineNbrTracker]];END;  -- of InitTOCThumbPadNbr --InitDMThumbLineNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in a BoundaryLineNbr.BEGINnp _ intC.dmThumbLineNbr _ AllocateStateNode[SIZE[Nbr]];np^ _ Nbr	[nextNbr: NIL,	nLines: 0,	topY: 0,	bottomY: 0,	leftX: leftMargin,	rightX: rightMargin - 2,	cursorShape: bullsEye,	nbrVariant: thumbLine		[exists: FALSE,		length: 0,		start: 0,		end: 0,		selection: 0,		startX: leftMargin,		endX: leftMargin,		selectionX: leftMargin,		command: ThumbDM,		nbrTracker: ThumbLineNbrTracker]];END;  -- of InitDMThumbPadNbr --InitCMThumbLineNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in a BoundaryLineNbr.BEGINnp _ intC.cmThumbLineNbr _ AllocateStateNode[SIZE[Nbr]];np^ _ Nbr	[nextNbr: NIL,	nLines: 0,	topY: 0,	bottomY: 0,	leftX: leftMargin,	rightX: rightMargin - 2,	cursorShape: bullsEye,	nbrVariant: thumbLine		[exists: FALSE,		length: 0,		start: 0,		end: 0,		selection: 0,		startX: leftMargin,		endX: leftMargin,		selectionX: leftMargin,		command: ThumbCM,		nbrTracker: ThumbLineNbrTracker]];END;  -- of InitCMThumbPadNbr --InitMailCommandNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in the MailCommandNbr.BEGINh, hp: HousePtr;houseLeftX, houseRightX: dsD.ScreenXCoord;commandString, versionString, freeDiskPages: STRING;testingModeString: STRING _ " GV Test Mode"L;versionString _ ovD.GetVersionString[];commandString _ AllocateStateString  [versionString.length  + (IF intC.gvTestingMode THEN testingModeString.length ELSE 0)];String.AppendString[commandString, versionString];IF intC.gvTestingMode THEN String.AppendString[commandString, testingModeString];houseLeftX _ leftMargin;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, plainFace];hp _ h _ intC.versionHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: commandString,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: TextHouseRefresher];-- timeHousehouseRightX _ rightMargin;houseLeftX _ houseRightX;h _ h.nextHouse _ intC.timeHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[DMSTimeDefs.timeStringLength],	fixedEdge: right,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: TextHouseRefresher];commandString _ AllocateStateString[40];  -- length of "You have new mail."commandString.length _ 0;houseLeftX _ leftMargin;houseRightX _ houseLeftX;h _ h.nextHouse _ intC.newMessagesHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: commandString,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: TextHouseRefresher];-- free pages housefreeDiskPages _ " free disk pages"L;commandString _ AllocateStateString[5];  -- length of "99999"String.AppendString[commandString, "     "];houseRightX _ rightMargin - dsD.GetStringWidth[freeDiskPages, plainFace];houseLeftX _ houseRightX;h _ h.nextHouse _ intC.freePagesHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: commandString,	fixedEdge: right,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: TextHouseRefresher];-- free pages constant text housecommandString _ AllocateStateString[freeDiskPages.length];String.AppendString[commandString, freeDiskPages];houseRightX _ rightMargin;houseLeftX _ houseRightX;h _ h.nextHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: commandString,	fixedEdge: right,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: TextHouseRefresher];commandString _ "User"L;houseLeftX _ leftMargin + commandIndent;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];h _ h.nextHouse _ intC.userCommandHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 2,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[commandString.length],	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: LoginCommand,	houseRefresher: TextHouseRefresher];String.AppendString[h.text, commandString];houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];intC.userBracketsHouse _ h _ h.nextHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 2,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[maxBracketStringLength],	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];commandString _ "New mail"L;houseLeftX _ leftMargin + 165;houseRightX _ houseLeftX  + dsD.GetStringWidth[commandString, boldFace];h _ h.nextHouse _ intC.newMailCommandHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 2,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[commandString.length],	fixedEdge: left,	typeface: boldFace,	needsConfirmation: FALSE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: GetNewMailCommand,	houseRefresher: TextHouseRefresher];String.AppendString[h.text, commandString];commandString _ "Mail file"L;houseLeftX _ houseRightX + interCommandSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];h _ h.nextHouse _ intC.mailFileCommandHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 2,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[commandString.length],	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: GetMailFileCommand,	houseRefresher: TextHouseRefresher];String.AppendString[h.text, commandString];houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];intC.mailFileBracketsHouse _ h _ h.nextHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 2,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[maxBracketStringLength],	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];commandString _ "Quit"L;houseRightX _ rightMargin;houseLeftX _ houseRightX - dsD.GetStringWidth[commandString, boldFace];h _ h.nextHouse _ intC.quitCommandHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 2,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[commandString.length],	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: QuitCommand,	houseRefresher: TextHouseRefresher];String.AppendString[h.text, commandString];np _ AllocateStateNode[SIZE[Nbr]];np^ _ Nbr	[nextNbr: NIL,	nLines: 0,	topY: 0,	bottomY: 0,	leftX: leftMargin,	rightX: rightMargin,	cursorShape: bullsEye,	nbrVariant: command		[houses: hp,		nbrTracker: CommandTracker]];END;  -- of InitMailCommandNbr --InitTOCTextNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in the TOCTextNbr.BEGINline: LinePtr _ intC.linePoolPtr;intC.linePoolPtr _ line.nextLine;np _ intC.tocTextNbr _ AllocateStateNode[SIZE[Nbr]];np^ _ Nbr	[nextNbr: NIL,	nLines: 0,	topY: 0,	bottomY: 0,	leftX: 0,	rightX: rightMargin,	cursorShape: lineArrow,	nbrVariant: tocText		[lines: line,		firstLineOffScreen: line,		nbrTracker: TOCTracker]];line.nextLine _ NIL;line.y _ 0;line.state _ empty;line.linePair _ LinePair[0, 0];END;  -- of InitTOCTextNbr --InitTOCCommandNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in the DMCommandNbr.BEGINh, hp: HousePtr;houseLeftX, houseRightX: ScreenXCoord;commandString: STRING _ [maxCommandString];commandString _ "Display"L;houseLeftX _  leftMargin + commandIndent;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];hp _ h _ intC.displayCommandHouse _ AllocateStateNode[SIZE[House]];hp^ _ House	[nextHouse: NIL,	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[commandString.length],	fixedEdge: left,	typeface: boldFace,	needsConfirmation: FALSE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: DisplayMessageCommand,	houseRefresher: TextHouseRefresher];String.AppendString[h.text, commandString];commandString _ "Delete"L;houseLeftX _ houseRightX + interCommandSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];h _ h.nextHouse _ intC.deleteCommandHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[commandString.length],	fixedEdge: left,	typeface: boldFace,	needsConfirmation: FALSE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: DeleteCommand,	houseRefresher: TextHouseRefresher];String.AppendString[h.text, commandString];commandString _ "Undelete"L;houseLeftX _ houseRightX + interCommandSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];h _ h.nextHouse _ intC.undeleteCommandHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[commandString.length],	fixedEdge: left,	typeface: boldFace,	needsConfirmation: FALSE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: UndeleteCommand,	houseRefresher: TextHouseRefresher];String.AppendString[h.text, commandString];IF intC.disableWriting THEN	BEGIN	commandString _ ""L;	houseLeftX _ houseRightX;	ENDELSE BEGIN	commandString _  "Move to"L;	houseLeftX _ houseRightX + interCommandSpacing;	houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];	END;h _ h.nextHouse _ intC.moveToCommandHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[commandString.length],	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: MoveMessageToFileCommand,	houseRefresher: TextHouseRefresher];String.AppendString[h.text, commandString];IF intC.disableWriting THEN	BEGIN	commandString _ NIL;	houseLeftX _ houseRightX;	ENDELSE BEGIN	houseLeftX _ houseRightX + preBracketSpacing;	houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];	commandString _ AllocateStateString[maxBracketStringLength];	END;intC.moveToBracketsHouse _ h _ h.nextHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: commandString,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: IF intC.disableWriting THEN TextHouseRefresher							ELSE BracketsHouseRefresher];houseRightX _ rightMargin;IF intC.disableWriting THEN	BEGIN	commandString _ ""L;	houseLeftX _ houseRightX;	ENDELSE BEGIN	commandString _  "Hardcopy"L;	houseLeftX _ houseRightX - dsD.GetStringWidth[commandString, boldFace];	END;intC.hardcopyCommandHouse _ h _ h.nextHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[commandString.length],	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: FALSE,	callable: TRUE,	command: HardcopyCommand,	houseRefresher: TextHouseRefresher];String.AppendString[h.text, commandString];np _ AllocateStateNode[SIZE[Nbr]];np^ _ Nbr	[nextNbr: NIL,	nLines: 0,	topY: 0,	bottomY: 0,	leftX:  leftMargin,	rightX:  rightMargin,	cursorShape: bullsEye,	nbrVariant: command		[houses: hp,		nbrTracker: CommandTracker]];END;  -- of InitTOCCommandNbr --InitDMTextNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in the DMTextNbr.BEGINline: LinePtr _ intC.linePoolPtr;intC.linePoolPtr _ line.nextLine;np _ intC.dmTextNbr _ AllocateStateNode[SIZE[Nbr]];np^ _ Nbr	[nextNbr: NIL,	nLines: 0,	topY: 0,	bottomY: 0,	leftX: 0,	rightX:  rightMargin,	cursorShape: charArrow,	nbrVariant: messageText		[haveMessage: FALSE,		editable: FALSE,		lines: line,		firstLineOffScreen: line,		message: NIL,		protectedFieldPtr: NIL,		insertionBuffer: NIL,		deletionBuffer: NIL,		endString: endOfMessageString,		nbrTracker: TextNbrTracker]];line.nextLine _ NIL;line.y _ 0;line.state _ trailingBlankLine;line.rightX _  leftMargin;line.firstCharIndex _ 0;END;  -- of InitDMTextNbr --InitCMCommandNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in the CMCommandNbr.BEGINh, hp: HousePtr;houseLeftX, houseRightX: dsD.ScreenXCoord;commandString: STRING _ [maxCommandString];commandString _ "New form"L;houseLeftX _  leftMargin + commandIndent;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];hp _ h _ intC.newFormCommandHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[commandString.length],	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: NewFormCommand,	houseRefresher: TextHouseRefresher];String.AppendString[h.text, commandString];commandString _ "Answer"L;houseLeftX _ houseRightX + interCommandSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];h _ h.nextHouse _ intC.answerCommandHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[commandString.length],	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: AnswerCommand,	houseRefresher: TextHouseRefresher];String.AppendString[h.text, commandString];commandString _ "Forward"L;houseLeftX _ houseRightX + interCommandSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];h _ h.nextHouse _ intC.forwardCommandHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[commandString.length],	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: ForwardCommand,	houseRefresher: TextHouseRefresher];String.AppendString[h.text, commandString];commandString _ "Get"L;houseLeftX _ houseRightX + interCommandSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];intC.getCommandHouse _ h _ h.nextHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[commandString.length],	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: GetCommand,	houseRefresher: TextHouseRefresher];String.AppendString[h.text, commandString];IF intC.disableWriting THEN	BEGIN	commandString _ ""L;	houseLeftX _ houseRightX;	ENDELSE BEGIN	commandString _  "Put"L;	houseLeftX _ houseRightX + interCommandSpacing;	houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];	END;h _ h.nextHouse _ intC.putCommandHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[commandString.length],	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: PutCommand,	houseRefresher: TextHouseRefresher];String.AppendString[h.text, commandString];commandString _ "Copy"L;houseLeftX _ houseRightX + interCommandSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];intC.copyCommandHouse _ h _ h.nextHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[commandString.length],	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: CopyCommand,	houseRefresher: TextHouseRefresher];String.AppendString[h.text, commandString];commandString _ "Run"L;houseLeftX _ houseRightX + interCommandSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];h _ h.nextHouse _ intC.runCommandHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[commandString.length],	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: FALSE,	callable: TRUE,	command: RunCommand,	houseRefresher: TextHouseRefresher];String.AppendString[h.text, commandString];commandString _ "delivered";houseRightX _  rightMargin;houseLeftX _ houseRightX - dsD.GetStringWidth[commandString, italicFace];h _ h.nextHouse _ intC.deliverCommandHouse _ AllocateStateNode[SIZE[House]];h^ _ House	[nextHouse: NIL,	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[commandString.length],	fixedEdge: right,	typeface: italicFace,	needsConfirmation: TRUE, -- was FALSE	trackerIndicateDone: TRUE,	callable: FALSE,	command: SendCommand,	houseRefresher: TextHouseRefresher];np _ AllocateStateNode[SIZE[Nbr]];np^ _ Nbr	[nextNbr: NIL,	nLines: 0,	topY: 0,	bottomY: 0,	leftX:  leftMargin,	rightX:  rightMargin,	cursorShape: bullsEye,	nbrVariant: command		[houses: hp,		nbrTracker: CommandTracker]];END;  -- of InitCMCommandNbr --InitCMTextNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in the CMTextNbr.BEGINline: LinePtr _ intC.linePoolPtr;intC.linePoolPtr _ line.nextLine;np _ intC.cmTextNbr _ AllocateStateNode[SIZE[Nbr]];np^ _ Nbr	[nextNbr: NIL,	nLines: 0,	topY: 0,	bottomY: 0,	leftX: 0,	rightX:  rightMargin,	cursorShape: charArrow,	nbrVariant: messageText		[haveMessage: TRUE,		editable: TRUE,		lines: line,		firstLineOffScreen: line,		message: NIL,		protectedFieldPtr: NIL,		insertionBuffer: NIL,		deletionBuffer: NIL,		endString: endOfMessageString,		nbrTracker: TextNbrTracker]];line.nextLine _ NIL;line.y _ 0;line.state _ endOfMessage;line.rightX _  leftMargin;line.firstCharIndex _ 0;END;  -- of InitCMTextNbr --InitExceptionsNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in the ExceptionsNbr.BEGINline: LinePtr _ intC.linePoolPtr;intC.linePoolPtr _ line.nextLine;np _ AllocateStateNode[SIZE[Nbr]];np^ _ Nbr	[nextNbr: NIL,	nLines: 0,	topY: 0,	bottomY: 0,	leftX:  leftMargin,	rightX:  rightMargin,	cursorShape: charArrow,	nbrVariant: messageText		[haveMessage: FALSE,		editable: FALSE,		lines: line,		firstLineOffScreen: line,		message: NIL,		protectedFieldPtr: NIL,		insertionBuffer: NIL,		deletionBuffer: NIL,		endString: NIL,		nbrTracker: ExceptionsTracker]];line.nextLine _ NIL;line.y _ 0;line.state _ trailingBlankLine;line.rightX _  leftMargin;line.firstCharIndex _ 0;END;  -- of InitExceptionsNbr --BuildSwappableMenus: PROCEDURE =BEGINhouse: House;houseLeftX, houseRightX: ScreenXCoord;currentString: STRING;bracketString: STRING _ [maxBracketStringLength];base: POINTER;nextSlot, segmentLimit: CARDINAL;currentSegment: lsD.StateSegment;InitSegment: PROCEDURE [seg: POINTER TO lsD.StateSegment, nPages: lsD.PageCount] =	BEGIN	seg^ _ currentSegment _ lsD.DefineStateSegment[nPages];	base _ lsD.SwapInStateSegment[currentSegment];	nextSlot _ 0;	segmentLimit _ nPages * AltoDefs.PageSize;	END;  -- of MakeSegment --AddToSegment: PROCEDURE =	-- adds contents of house and s to the current segment;	BEGIN	IF nextSlot + SIZE[House] > segmentLimit THEN exD.SysBug[];	Inline.COPY[from: @house, nwords: SIZE[House], to: base + nextSlot];	nextSlot _ nextSlot + SIZE[House];	IF nextSlot + String.WordsForString[currentString.maxlength] > segmentLimit		THEN exD.SysBug[];	Inline.COPY[from: currentString,							nwords: String.WordsForString[currentString.maxlength],							to: base + nextSlot];	nextSlot _ nextSlot + String.WordsForString[currentString.maxlength];	END;  -- of AddToSegment --FinishSegment: PROCEDURE =	BEGIN	lsD.WriteStateSegment[currentSegment];	lsD.ReleaseStateSegment[currentSegment];	END;  -- of FinishSegment --InitSegment[@intC.hardcopyMenuSegment, 1];currentString _ "Printer"L;houseLeftX _ leftMargin;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: FALSE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: SetPrinterCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ bracketString;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ "Form"L;houseLeftX _  leftMargin + 260;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: FALSE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: SetOverrideFormCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ bracketString;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ "Hardcopy"L;houseLeftX _  intC.hardcopyCommandHouse.leftX;houseRightX _ rightMargin;house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: FALSE,	callable: TRUE,	command: HardcopyConfirmCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ "Copies"L;houseLeftX _ leftMargin;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: FALSE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: SetCopiesCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ "99"L;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ "Two sided"L;houseLeftX _  leftMargin + 110;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: FALSE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: SetDuplexCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ "Yes"L;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[3],  -- length of "Yes" --	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ "Private"L;houseLeftX _ leftMargin + 260;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: FALSE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: SetPasswordProtectedCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ "Yes"L;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[3],  -- length of "Yes" --	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ "Cancel"L;houseRightX _  rightMargin;houseLeftX _ houseRightX - dsD.GetStringWidth[currentString, boldFace];house _ House	[nextHouse: LOOPHOLE[0],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: FALSE,	callable: TRUE,	command: HardcopyCancelCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];FinishSegment[];InitSegment[@intC.getPutMenuSegment, 1];currentString _ "File name"L;houseLeftX _  leftMargin;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, italicFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: italicFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ bracketString;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ ""L;houseRightX _  rightMargin;houseLeftX _  rightMargin - dsD.GetPictureParameters[resetMenuIcon].width;house _ House	[nextHouse: LOOPHOLE[0],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	picture: resetMenuIcon,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: FALSE,	callable: TRUE,	usePicture: TRUE,	command: ShortenEditorMenuCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];FinishSegment[];InitSegment[@intC.runMenuSegment, 1];currentString _ "Program"L;houseLeftX _  leftMargin;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, italicFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: italicFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ bracketString;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ ""L;houseRightX _  rightMargin;houseLeftX _  rightMargin - dsD.GetPictureParameters[resetMenuIcon].width;house _ House	[nextHouse: LOOPHOLE[0],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	picture: resetMenuIcon,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: FALSE,	callable: TRUE,	usePicture: TRUE,	command: ShortenEditorMenuCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];FinishSegment[];InitSegment[@intC.copyMenuSegment, 1];currentString _ "from"L;houseLeftX _  leftMargin;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, italicFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: italicFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ bracketString;houseLeftX _ houseRightX + 2;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ "to"L;houseLeftX _  leftMargin + 240;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, italicFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: italicFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ bracketString;houseLeftX _ houseRightX + 2;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ ""L;houseRightX _  rightMargin;houseLeftX _  rightMargin - dsD.GetPictureParameters[resetMenuIcon].width;house _ House	[nextHouse: LOOPHOLE[0],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	picture: resetMenuIcon,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: FALSE,	callable: TRUE,	usePicture: TRUE,	command: ShortenEditorMenuCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];FinishSegment[];InitSegment[@intC.findMenuSegment, 1];currentString _ "Find"L;houseLeftX _  leftMargin;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: FindCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ bracketString;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ ""L;houseRightX _  rightMargin;houseLeftX _  rightMargin - dsD.GetPictureParameters[resetMenuIcon].width;house _ House	[nextHouse: LOOPHOLE[0],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	picture: resetMenuIcon,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: FALSE,	callable: TRUE,	usePicture: TRUE,	command: ShortenEditorMenuCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];FinishSegment[];InitSegment[@intC.substituteMenuSegment, 1];currentString _ "Substitute"L;houseLeftX _  leftMargin;houseRightX _ houseLeftX  + dsD.GetStringWidth[currentString, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: SubstituteCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ bracketString;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ " for"L;houseLeftX _  leftMargin + 210;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, italicFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: italicFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: FindCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ bracketString;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ ""L;houseRightX _  rightMargin;houseLeftX _  rightMargin - dsD.GetPictureParameters[resetMenuIcon].width;house _ House	[nextHouse: LOOPHOLE[0],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	picture: resetMenuIcon,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: FALSE,	callable: TRUE,	usePicture: TRUE,	command: ShortenEditorMenuCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];FinishSegment[];END;  -- of BuildSwappableMenus --NewDCB: PROCEDURE RETURNS [dcbPtr: dsD.DCBptr] =-- Returns  a pointer to a newly allocated blank DCB.BEGINdcbPtr _ Even[SIZE[dsD.DCB]];dcbPtr^ _ dsD.DCB	[next: dsD.DCBnil,	resolution: high,	background: drD.videoBackground,	indenting: 0,	width: 0,	bitmap: LOOPHOLE[0],	height: 0];END;  -- of NewDCB --Even: PRIVATE PROCEDURE [nWords: CARDINAL] RETURNS [p: POINTER] =-- Allocates nWords starting at an even address.BEGINp _ AllocateStateNode[nWords + 1];p _ p + Inline.BITAND[p, 1];END;  -- of Even --AllocateLinePool: PRIVATE PROCEDURE RETURNS [line: LinePtr] =-- Allocates enough lines to fill the screen as defined in dsD.numScanLines, links them--   together and returns a pointer to the top of the chain.BEGINnode: LinePtr;line _ NIL;THROUGH [0 .. dsD.numScanLines / dsD.lineHeight + 5) DO	node _ AllocateStateNode[SIZE[Line]];	node.nextLine _ line;	node.state _ trailingBlankLine;	node.rightX _ inD.leftMargin;	line _ node;	ENDLOOP;END;  -- of AllocateLinePool --END.  -- of InitInteractor --z20461(529)\f1