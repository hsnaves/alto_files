-- file:  LaurelNub.Mesa-- edited by Levin, April 14, 1981  4:22 PM-- edited by Brotz, April 1, 1981  4:47 PM-- edited by Schroeder: Wednesday Nov. 5, 1980 5:09 pm PST.DIRECTORY  ControlDefs,  CoreSwapDefs,  crD: FROM "CoreDefs",  displayCommon: FROM "DisplayCommon",  drD: FROM "LaurelDriverDefs",  dsD: FROM "DisplayDefs",  exD: FROM "ExceptionDefs",  FrameDefs,  gsD: FROM "GlobalStorageDefs",  inD: FROM "InteractorDefs",  Inline,  intCommon: FROM "IntCommon",  KeyDefs,  MiscDefs,  ovD: FROM "OverviewDefs",   -- PerfDefs,  ProcessDefs,  RetrieveDefs,  SegmentDefs,  Storage,  String;LaurelNub: PROGRAM   IMPORTS disC: displayCommon, drD, dsD, exD, FrameDefs, inD, Inline,    intC: intCommon, MiscDefs, -- PerfDefs,-- ProcessDefs, RetrieveDefs, SegmentDefs, Storage, String  = PUBLICBEGINOPEN drD;topMargin: inD.ScreenYCoord = 40;AllocateAndInitBitMap: PROCEDURE =BEGINOPEN SegmentDefs;wordsForBitMap: CARDINAL _ dsD.numScanLines * dsD.bmWidth;pagesForBitMap: CARDINAL _ (wordsForBitMap + 255) / 256;[] _ Storage.Prune[];disC.bitMapPtr _ LOOPHOLE[DataSegmentAddress  [MakeDataSegment[DefaultBase, pagesForBitMap, HardDown]]];END;  -- of AllocateAndInitBitMap --AllocateAndInitBbts: PROCEDURE =-- Allocates and fills in constant fields of the BITBLT tables.  Note: must be called AFTER--   the last AllocateAndInitBitMap.BEGIN OPEN dsD;MakeBbt: PROCEDURE RETURNS [POINTER] =  -- Allocates SIZE[Bbt] words starting at an even address  BEGIN  p: POINTER _ Storage.Node[SIZE[Bbt] + 1];  RETURN[p + Inline.BITAND[p, 1]];  END;  -- of Even --charBbtPtr _ MakeBbt[];charBbtPtr^ _	[func: paint + source,	dbca: disC.bitMapPtr,	dlx: , dty: , dw: , dh: ,	sbca: , sbmr: 1,	slx: 0, sty: 0];bbtPtr _ MakeBbt[];bbtPtr^ _	[func: ,	dbca: disC.bitMapPtr,	dlx: , dty: , dw: , dh: ,	sbca: disC.bitMapPtr, sbmr: dsD.bmWidth,	slx: , sty: ];pictureBbtPtr _ MakeBbt[];pictureBbtPtr^ _	[func: ,	dbca: disC.bitMapPtr,	dlx: , dty: , dw: , dh: ,	sbca: , sbmr: 1,	slx: 0, sty: 0];disC.bitMapReady _ TRUE;END;  -- of AllocateAndInitBbts --CheckForDebuggerCall: PROCEDURE =BEGINOPEN CoreSwapDefs, KeyDefs;IF (intC.debuggerExtant    _ PuntInfo^ ~= NIL AND PuntInfo^^.pDebuggerFP ~= NIL)  AND Keys.Spare2 = down AND Keys.Spare3 = down THEN  BEGIN  debuggingCursor: dsD.CursorBitMap = [     001000B, 002400B, 005200B, 012500B, 025240B, 052540B, 025240B, 012740B,    005240B, 003760B, 000030B, 000014B, 000006B, 000003B, 000001B, 000000B ];  savedCursor: dsD.CursorBitMap _ dsD.cursorBM^;  dsD.cursorBM^ _ debuggingCursor;  MiscDefs.WorryCallDebugger["Get that bug!"L];  dsD.cursorBM^ _ savedCursor;  END;END;  -- CheckForDebuggerCall --InitializeLaurel: PROCEDURE =BEGINinstallError: drD.InstallError;commandInCommandLine: CommandLineAction;ProcessCommandLine: PROCEDURE [entryKind: CommandLineAction] =  BEGIN  inBoxState: RetrieveDefs.MBXState;  intC.mailFileBracketsHouse.houseRefresher[intC.mailFileBracketsHouse];  SELECT entryKind FROM    gmfOnly => SimulateCommandInHouse[intC.mailFileCommandHouse];     checkOnly =>      BEGIN      inBoxState _ RetrieveDefs.MailboxState[intC.retrieveHandle];      IF ~(inBoxState = notEmpty OR inBoxState = badPwd) THEN        SimulateCommandInHouse[intC.quitCommandHouse];      SimulateCommandInHouse[intC.mailFileCommandHouse];       IF intC.haveMailFile AND inBoxState = notEmpty THEN        SimulateCommandInHouse[intC.newMailCommandHouse];      END;    gnmAndStay =>      BEGIN      SimulateCommandInHouse[intC.mailFileCommandHouse];       inBoxState _ RetrieveDefs.MailboxState[intC.retrieveHandle];      IF intC.haveMailFile AND inBoxState = notEmpty THEN        SimulateCommandInHouse[intC.newMailCommandHouse];      END;    sendOnly =>      BEGIN      IF intC.mailFileBracketsHouse.text.length # 0 THEN        SimulateCommandInHouse[intC.mailFileCommandHouse];      SimulateCommandInHouse[intC.newFormCommandHouse];      END;    sendBug => ProcessBugReport[];    ENDCASE;  intC.audioEnabled _ (intC.newMailTune # NIL);  END;  -- of ProcessCommandLine --SimulateCommandInHouse: PROCEDURE [hp: inD.HousePtr] =  -- Simulates command selection, including graying.  -- Will not work properly for picture houses.  BEGIN  dsD.ReplaceRectangle[hp.leftX, hp.rightX, hp.topY, hp.bottomY, lightGray];  [] _ dsD.PutStringInBitMap[hp.leftX, hp.topY, hp.text, boldFace];  hp.command[hp, TRUE];  dsD.ClearRectangle[hp.leftX, hp.rightX, hp.topY, hp.bottomY];  [] _ dsD.PutStringInBitMap[hp.leftX, hp.topY, hp.text, hp.typeface];  IF inD.CaretIsBlinking[] THEN inD.SetCaretBlinking[intC.target.point, intC.target.mnp];  END; -- of SimulateCommandInHouse ---- ****************************-- Initialization Code Proper-- ****************************[commandInCommandLine, installError] _ PreInit[];AllocateAndInitBitMap[];AllocateAndInitBbts[];dsD.ClearRectangle  [inD.leftMargin, inD.rightMargin, dsD.yOrigin, dsD.yOrigin + dsD.numScanLines];IF installError = inLog THEN  BEGIN  intC.mailFileBracketsHouse.text.length _ 0;  String.AppendString[intC.mailFileBracketsHouse.text, "InstallErrors"L];  END;inD.SetScreenParameters  [[4,  -- mailCommandRegion  12,  -- tocRegion  3,    -- tocCommandRegion  19,  -- dmRegion  3,    -- cmCommandRegion  16,  -- cmRegion  3]];    -- exceptionsRegion-- report error from ReadLaurelProfile, if anySELECT installError FROM  none => NULL;  inLog =>    BEGIN    SimulateCommandInHouse[intC.mailFileCommandHouse];     SimulateCommandInHouse[intC.displayCommandHouse];     SimulateCommandInHouse[intC.deleteCommandHouse];     exD.DisplayException[exD.installFailed];    END;  ENDCASE => exD.SysBug[message: "Deep yoghurt."L];ProcessDefs.Yield[]; -- let EtherProbe run-- Now act on the command line switches.IF installError = none THEN ProcessCommandLine[commandInCommandLine];ProcessDefs.Yield[]; -- let EtherProbe runEND; -- of InitializeLaurel ----  This is where it all gets started...PreInit: PORT RETURNS  [commandInCommandLine: CommandLineAction, installError: InstallError];LOOPHOLE[PreInit, ControlDefs.Port].out _ @ResumeNub;START LOOPHOLE[FrameDefs.GlobalFrame[PreStopInitialization], PROGRAM];LOOPHOLE[ResumeNub, ControlDefs.Port].out _ @PreInit;LOOPHOLE[ResumeNub, ControlDefs.Port].in _ PreStopInitialization;[] _ PreInit[];STOP;-- START PerfDefs.AltoMesaPerfMonitor;CheckForDebuggerCall[]; -- cannot be done before the STOPInitializeLaurel[]; -- do the Laurel initializationdsD.SetCursor[bullsEye];inD.ScreenTracker[normal];END.  -- of LaurelNub --z19932(635)\f1