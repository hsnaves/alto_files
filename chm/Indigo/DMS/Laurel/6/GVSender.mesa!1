-- GVSender.mesa-- Edited by Schroeder, April 2, 1981  10:37 AM-- Edited by Brotz, April 8, 1981  4:06 PMDIRECTORY  BodyDefs,  exD: FROM "ExceptionDefs",  intCommon: FROM "intCommon",  LaurelSendDefs,  ovD: FROM "OverviewDefs",  SendDefs,  String;GVSender: PROGRAM  IMPORTS exD, intC: intCommon, LaurelSendDefs, SendDefs, String  EXPORTS LaurelSendDefs =BEGIN OPEN LaurelSendDefs;GVSend: PUBLIC PROCEDURE [publicDLs: CARDINAL, sendMode: SendMode,  netMail:BOOLEAN, fromField:BOOLEAN, replyTo: BOOLEAN, formatProc: PROCEDURE] =BEGINscreenStringLength: CARDINAL = 100;maxRecipientsWithoutConfirmation: CARDINAL = 20;utilityString: STRING = [screenStringLength];sendHandle: SendDefs.Handle;badList, badOther, charsDelivered, recipients: CARDINAL;nameListFull: BOOLEAN;RecordInvalidRecipient: PROCEDURE [recipNo: CARDINAL, name: BodyDefs.RName] =  BEGIN  IF utilityString.length+name.length+3 <= utilityString.maxlength    THEN BEGIN      IF utilityString.length > 0 THEN String.AppendString[utilityString, ", "L];      String.AppendString[utilityString, name];      END    ELSE nameListFull _ TRUE;  FOR i: CARDINAL DECREASING IN [1 .. name.length) DO    IF name[i] = '. THEN BEGIN      IF name[i-1] = '^        THEN badList _ badList + 1        ELSE badOther _ badOther + 1;      EXIT;      END;    REPEAT FINISHED => badOther _ badOther + 1;  ENDLOOP;  AbortPoint[];  END;SendRecipient: PROCEDURE[name: STRING] RETURNS[BOOLEAN] =  BEGIN  FOR i: CARDINAL IN [0 .. name.length) DO    IF name[i] = '. THEN EXIT;    REPEAT FINISHED =>      BEGIN --append registry, it will fit      String.AppendChar[name, '.];      String.AppendString[name, intC.user.registry];      END;    ENDLOOP;  SendDefs.AddRecipient[sendHandle, name];  AbortPoint[];  RETURN[FALSE] --stop sending recipients if abort  END;  -- of SendRecipient --SendBodyBlock: PROCEDURE[block: POINTER, bytes: CARDINAL] =  BEGIN  buffer: DESCRIPTOR FOR PACKED ARRAY OF CHARACTER =    DESCRIPTOR[block, bytes];  SendDefs.AddToItem[sendHandle, buffer];  charsDelivered _ charsDelivered+bytes;  END;BuildCredentialsString: PROCEDURE =  BEGIN  utilityString.length _ 0;  String.AppendString[utilityString, intC.user.name];  String.AppendChar[utilityString, '.];  String.AppendString[utilityString, intC.user.registry];  END;-- main body of GVSendutilityString.length _ 0;recipients _ GetRecipients[];IF publicDLs > 0  THEN BEGIN    others: CARDINAL = recipients - publicDLs;    String.AppendDecimal[utilityString, publicDLs];    String.AppendString[utilityString, " public distribution list"L];    IF publicDLs > 1 THEN String.AppendChar[utilityString, 's];    IF others # 0 THEN BEGIN      String.AppendString[utilityString, " + "L];      String.AppendDecimal[utilityString, others];      String.AppendString[utilityString, " other recipients"L];      IF others = 1 THEN utilityString.length _ utilityString.length - 1;      END;    END  ELSE BEGIN    String.AppendDecimal[utilityString, recipients];    String.AppendString[utilityString, " recipient"L];    IF recipients # 1 THEN String.AppendChar[utilityString, 's];    END;IF sendMode = red AND (publicDLs > 0 OR recipients > maxRecipientsWithoutConfirmation)  AND ~replyTo THEN {exD.DisplayExceptionString[utilityString]; InsertReplyToField[]};formatProc[];ReportProgress[exD.nil, utilityString, TRUE];sendHandle _ SendDefs.Create[];DO  ENABLE BEGIN    SendDefs.SendFailed =>      IF notDelivered        THEN BEGIN          ReportProgress[exD.anotherServer, NIL, TRUE];          LOOP          END        ELSE ReportError[uncertainClosing, "Communication failure."L, 0, 0];    UNWIND =>        {SendDefs.Abort[sendHandle]; SendDefs.Destroy[sendHandle]};    END;  AbortPoint[];  BuildCredentialsString[];   exD.AppendStringToExceptionLine[" ..."L, 1];  SELECT SendDefs.StartSend[sendHandle, intC.user.password,      utilityString, NIL, TRUE] FROM    badSender, badPwd => ReportError[badSender, NIL, 0, 0];    badReturnTo => exD.SysBug[];    allDown => ReportError[cantConnect, NIL, 0, 0];    ENDCASE; --ok--  exD.AppendStringToExceptionLine["."L, 1];  [] _ EnumerateRecipientList[intC.user.registry.length+1, SendRecipient];  badList _ 0; badOther _ 0; nameListFull _ FALSE; utilityString.length _ 0;  IF SendDefs.CheckValidity[sendHandle, RecordInvalidRecipient] = 0    THEN ReportError[noValidRecipients, NIL, 0, 0];  IF sendMode = red AND badList + badOther > 0    THEN ReportRejectedRecipients[badList+badOther, utilityString, nameListFull];  SendDefs.StartText[sendHandle];  charsDelivered _ 0;  DeliverBody[netMail, fromField, SendBodyBlock];  SendDefs.Send[sendHandle];  EXIT;  ENDLOOP;BEGIN  totalOther: CARDINAL = recipients-publicDLs;  ReportDelivery[charsDelivered, totalOther-badOther, totalOther, publicDLs-badList, publicDLs];  END;SendDefs.Destroy[sendHandle];END;  -- GVSend --END.  -- of GVSender --(635)\f1