-- file:  IntMailCom.Mesa-- edited by Schroeder, November 5, 1980  10:30 AM-- edited by Horning, January 30, 1978  5:26 PM-- edited by Brotz, March 23, 1981  3:23 PM-- edited by Levin, January 16, 1981  3:08 PMDIRECTORY  AltoFileDefs,  crD: FROM "CoreDefs",  displayCommon: FROM "DisplayCommon",  dsD: FROM "DisplayDefs",  exD: FROM "ExceptionDefs",  ImageDefs,  inD: FROM "InteractorDefs",  Inline,  intCommon: FROM "IntCommon",  lmD: FROM "LaurelMenuDefs",  Mopcodes,  opD: FROM "OperationsDefs",  OsStaticDefs,  ovD: FROM "OverviewDefs",  tsD: FROM "TOCSelectionDefs",  vmD: FROM "VirtualMgrDefs";IntMailCom: PROGRAM  IMPORTS disC: displayCommon, dsD, exD, ImageDefs, inD, Inline, intC: intCommon,    lmD, opD, tsD, vmD  EXPORTS inD  SHARES inD = PUBLICBEGINOPEN inD;-- Purpose: handles user interactions including the display, keyboard and mouse.  This--   division gathers together commands and their arguments and is responsible for the--   display of all error messages.GetMailFileCommand: PROCEDURE [hp: HousePtr, confirmed: BOOLEAN] =-- Implements Get mail file.  Returns current mail file, clears screen selectively, uses--   GetMailFileOperation to obtain new mail, sets up new TOC display.BEGIN-- Calls ReturnMailFileOperation with activeMailFileName and TOCStructure.  Clears--   TOC-entries neighborhood and clears DM-text neighborhood.  Calls GetMailFileOperation--   with GMFFileName, user's file server name, password and file server port.; calls--   DisplayException if failure is reported back.  Determines what portion of the TOC should--   be displayed, selects a default selected message interval, and calls DisplayTOC to display--   the TOC.error: ovD.ErrorCode;i, firstUnSeenTOCIndex: vmD.TOCIndex;dm: MessageTextNbrPtr = intC.dmTextNbr;toc: TOCTextNbrPtr = intC.tocTextNbr;successful: BOOLEAN _ FALSE;IF ~confirmed AND~ConfirmBrackets[hp: intC.mailFileBracketsHouse, fileExtension: ".mail."L] THEN RETURN;dsD.ClearRectangle[leftMargin, rightMargin, toc.topY, toc.bottomY];dsD.ClearRectangle[leftMargin, rightMargin, dm.topY, dm.bottomY];BEGIN -- for EXITS --IF intC.haveMailFile THEN  {dm.haveMessage _ FALSE; IF CallReturnOp[]#ovD.ok THEN GOTO ReturnExit};[error, firstUnSeenTOCIndex] _ opD.GetMailFileOperation[intC.mailFileBracketsHouse.text];SELECT error FROM  ovD.ok => NULL;  ovD.notAMailFile => {exD.DisplayException[exD.formatErrorCantGet]; GOTO ReturnExit};  ovD.badMailFile => exD.DisplayException[exD.mayBeTruncated];  ovD.tOCOverflow => exD.DisplayException[exD.tocOverflowSomeNotIndexed];  ovD.diskFull => exD.DisplayException[exD.diskFullSomeNotIndexed];  ovD.illegalFilename =>{exD.DisplayException[exD.illegalMailFileName]; GOTO ReturnExit};  ovD.fileInUse =>{exD.DisplayException[exD.fileInUse]; GOTO ReturnExit};  ENDCASE => {exD.DisplayException[exD.diskErrorGetFailed]; GOTO ReturnExit};intC.haveMailFile _ TRUE;tsD.ResetTOCSelection[];IF firstUnSeenTOCIndex # 0 THEN -- some unseen entry exists  tsD.SetTOCSelection[firstUnSeenTOCIndex]ELSE IF (i _ vmD.GetFirstFreeTOCIndex[]) > 1 THEN tsD.SetTOCSelection[i - 1];successful _ TRUE;GOTO ReturnExit;EXITSReturnExit =>  IF successful THEN TOCTextPainter[intC.tocTextNbr] ELSE UpdateTOCThumbLine[];END;  -- for EXITS --END;  -- of GetMailFileCommand --CallReturnOp: PROCEDURE RETURNS [error: ovD.ErrorCode] =-- Bundles up buffer allocations and ReturnOp call.BEGINtocDcb: dsD.DCBptr = intC.TOCRegion.dcb;dmDcb: dsD.DCBptr = intC.DMRegion.dcb;dm: MessageTextNbrPtr = intC.dmTextNbr;toc: TOCTextNbrPtr = intC.tocTextNbr;base1: ORDERED POINTER = Inline.BITAND[tocDcb.bitmap+377B, 177400B];base2: ORDERED POINTER = Inline.BITAND[dmDcb.bitmap+377B, 177400B];buffer: opD.BufferRecord;buffer.b1 _ base1; buffer.b2 _ base2;buffer.s1 _ IF intC.TOCCommandRegion.dcb.bitmap < base1 THEN 0             ELSE intC.TOCCommandRegion.dcb.bitmap - base1;buffer.s2 _ IF intC.CMCommandRegion.dcb.bitmap < base2 THEN 0             ELSE intC.CMCommandRegion.dcb.bitmap - base2;-- blank buffers on screen:tocDcb.width _ dmDcb.width _ 0;error _ opD.ReturnMailFileOperation[@buffer];intC.haveMailFile _ FALSE;dsD.ClearRectangle[leftMargin, rightMargin, toc.topY, toc.bottomY];dsD.ClearRectangle[leftMargin, rightMargin, dm.topY, dm.bottomY];tocDcb.width _ dmDcb.width _ dsD.bmWidth;IF error # ovD.ok THEN exD.DisplayException[exD.returnMayBeDamaged];END;  -- of CallReturnOp --QuitCommand: PROCEDURE [hp: HousePtr, confirmed: BOOLEAN] =-- Calls QuitOperation.  Calls DisplayException if failure is reported back.BEGINIF ~confirmed AND ~Confirm[1] THEN RETURN;IF intC.composedMessageEdited AND vmD.GetMessageSize[intC.cmTextNbr.message] # 0  AND ~AskUserToConfirm[exD.messageNotFiled] THEN RETURN;IF intC.haveMailFile AND CallReturnOp[] # ovD.ok THEN RETURN;lmD.ChangeEditorMenu[singleLine];vmD.CleanupCMs[];dsD.ClearDCBs[];ImageDefs.StopMesa[];END;  -- of QuitCommand --GetNewMailCommand: PROCEDURE [hp: HousePtr, confirmed: BOOLEAN] =BEGINtoc: TOCTextNbrPtr = intC.tocTextNbr;oldFirstFreeIndex: vmD.TOCIndex;IF ~intC.haveMailFile THEN {exD.DisplayException[exD.noFileCantGetMail]; RETURN};oldFirstFreeIndex _ vmD.GetFirstFreeTOCIndex[];intC.audioEnabled _ FALSE;IF opD.AccessNewMailOperation[] THEN  BEGIN --new items added to TOC  dsD.ClearRectangle[leftMargin, rightMargin, toc.topY, toc.bottomY];  IF oldFirstFreeIndex < vmD.GetFirstFreeTOCIndex[] THEN    tsD.SetTOCSelection[oldFirstFreeIndex];  TOCTextPainter[toc];  END;intC.audioEnabled _ (intC.newMailTune # NIL);END;  -- of GetNewMailCommand --END.  -- of IntMailCom --z19932(635)\f1z19932\f1