-- file:  IntBoundaryCom.Mesa-- edited by Brotz, May 3, 1982  5:32 PM-- edited by Levin, October 24, 1979  4:08 PM-- edited by Taft, May 16, 1983  10:26 AMDIRECTORY  displayCommon USING [bitMapPtr, firstDCB, patchDCBPtr],  dsD: FROM "DisplayDefs" USING [BlackenRectangle, bmWidth, ClearRectangle, DCB,    DCBorg, DCBptr, lineHeight, longDcbSeal, machineFlavor,    MoveFullWidthRectangleVertically, PaintPicture, replace, ScreenYCoord,    xOrigin, yOrigin],  Editor USING [RefreshSoThatFirstCharStartsLine],  exD: FROM "ExceptionDefs" USING [SysBug],  inD: FROM "InteractorDefs" USING [BoundaryLineNbrPtr, BoundaryPadNbrPtr, CharIndex,    CommandNbrPtr, DisplayTOCTail, HousePtr, leftMargin, LinePair, LinePtr, LineState,    MessageTextNbrPtr, RegionPtr, RegionType, rightMargin, ScreenParametersArray,    ScreenYCoord, ThumbLineNbrPtr, TOCTextNbrPtr, UpdateTOCThumbLine],  Inline USING [LowHalf],  intCommon USING [cmCommandNbr, CMCommandRegion, CMRegion, cmTextNbr,    copyMenuSegment, dmcmBoundaryPadNbr, DMRegion, dmTextNbr, editorMenuState,    exceptionsRegion, findMenuSegment, getPutMenuSegment, linePoolPtr,    mailCommandRegion, numScanLines, regions, runMenuSegment, source,    substituteMenuSegment, TOCCommandRegion, tocdmBoundaryPadNbr, TOCRegion, tocTextNbr],  LaurelBitmapDefs USING [BitmapNotifyProc],  lmD: FROM "LaurelMenuDefs" USING [ReleaseMenu],  vmD: FROM "VirtualMgrDefs" USING [TOCHandle, UnlockTOC, WaitForLock];IntBoundaryCom: PROGRAM  IMPORTS disC: displayCommon, dsD, Editor, exD, inD, Inline, intC: intCommon, lmD, vmD  EXPORTS inD, LaurelBitmapDefs =BEGINOPEN inD;bitmapNotifyProc: LaurelBitmapDefs.BitmapNotifyProc _ NIL;MoveTOCDMBoundary: PUBLIC PROCEDURE [bnp: BoundaryPadNbrPtr, y: ScreenYCoord] =-- Changes cursor to boundary-moving shape, tracks cursor anywhere on screen.  While left--   button is down do:  Read curser y-position, compute new boundaries for TOC and DM--   (not to go outside the area bounded by TOC top and DM bottom), call--   SetNominalBufferPool to establish nominal number of pages for TOC and DM, call--   ChangeTOCPosition and ChangeDMPosition to update screen.  Returns when left button--   goes up.BEGINtopAllowableY, bottomAllowableY, tocdmY, dmcmY: ScreenYCoord;tocCommandHeight: CARDINAL =  intC.TOCCommandRegion.bottomY - intC.TOCCommandRegion.topY;cmCommandHeight: CARDINAL =  intC.CMCommandRegion.bottomY - intC.CMCommandRegion.topY;lineDeltaY: CARDINAL = dsD.yOrigin MOD dsD.lineHeight;topAllowableY _ intC.tocTextNbr.topY;bottomAllowableY _ intC.exceptionsRegion.topY - tocCommandHeight - cmCommandHeight;tocdmY _ ((y - lineDeltaY) / dsD.lineHeight) * dsD.lineHeight + lineDeltaY;tocdmY _ MIN[MAX[tocdmY, topAllowableY], bottomAllowableY];IF tocdmY = bnp.topY THEN  {dsD.PaintPicture[bnp.leftX, bnp.topY, boundaryPad, dsD.replace]; RETURN};dmcmY _ MAX[intC.CMCommandRegion.topY, tocdmY + tocCommandHeight];AdjustBoundaries[tocdmY, dmcmY];END;  -- of MoveTOCDMBoundary --MoveDMCMBoundary: PUBLIC PROCEDURE [bnp: BoundaryPadNbrPtr, y: ScreenYCoord] =-- Changes cursor to boundary-moving shape, tracks cursor anywhere on screen.  While left--   button is down do:  Read curser y-position, compute new boundaries for DM and CM--   (not to go outside the area bounded by DM top and CM bottom), call--   SetNominalBufferPool to establish nominal number of pages for DM and CM, call--   ChangeDMPosition and ChangeCMPosition to update screen.  Returns when left button--   goes up.BEGINtopAllowableY, bottomAllowableY, tocdmY, dmcmY: ScreenYCoord;tocCommandHeight: CARDINAL =  intC.TOCCommandRegion.bottomY - intC.TOCCommandRegion.topY;cmCommandHeight: CARDINAL =  intC.CMCommandRegion.bottomY - intC.CMCommandRegion.topY;lineDeltaY: CARDINAL = dsD.yOrigin MOD dsD.lineHeight;topAllowableY _ intC.tocTextNbr.topY + tocCommandHeight;bottomAllowableY _ intC.exceptionsRegion.topY - cmCommandHeight;dmcmY _ ((y - lineDeltaY) / dsD.lineHeight) * dsD.lineHeight + lineDeltaY;dmcmY _ MIN[MAX[dmcmY, topAllowableY], bottomAllowableY];IF dmcmY = bnp.topY THEN  {dsD.PaintPicture[bnp.leftX, bnp.topY, boundaryPad, dsD.replace]; RETURN};tocdmY _ MIN[intC.TOCCommandRegion.topY, dmcmY - tocCommandHeight];AdjustBoundaries[tocdmY, dmcmY];END;  -- of MoveDMCMBoundary --AdjustBoundaries: PUBLIC PROCEDURE [tocdmY, dmcmY: ScreenYCoord] =-- Adjust screen so that the boundary pads will be at tocdmY and dmcmY.BEGINdcb: dsD.DCBptr;oldTocdmY: ScreenYCoord = intC.tocdmBoundaryPadNbr.topY;oldDmcmY: ScreenYCoord = intC.dmcmBoundaryPadNbr.topY;tocCommandHeight: CARDINAL =  intC.TOCCommandRegion.bottomY - intC.TOCCommandRegion.topY;cmCommandHeight: CARDINAL =  intC.CMCommandRegion.bottomY - intC.CMCommandRegion.topY;tocCommandLines: CARDINAL = tocCommandHeight / dsD.lineHeight;cmCommandLines: CARDINAL = cmCommandHeight / dsD.lineHeight;tocDeltaHeight: INTEGER = tocdmY - oldTocdmY;cmDeltaHeight: INTEGER = oldDmcmY - dmcmY;dmDeltaHeight: INTEGER = -(tocDeltaHeight + cmDeltaHeight);tocDeltaLines: INTEGER = tocDeltaHeight / dsD.lineHeight;cmDeltaLines: INTEGER = cmDeltaHeight / dsD.lineHeight;dmDeltaLines: INTEGER = dmDeltaHeight / dsD.lineHeight;IF oldTocdmY = tocdmY AND oldDmcmY = dmcmY THEN RETURN;disC.patchDCBPtr^ _ dsD.DCB  [next: intC.exceptionsRegion.dcb,  resolution: high,  background: intC.mailCommandRegion.dcb.background,  indenting: dsD.xOrigin / 16,  width: dsD.bmWidth,  bitmap: intC.TOCRegion.dcb.bitmap,  tag: intC.TOCRegion.dcb.tag,  height: (intC.exceptionsRegion.topY - intC.TOCRegion.topY) / 2,  longBitmap: intC.TOCRegion.dcb.longBitmap];intC.mailCommandRegion.dcb.next _ disC.patchDCBPtr;IF tocDeltaLines < 0 THEN  MoveRegion    [intC.TOCRegion, intC.TOCRegion.topY, intC.tocTextNbr.nLines + tocDeltaLines];IF cmDeltaLines < 0 THEN  BEGIN  MoveRegion    [intC.CMRegion, intC.CMRegion.topY - cmDeltaHeight,    intC.cmTextNbr.nLines + cmDeltaLines];  MoveRegion[intC.CMCommandRegion, dmcmY, cmCommandLines];  END;IF oldTocdmY > tocdmY THEN  -- dm moving up  MoveRegion[intC.TOCCommandRegion, tocdmY, tocCommandLines];MoveRegion  [intC.DMRegion, tocdmY + tocCommandHeight, intC.dmTextNbr.nLines + dmDeltaLines];IF oldTocdmY < tocdmY THEN  -- dm moving down  MoveRegion[intC.TOCCommandRegion, tocdmY, tocCommandLines];IF tocDeltaLines > 0 THEN  MoveRegion    [intC.TOCRegion, intC.TOCRegion.topY, intC.tocTextNbr.nLines + tocDeltaLines];IF cmDeltaLines > 0 THEN  BEGIN  MoveRegion[intC.CMCommandRegion, dmcmY, cmCommandLines];  MoveRegion    [intC.CMRegion, intC.CMRegion.topY - cmDeltaHeight,    intC.cmTextNbr.nLines + cmDeltaLines];  END;-- Relink dcb's taking into account that a zero height dcb doesn't work right on the Alto.dcb _ intC.exceptionsRegion.dcb;IF intC.CMRegion.dcb.height > 0 THEN  {intC.CMRegion.dcb.next _ dcb; dcb _ intC.CMRegion.dcb};IF intC.CMCommandRegion.dcb.height > 0 THEN  {intC.CMCommandRegion.dcb.next _ dcb; dcb _ intC.CMCommandRegion.dcb};IF intC.DMRegion.dcb.height > 0 THEN  {intC.DMRegion.dcb.next _ dcb; dcb _ intC.DMRegion.dcb};IF intC.TOCCommandRegion.dcb.height > 0 THEN  {intC.TOCCommandRegion.dcb.next _ dcb; dcb _ intC.TOCCommandRegion.dcb};IF intC.TOCRegion.dcb.height > 0 THEN  {intC.TOCRegion.dcb.next _ dcb; dcb _ intC.TOCRegion.dcb};intC.mailCommandRegion.dcb.next _ dcb;IF bitmapNotifyProc # NIL THEN bitmapNotifyProc[];END;  -- of AdjustBoundaries --SetScreenParameters: PUBLIC PROCEDURE [screenParameters: ScreenParametersArray] =-- Sets all Y dependent parameters for the screen.  Links DCB's into the hardware display--   chain.BEGINrp: RegionPtr;y: ScreenYCoord _ dsD.yOrigin;totalLines: CARDINAL _ 0;r: RegionType;FOR r IN RegionType DO  totalLines _ totalLines + screenParameters[r];  ENDLOOP;IF totalLines * dsD.lineHeight > intC.numScanLines THEN exD.SysBug[];disC.firstDCB.height _ y/2;FOR rp _ intC.regions, rp.nextRegion UNTIL rp = NIL DO  MoveRegion[rp, y, screenParameters[rp.regionType]];  y _ y + dsD.lineHeight * screenParameters[rp.regionType];  ENDLOOP;dsD.DCBorg^ _ disC.firstDCB;END;  -- of SetScreenParameters --MoveRegion: PROCEDURE [rp: RegionPtr, topY: ScreenYCoord, nLines: CARDINAL] =-- Sets all Y dependent parameters within a region.  Sets DCB data for the region.BEGINrp.topY _ topY;rp.bottomY _ topY + nLines * dsD.lineHeight;rp.dcb.bitmap _ IF dsD.machineFlavor # dmachine  THEN LOOPHOLE[Inline.LowHalf[disC.bitMapPtr] + (topY - dsD.yOrigin) * dsD.bmWidth, POINTER] ELSE dsD.longDcbSeal;rp.dcb.tag _ IF dsD.machineFlavor # dmachine THEN short ELSE long;rp.dcb.height _ nLines * dsD.lineHeight / 2;rp.dcb.longBitmap _ disC.bitMapPtr + (topY - dsD.yOrigin) * dsD.bmWidth;rp.dcb.width _ dsD.bmWidth;rp.dcb.indenting _ dsD.xOrigin / 16;SELECT rp.regionType FROMmailCommandRegion =>  BEGIN  MoveCommandNbr[LOOPHOLE[rp.nbrs, CommandNbrPtr], topY, nLines - 1];  MoveThumbLineNbr[LOOPHOLE[rp.nbrs.nextNbr, ThumbLineNbrPtr],    topY + LOOPHOLE[nLines - 1, CARDINAL] * dsD.lineHeight,    IF nLines > 0 THEN 1 ELSE 0];  END;tocCommandRegion, cmCommandRegion =>  BEGIN  MoveCommandNbr[LOOPHOLE[rp.nbrs.nextNbr.nextNbr, CommandNbrPtr],    topY + dsD.lineHeight, nLines - 2];  MoveBoundaryLineNbr    [LOOPHOLE[rp.nbrs, BoundaryLineNbrPtr], topY, IF nLines > 0 THEN 1 ELSE 0];  MoveBoundaryPadNbr[LOOPHOLE[rp.nbrs.nextNbr, BoundaryPadNbrPtr],    topY, IF nLines > 0 THEN 1 ELSE 0];  MoveThumbLineNbr[LOOPHOLE[rp.nbrs.nextNbr.nextNbr.nextNbr, ThumbLineNbrPtr],    topY + LOOPHOLE[nLines - 1, CARDINAL] * dsD.lineHeight,    IF nLines > 0 THEN 1 ELSE 0];  END;tocRegion => MoveTOCTextNbr[LOOPHOLE[rp.nbrs, TOCTextNbrPtr], topY, nLines];dmRegion, cmRegion =>  MoveMessageTextNbr[LOOPHOLE[rp.nbrs, MessageTextNbrPtr], topY, nLines];exceptionsRegion =>  BEGIN  MoveMessageTextNbr    [LOOPHOLE[rp.nbrs.nextNbr, MessageTextNbrPtr], topY + dsD.lineHeight, nLines - 1];  MoveBoundaryLineNbr    [LOOPHOLE[rp.nbrs, BoundaryLineNbrPtr], topY, IF nLines > 0 THEN 1 ELSE 0];  END;ENDCASE;END;  -- of MoveRegion --MoveCommandNbr: PROCEDURE [cnp: CommandNbrPtr, topY: ScreenYCoord,  nLines: CARDINAL] =-- Sets all Y position dependent parameters within a CommandNbr data structure.BEGINoldNLines: CARDINAL _ cnp.nLines;oldTopY: ScreenYCoord _ cnp.topY;hp: HousePtr;dsD.MoveFullWidthRectangleVertically  [top: oldTopY, bottom: oldTopY + dsD.lineHeight * MIN[oldNLines, nLines], newTop: topY];cnp.topY _ topY;cnp.bottomY _ topY + nLines * dsD.lineHeight;cnp.nLines _ nLines;FOR hp _ cnp.houses, hp.nextHouse UNTIL hp = NIL DO  hp.bottomY _ (hp.topY _ topY + hp.lineNumber * dsD.lineHeight) + dsD.lineHeight;  ENDLOOP;IF nLines > oldNLines THEN  BEGIN  dsD.ClearRectangle[inD.leftMargin, inD.rightMargin, topY + oldNLines * dsD.lineHeight,    topY + nLines * dsD.lineHeight];  DisplayCommandTail[cnp: cnp, startLineNumber: MIN[oldNLines, nLines],    endLineNumber: nLines];  END;END;  -- of MoveCommandNbr --DisplayCommandTail: PROCEDURE [cnp: CommandNbrPtr, startLineNumber,  endLineNumber: CARDINAL] =-- Paints all houses of cnp whose line numbers are within--   [startLineNumber .. endLineNumber).BEGINhp: HousePtr;FOR hp _ cnp.houses, hp.nextHouse UNTIL hp = NIL DO  IF hp.lineNumber IN [startLineNumber .. endLineNumber) THEN hp.houseRefresher[hp];  ENDLOOP;END;  -- of DisplayCommandTail --MoveBoundaryLineNbr: PROCEDURE [bnp: BoundaryLineNbrPtr, topY: ScreenYCoord,  nLines: CARDINAL] =-- Sets all Y position dependent parameters within a BoundaryLineNbr data structure.BEGINbnp.topY _ topY + dsD.lineHeight/2 - 1;bnp.bottomY _ IF nLines = 0 THEN 0 ELSE topY + dsD.lineHeight/2 + 1;bnp.nLines _ nLines;IF nLines > 0 THEN  BEGIN  dsD.ClearRectangle    [inD.leftMargin, inD.rightMargin, topY, topY + nLines * dsD.lineHeight];  dsD.BlackenRectangle[bnp.leftX, bnp.rightX, bnp.topY, bnp.bottomY];  END;END;  -- of MoveBoundaryLineNbr --MoveBoundaryPadNbr: PROCEDURE [bnp: BoundaryPadNbrPtr, topY: ScreenYCoord,  nLines: CARDINAL] =-- Sets all Y position dependent parameters within a BoundaryPadNbr data structure.BEGINbnp.topY _ topY;bnp.bottomY _ topY + nLines * dsD.lineHeight;bnp.nLines _ nLines;IF nLines > 0 THEN  BEGIN  dsD.ClearRectangle[bnp.leftX, bnp.rightX, bnp.topY, bnp.bottomY];  dsD.PaintPicture[bnp.leftX, bnp.topY, boundaryPad, dsD.replace];  END;END;  -- of MoveBoundaryPadNbr --MoveThumbLineNbr: PROCEDURE [tlnp: ThumbLineNbrPtr, topY: ScreenYCoord,  nLines: CARDINAL] =-- Sets all Y position dependent parameters within a ThumbLineNbr data structure.BEGINtlnp.topY _ topY;tlnp.bottomY _ topY + nLines * dsD.lineHeight;tlnp.nLines _ nLines;IF nLines > 0 THEN  BEGIN  dsD.ClearRectangle    [inD.leftMargin, inD.rightMargin, topY, topY + nLines * dsD.lineHeight];  dsD.BlackenRectangle[tlnp.leftX, tlnp.rightX, tlnp.topY+5, tlnp.topY+7];  END;tlnp.exists _ FALSE;tlnp.startX _ tlnp.endX _ tlnp.selectionX _ tlnp.leftX;END;  -- of MoveThumbPadNbr --MoveTOCTextNbr: PROCEDURE [tnp: TOCTextNbrPtr, topY: ScreenYCoord,  nLines: CARDINAL] =-- Sets all y dependent values for a TOCTextNbr based on topY and nLines.  Increases or--   decreases the number of lines held on the line chain according to the number of lines--   held by the Nbr at entry and according to nLines.  Moves Bitmap area to new--   placement if necessary.BEGINoldNLines: CARDINAL _ tnp.nLines;oldTopY: ScreenYCoord _ tnp.topY;oldFirstLineOffScreen: LinePtr _ tnp.firstLineOffScreen;oldState: LineState _ oldFirstLineOffScreen.state;oldLinePair: LinePair _ oldFirstLineOffScreen.linePair;line: LinePtr;y: ScreenYCoord;toc: vmD.TOCHandle = tnp.toc;key: CARDINAL _ 0;holdLock: BOOLEAN _ FALSE;dsD.MoveFullWidthRectangleVertically  [top: oldTopY, bottom: oldTopY +dsD.lineHeight * MIN[oldNLines, nLines], newTop: topY];tnp.topY _ y _ topY;tnp.bottomY _ topY + nLines * dsD.lineHeight;tnp.nLines _ nLines;IF nLines >= oldNLines THEN  BEGIN  line _ oldFirstLineOffScreen;  line.nextLine _ intC.linePoolPtr;  THROUGH [1 .. nLines - oldNLines] DO    line _ line.nextLine;    line.state _ empty;    line.linePair _ oldLinePair;    ENDLOOP;  intC.linePoolPtr _ line.nextLine;  line.nextLine _ NIL;  tnp.firstLineOffScreen _ line;  ENDELSE BEGIN  line _ tnp.lines;  oldFirstLineOffScreen.nextLine _ intC.linePoolPtr;  THROUGH [1 .. nLines] DO    line _ line.nextLine;    ENDLOOP;  tnp.firstLineOffScreen _ line;  intC.linePoolPtr _ line.nextLine;  line.nextLine _ NIL;  END;y _ topY;FOR line _ tnp.lines, line.nextLine UNTIL line = NIL DO  line.y _ y;  y _ y + dsD.lineHeight;  ENDLOOP;IF intC.source.key # 0 THEN key _ intC.source.keyELSE IF toc#NIL THEN {key _ vmD.WaitForLock[toc]; holdLock _ TRUE};IF nLines > oldNLines THEN  BEGIN  dsD.ClearRectangle[inD.leftMargin, inD.rightMargin, topY + oldNLines * dsD.lineHeight,    topY + nLines * dsD.lineHeight];  IF oldState # empty THEN    DisplayTOCTail      [tnp, key, oldFirstLineOffScreen, oldLinePair.index, oldLinePair.lineNumber];  END;UpdateTOCThumbLine[tnp, key];IF holdLock THEN vmD.UnlockTOC[toc, key];END;  -- of MoveTOCTextNbr --MoveMessageTextNbr: PROCEDURE [mnp: MessageTextNbrPtr, topY: ScreenYCoord,  nLines: CARDINAL] =-- Sets all y dependent values for a MessageTextNbr based on topY and nLines.  Increases or--   decreases the number of lines held on the line chain according to the number of lines--   held by the Nbr at entry and according to nLines.  Moves Bitmap area to new--   placement if necessary.BEGINoldNLines: CARDINAL _ mnp.nLines;oldTopY: ScreenYCoord _ mnp.topY;oldFirstLineOffScreen: LinePtr _ mnp.firstLineOffScreen;oldState: LineState _ oldFirstLineOffScreen.state;oldFirstCharIndex: CharIndex _ oldFirstLineOffScreen.firstCharIndex;line: LinePtr;y: ScreenYCoord;dsD.MoveFullWidthRectangleVertically  [top: oldTopY, bottom: oldTopY +dsD.lineHeight * MIN[oldNLines, nLines], newTop: topY];mnp.topY _ y _ topY;mnp.bottomY _ topY + nLines * dsD.lineHeight;mnp.nLines _ nLines;IF nLines >= oldNLines THEN  BEGIN  line _ mnp.firstLineOffScreen;  line.nextLine _ intC.linePoolPtr;  THROUGH [1 .. nLines - oldNLines] DO    line _ line.nextLine;    line.state _ trailingBlankLine;    line.rightX  _ inD.leftMargin;    line.firstCharIndex _ oldFirstCharIndex;    ENDLOOP;  intC.linePoolPtr _ line.nextLine;  line.nextLine _ NIL;  mnp.firstLineOffScreen _ line;  ENDELSE BEGIN  line _ mnp.lines;  mnp.firstLineOffScreen.nextLine _ intC.linePoolPtr;  THROUGH [1 .. nLines] DO    line _ line.nextLine;    ENDLOOP;  mnp.firstLineOffScreen _ line;  intC.linePoolPtr _ line.nextLine;  line.nextLine _ NIL;  END;y _ topY;FOR line _ mnp.lines, line.nextLine UNTIL line = NIL DO  line.y _ y;  y _ y + dsD.lineHeight;  ENDLOOP;IF nLines > oldNLines THEN  BEGIN  dsD.ClearRectangle[inD.leftMargin, inD.rightMargin, topY + oldNLines * dsD.lineHeight,    topY + nLines * dsD.lineHeight];  IF oldState # trailingBlankLine THEN    Editor.RefreshSoThatFirstCharStartsLine[oldFirstCharIndex, oldFirstLineOffScreen, mnp];  END;END;  -- of MoveMessageTextNbr --ChangeCommandMenu: PUBLIC PROCEDURE  [cnp: CommandNbrPtr, region: RegionPtr, linesToKeep: CARDINAL] =-- The list of houses pointed to by cnp has changed.  linesToKeep is the number of line of--   the cnp that have not changed.  Changes the menu on screen to display all houses now--   in cnp's houses list.  Rearranges screen if necessary to accommodate changed command--   neighborhood height.BEGINnLines: CARDINAL _ 0;prevDCB: dsD.DCBptr;totalLinesForRegion: CARDINAL;oldNLines, nLinesNeeded, nLinesToGrab, deltaY, nLinesOfNextRegion: CARDINAL;h: HousePtr;-- First, find out how many lines the new command nbr will cover.FOR h _ cnp.houses, h.nextHouse UNTIL h = NIL DO  nLines _ MAX[nLines, h.lineNumber];  ENDLOOP;nLines _ nLines + 1;oldNLines _ cnp.nLines;IF nLines > oldNLines THEN  BEGIN  -- If next lower region doesn't have enough lines to spare, then adjust boundaries so  --   that it does.  nLinesNeeded _ nLines - oldNLines;  nLinesOfNextRegion _ region.nextRegion.nbrs.nLines;  IF nLinesOfNextRegion <= nLinesNeeded THEN    BEGIN    nLinesToGrab _ nLinesNeeded - nLinesOfNextRegion + 1;    deltaY _ nLinesToGrab * dsD.lineHeight;    SELECT region.regionType FROM      mailCommandRegion =>        MoveTOCDMBoundary          [bnp: intC.tocdmBoundaryPadNbr, y: intC.tocdmBoundaryPadNbr.topY + deltaY];      tocCommandRegion =>        IF intC.cmTextNbr.nLines > nLinesToGrab THEN          MoveDMCMBoundary            [bnp: intC.dmcmBoundaryPadNbr, y: intC.dmcmBoundaryPadNbr.topY + deltaY]        ELSE MoveTOCDMBoundary          [bnp: intC.tocdmBoundaryPadNbr, y: intC.tocdmBoundaryPadNbr.topY - deltaY];      cmCommandRegion =>        MoveDMCMBoundary          [bnp: intC.dmcmBoundaryPadNbr, y: intC.dmcmBoundaryPadNbr.topY - deltaY];      ENDCASE => ERROR;    END;  END;cnp.nLines _ linesToKeep;IF oldNLines = nLines THEN  {MoveCommandNbr[cnp: cnp, topY: cnp.topY, nLines: nLines]; RETURN};-- In the following cases, regions will change heights.  Since DCB's will be adjusted,--   patch in a dummy DCB to keep the screen tidy.disC.patchDCBPtr^ _ dsD.DCB  [next: region.nextRegion.nextRegion.dcb,  resolution: high,  background: intC.exceptionsRegion.dcb.background,  indenting: dsD.xOrigin / 16,  width: dsD.bmWidth,  bitmap: region.dcb.bitmap,  tag: region.dcb.tag,  height: region.dcb.height + region.nextRegion.dcb.height,  longBitmap: region.dcb.longBitmap];totalLinesForRegion _ nLines + 2;SELECT region.regionType FROM  mailCommandRegion => {prevDCB _ disC.firstDCB; totalLinesForRegion _ nLines + 1};  tocCommandRegion => prevDCB _ intC.TOCRegion.dcb;  cmCommandRegion => prevDCB _ intC.DMRegion.dcb;  ENDCASE => ERROR;prevDCB.next _ disC.patchDCBPtr;IF nLines > oldNLines THEN  -- command nbr will get bigger.  Take from next lower region.  BEGIN  MoveRegion[region.nextRegion, region.nextRegion.topY + nLinesNeeded * dsD.lineHeight,        region.nextRegion.nbrs.nLines - nLinesNeeded];  MoveRegion[region, region.topY, totalLinesForRegion];  ENDELSE  -- command nbr will get smaller.  Add to next lower region.  BEGIN  MoveRegion[region, region.topY, totalLinesForRegion];  MoveRegion    [region.nextRegion, region.bottomY, region.nextRegion.nbrs.nLines + oldNLines - nLines];  -- The next Region may have been 0 lines, thus its dcb was not linked in.  --   the following links it in in any case.  region.dcb.next _ region.nextRegion.dcb;  END;prevDCB.next _ region.dcb;IF cnp = intC.cmCommandNbr THEN  BEGIN  SELECT intC.editorMenuState FROM    singleLine => NULL;    getPut => lmD.ReleaseMenu[intC.getPutMenuSegment];    run => lmD.ReleaseMenu[intC.runMenuSegment];    find => lmD.ReleaseMenu[intC.findMenuSegment];    substitute => lmD.ReleaseMenu[intC.substituteMenuSegment];    copy => lmD.ReleaseMenu[intC.copyMenuSegment];    ENDCASE => exD.SysBug[];  intC.editorMenuState _ singleLine;  END;IF bitmapNotifyProc # NIL THEN bitmapNotifyProc[];END;  -- of ChangeCommandMenu --NullCommand: PUBLIC PROCEDURE [hp: POINTER, confirmed: BOOLEAN] =-- Does nothing.  Purely a placeholder for information houses and boundaryLine--   neighborhoods.BEGINEND;  -- of NullCommand --DestroyDM: PUBLIC PROCEDURE =-- Clears the displayed message area on the Laurel screen and makes Laurel--   believe that no displayed message exists.BEGINdm: MessageTextNbrPtr _ intC.dmTextNbr;dm.haveMessage _ FALSE;dsD.ClearRectangle[leftMargin, rightMargin, dm.topY, dm.bottomY];END;  -- of DestroyDM --DestroyTOC: PUBLIC PROCEDURE =-- Clears the table of contents area on the Laurel screen and makes Laurel--   believe that no table of contents exists.BEGINtnp: TOCTextNbrPtr _ intC.tocTextNbr;dsD.ClearRectangle[leftMargin, rightMargin, tnp.topY, tnp.bottomY];END;  -- of DestroyTOC --DMBitmapLocation: PUBLIC PROCEDURE RETURNS  [base: LONG POINTER, wordsPerLine, bitsX, bitsY: CARDINAL] =-- Returns the location of the bitmap in the displayed message area of the--   Laurel screen.BEGINdmDcb: dsD.DCBptr _ intC.DMRegion.dcb;RETURN[dmDcb.longBitmap, dsD.bmWidth, dsD.bmWidth * 16,  dmDcb.height * 2];END;  -- of DMBitmapLocation --TOCBitmapLocation: PUBLIC PROCEDURE RETURNS  [base: LONG POINTER, wordsPerLine, bitsX, bitsY: CARDINAL] =-- Returns the location of the bitmap in the table of contents area of the--   Laurel screen.BEGINtocDcb: dsD.DCBptr _ intC.TOCRegion.dcb;RETURN[tocDcb.longBitmap, dsD.bmWidth, dsD.bmWidth * 16,  tocDcb.height * 2];END;  -- of TOCBitmapLocation --SetBitmapNotifyProc: PUBLIC PROCEDURE [p: LaurelBitmapDefs.BitmapNotifyProc] =  {bitmapNotifyProc _ p};END.  -- of IntBoundaryCom --z20461(529)\f1