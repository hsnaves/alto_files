-- file:  InitInteractor-- edited by Brotz, August 31, 1982  10:39 AM-- edited by Levin, April 14, 1981  3:41 PM-- edited by Schroeder, Wednesday Nov. 5, 1980 2:59 pm PST-- edited by Taft, May 10, 1983  6:11 PMDIRECTORY  AltoDefs USING [PageSize],  ccD: FROM "ChollaCmdDefs" USING [BBoardCommand],  displayCommon USING [firstDCB, patchDCBPtr],  DMSTimeDefs USING [timeStringLength],  drD: FROM "LaurelDriverDefs" USING [videoBackground],  dsD: FROM "DisplayDefs" USING [DCB, DCBnil, DCBptr, GetPictureParameters,    GetStringWidth, lineHeight, ScreenXCoord, ScreenYCoord],  exD: FROM "ExceptionDefs" USING [SysBug],  inD: FROM "InteractorDefs" USING [AnswerCommand, BoundaryLineNbrTracker,    BoundaryPadNbrPtr, BoundaryPadNbrTracker, BracketsHouseRefresher,    CommandProcedure, CommandTracker, CopyCommand, DeleteCommand,    DisplayMessageCommand, ExceptionsTracker, FindCommand, ForwardCommand,    GetCommand, GetMailFileCommand, GetNewMailCommand, HardcopyCancelCommand,    HardcopyCommand, HardcopyConfirmCommand, House, HouseFixedEdgeType, HousePtr,    leftMargin, Line, LinePair, LinePtr, LoginCommand, maxBracketStringLength,    MoveDMCMBoundary, MoveMessageToFileCommand, MoveTOCDMBoundary, Nbr,    NbrPtr, NewFormCommand, NullCommand, PutCommand, QuitCommand, Region,    RegionPtr, RegionType, rightMargin, RunCommand, ScreenXCoord, ScreenYCoord,    SendCommand, SetCopiesCommand, SetDuplexCommand, SetOverrideFormCommand,    SetPasswordProtectedCommand, SetPrinterCommand, ShortenEditorMenuCommand,    SubstituteCommand, TextHouseRefresher, TextNbrTracker, ThumbLineNbrPtr,    ThumbLineNbrTracker, ThumbMessageNbr, ThumbTOC, TOCTracker, UndeleteCommand],  Inline USING [BITAND, COPY],  intCommon USING [answerCommandHouse, bboardCommandHouse, cmCommandNbr,    CMCommandRegion, CMRegion, cmTextNbr, cmThumbLineNbr, copyCommandHouse,    copyMenuSegment, deleteCommandHouse, deliverCommandHouse, disableWriting,    displayCommandHouse, dmcmBoundaryPadNbr, DMRegion, dmTextNbr,    dmThumbLineNbr, exceptionsRegion, findMenuSegment, forwardCommandHouse,    freePagesHouse, getCommandHouse, getPutMenuSegment, gvTestingMode,    hardcopyCommandHouse, hardcopyMenuSegment, isCholla, linePoolPtr, mailCommandNbr,    mailCommandRegion, mailFileBracketsHouse, mailFileCommandHouse,    moveToBracketsHouse, moveToCommandHouse, newFormCommandHouse,    newMailCommandHouse, newMessagesHouse, numScanLines, putCommandHouse,    quitCommandHouse, regions, runCommandHouse, runMenuSegment, substituteMenuSegment,    timeHouse, tocCommandNbr, TOCCommandRegion, tocdmBoundaryPadNbr, TOCRegion,    tocTextNbr, tocThumbLineNbr, undeleteCommandHouse, userBracketsHouse,    userCommandHouse, versionHouse],  lsD: FROM "LaurelStateDefs" USING [AllocateStateNode, AllocateStateString,    DefineStateSegment, PageCount, ReleaseStateSegment, StateSegment, SwapInStateSegment,    WriteStateSegment],  ovD: FROM "OverviewDefs" USING [GetVersionString],  String USING [AppendString, WordsForString];InitInteractor: PROGRAM   IMPORTS ccD, disC: displayCommon, drD, dsD, exD, inD, Inline, intC: intCommon, lsD,    ovD, String  EXPORTS inD =BEGINOPEN inD, lsD;-- Global constants --commandIndent: CARDINAL = 0;interCommandSpacing: CARDINAL = 15;preBracketSpacing: CARDINAL = 7;maxCommandString: CARDINAL = 30;endOfMessageString: STRING;HouseType: TYPE = {command, brackets, text};BuildScreenStructures: PUBLIC PROCEDURE =-- Builds all data structures that support the display.  All constant fields will be filled in;--   actual x,y screen coordinates will not.-- Side effects: intCommon region and house pointers are filled in.  DisplayCommon firstDCB--   is filled in to point to a spacer DCB, which in turn is linked to all other DCB's.BEGIN-- Call each region builder in turn, linking the regions and their DCB's in a chain.rp: RegionPtr;dcbPtr: dsD.DCBptr;s: STRING _ "End of Message."L;endOfMessageString _ lsD.AllocateStateString[s.length];String.AppendString[endOfMessageString, s];intC.linePoolPtr _ AllocateLinePool[];disC.firstDCB _ dcbPtr _ NewDCB[];rp _ intC.regions _ InitMailCommandRegion[];dcbPtr _ dcbPtr.next _ rp.dcb;rp _ rp.nextRegion _ InitTOCRegion[];dcbPtr _ dcbPtr.next _ rp.dcb;rp _ rp.nextRegion _ InitTOCCommandRegion[];dcbPtr _ dcbPtr.next _ rp.dcb;rp _ rp.nextRegion _ InitDMRegion[];dcbPtr _ dcbPtr.next _ rp.dcb;rp _ rp.nextRegion _ InitCMCommandRegion[];dcbPtr _ dcbPtr.next _ rp.dcb;rp _ rp.nextRegion _ InitCMRegion[];dcbPtr _ dcbPtr.next _ rp.dcb;rp _ rp.nextRegion _ InitExceptionsRegion[];dcbPtr _ dcbPtr.next _ rp.dcb;disC.patchDCBPtr _ NewDCB[];BuildSwappableMenus[];END;  -- of BuildScreenStructures --InitMailCommandRegion: PROCEDURE RETURNS [rp: RegionPtr] =-- Allocates and partially fills in the mailCommandRegion.BEGINnp: NbrPtr _ intC.mailCommandNbr _ LOOPHOLE[InitMailCommandNbr[]];np.nextNbr _ InitTOCThumbLineNbr[];intC.mailCommandRegion _ rp _ MakeRegion[mailCommandRegion, np];END;  -- of InitMailCommandRegion --InitTOCRegion: PROCEDURE RETURNS [rp: RegionPtr] =-- Allocates and partially fills in the TOCRegion.BEGINnp: NbrPtr _ InitTOCTextNbr[];intC.tocThumbLineNbr.np _ np;intC.TOCRegion _ rp _ MakeRegion[tocRegion, np];END;  -- of InitTOCRegion --InitTOCCommandRegion: PROCEDURE RETURNS [rp: RegionPtr] =-- Allocates and partially fills in the TOCCommandRegion.BEGINnp: NbrPtr _ MakeBoundaryLineNbr[rightMargin - 16];np.nextNbr _ InitTOCDMBoundaryPadNbr[];np.nextNbr.nextNbr _ intC.tocCommandNbr _ LOOPHOLE[InitTOCCommandNbr[]];np.nextNbr.nextNbr.nextNbr _ InitDMThumbLineNbr[];intC.TOCCommandRegion _ rp _ MakeRegion[tocCommandRegion, np];END;  -- of InitTOCCommandRegion --InitDMRegion: PROCEDURE RETURNS [rp: RegionPtr] =-- Allocates and partially fills in the DMRegion.BEGINnp: NbrPtr _ InitDMTextNbr[];intC.dmThumbLineNbr.np _ np;intC.DMRegion _ rp _ MakeRegion[dmRegion, np];END;  -- of InitDMRegion --InitCMCommandRegion: PROCEDURE RETURNS [rp: RegionPtr] =-- Allocates and partially fills in the CMCommandRegion.BEGINnp: NbrPtr _ MakeBoundaryLineNbr[rightMargin - 16];np.nextNbr _ InitDMCMBoundaryPadNbr[];np.nextNbr.nextNbr _ intC.cmCommandNbr _ LOOPHOLE[InitCMCommandNbr[]];np.nextNbr.nextNbr.nextNbr _ InitCMThumbLineNbr[];intC.CMCommandRegion _ rp _ MakeRegion[cmCommandRegion, np];END;  -- of InitCMCommandRegion --InitCMRegion: PROCEDURE RETURNS [rp: RegionPtr] =-- Allocates and partially fills in the CMRegion.BEGINnp: NbrPtr _ InitCMTextNbr[];intC.cmThumbLineNbr.np _ np;intC.CMRegion _ rp _ MakeRegion[cmRegion, np];END;  -- of InitCMRegion --InitExceptionsRegion: PROCEDURE RETURNS [rp: RegionPtr] =-- Allocates and partially fills in the ExceptionsRegion.BEGINnp: NbrPtr _ MakeBoundaryLineNbr[rightMargin];np.nextNbr _ InitExceptionsNbr[];intC.exceptionsRegion _ rp _ MakeRegion[exceptionsRegion, np];END;  -- of InitExceptionsRegion --MakeRegion: PROCEDURE [regionType: RegionType, nbrs: NbrPtr]  RETURNS [rp: RegionPtr] =BEGINrp _ AllocateStateNode[SIZE[Region]];rp^ _ Region  [nextRegion: NIL, dcb: NewDCB[], regionType: regionType, topY: 0, bottomY: 0,  cursorShape: charArrow, nbrs: nbrs];END;  -- of MakeRegion --MakeBoundaryLineNbr: PROCEDURE [right: dsD.ScreenXCoord] RETURNS [np: NbrPtr] =-- Allocates and partially fills in a BoundaryLineNbr.BEGINnp _ AllocateStateNode[SIZE[boundaryLine Nbr]];np^ _ Nbr  [nextNbr: NIL,  nLines: 0,  topY: 0,  bottomY: 0,  leftX: leftMargin,  rightX: right,  cursorShape: charArrow,  nbrVariant: boundaryLine[nbrTracker: BoundaryLineNbrTracker]];END;  -- of MakeBoundaryLineNbr --InitTOCDMBoundaryPadNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in a BoundaryPadNbr.BEGINnp _ intC.tocdmBoundaryPadNbr _ MakeBoundaryPadNbr[MoveTOCDMBoundary];END;  -- of InitTOCDMBoundaryPadNbr --InitDMCMBoundaryPadNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in a BoundaryPadNbr.BEGINnp _ intC.dmcmBoundaryPadNbr _ MakeBoundaryPadNbr[MoveDMCMBoundary];END;  -- of InitDMCMBoundaryPadNbr --MakeBoundaryPadNbr: PROCEDURE    [command: PROCEDURE [BoundaryPadNbrPtr, ScreenYCoord]]  RETURNS [np: BoundaryPadNbrPtr] =BEGINnp _ AllocateStateNode[SIZE[boundaryPad Nbr]];np^ _ Nbr  [nextNbr: NIL,  nLines: 0,  topY: 0,  bottomY: 0,  leftX: rightMargin - 16,  rightX: rightMargin,  cursorShape: charArrow,  nbrVariant: boundaryPad[command: command, nbrTracker: BoundaryPadNbrTracker]];END;  -- of MakeBoundaryPadNbr --InitTOCThumbLineNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in a BoundaryLineNbr.BEGINnp _ intC.tocThumbLineNbr _ MakeThumbLineNbr[ThumbTOC, 4];END;  -- of InitTOCThumbLineNbr --InitDMThumbLineNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in a BoundaryLineNbr.BEGINnp _ intC.dmThumbLineNbr _ MakeThumbLineNbr[ThumbMessageNbr];END;  -- of InitDMThumbPadNbr --InitCMThumbLineNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in a BoundaryLineNbr.BEGINnp _ intC.cmThumbLineNbr _ MakeThumbLineNbr[ThumbMessageNbr];END;  -- of InitCMThumbPadNbr --MakeThumbLineNbr: PROCEDURE    [command: PROCEDURE [ThumbLineNbrPtr, NbrPtr, ScreenXCoord], x: CARDINAL _ 0]  RETURNS [np: ThumbLineNbrPtr] =BEGINnp _ AllocateStateNode[SIZE[thumbLine Nbr]];np^ _ Nbr  [nextNbr: NIL, nLines: 0, topY: 0, bottomY: 0, leftX: leftMargin, rightX: rightMargin - 2,  cursorShape: charArrow,  nbrVariant: thumbLine[exists: FALSE, length: 0, start: 0, end: 0, selection: 0,    startX: leftMargin + x, endX: leftMargin + x, selectionX: leftMargin + x,    np: NIL, command: command, nbrTracker: ThumbLineNbrTracker]];END;  -- of MakeThumbLineNbr --InitMailCommandNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in the MailCommandNbr.BEGINh, hp: HousePtr;houseLeftX, houseRightX: dsD.ScreenXCoord;commandString, versionString, freeDiskPages: STRING;testingModeString: STRING _ " GV Test Mode"L;versionString _ ovD.GetVersionString[];commandString _ AllocateStateString  [versionString.length  + (IF intC.isCholla THEN 8 ELSE 10)  + (IF intC.gvTestingMode THEN testingModeString.length ELSE 0)];String.AppendString[commandString, IF intC.isCholla THEN "Cholla 1"L ELSE "Laurel 6.1"L];String.AppendString[commandString, versionString];IF intC.gvTestingMode THEN String.AppendString[commandString, testingModeString];houseLeftX _ leftMargin;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, plainFace];hp _ h _ intC.versionHouse _  MakeHouse[houseType: text, leftX: houseLeftX, rightX: houseRightX, text: commandString];-- timeHousehouseRightX _ rightMargin;houseLeftX _ houseRightX;h _ h.nextHouse _ intC.timeHouse _  MakeHouse[houseType: text, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[DMSTimeDefs.timeStringLength], fixedEdge: right];commandString _ AllocateStateString[40];  -- length of "You have new mail."commandString.length _ 0;houseLeftX _ leftMargin;houseRightX _ houseLeftX;h _ h.nextHouse _ intC.newMessagesHouse _  MakeHouse[houseType: text, leftX: houseLeftX, rightX: houseRightX,    text: commandString, lineNumber: 1];IF intC.isCholla THEN  BEGIN  commandString _ "BBoard"L;  houseLeftX _ 280;  houseRightX _ houseLeftX  + dsD.GetStringWidth[commandString, boldFace];  h _ h.nextHouse _ intC.bboardCommandHouse _    MakeHouse[houseType: command, leftX: houseLeftX, rightX: houseRightX,      text: AllocateStateString[commandString.length], lineNumber: 1,      command: ccD.BBoardCommand];  String.AppendString[h.text, commandString];  END;-- free pages housefreeDiskPages _ " free disk pages"L;commandString _ AllocateStateString[5];  -- length of "99999"String.AppendString[commandString, "     "L];houseRightX _ rightMargin - dsD.GetStringWidth[freeDiskPages, plainFace];houseLeftX _ houseRightX;h _ h.nextHouse _ intC.freePagesHouse _  MakeHouse[houseType: text, leftX: houseLeftX, rightX: houseRightX,    text: commandString, lineNumber: 1, fixedEdge: right];-- free pages constant text housecommandString _ AllocateStateString[freeDiskPages.length];String.AppendString[commandString, freeDiskPages];h _ h.nextHouse _   MakeHouse[houseType: text, leftX: rightMargin, rightX: rightMargin,    text: commandString, lineNumber: 1, fixedEdge: right];commandString _ "User"L;houseLeftX _ leftMargin + commandIndent;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];h _ h.nextHouse _ intC.userCommandHouse _  MakeHouse[houseType: command, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[commandString.length], lineNumber: 2,    confirm: TRUE, command: LoginCommand];String.AppendString[h.text, commandString];houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];intC.userBracketsHouse _ h _ h.nextHouse _  MakeHouse[houseType: brackets, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[maxBracketStringLength], lineNumber: 2];commandString _ "New mail"L;houseLeftX _ leftMargin + 165;houseRightX _ houseLeftX  + dsD.GetStringWidth[commandString, boldFace];h _ h.nextHouse _ intC.newMailCommandHouse _  MakeHouse[houseType: command, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[commandString.length], lineNumber: 2, confirm: TRUE,    command: GetNewMailCommand];String.AppendString[h.text, commandString];commandString _ "Mail file"L;houseLeftX _ houseRightX + interCommandSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];h _ h.nextHouse _ intC.mailFileCommandHouse _  MakeHouse[houseType: command, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[commandString.length], lineNumber: 2,    confirm: TRUE, command: GetMailFileCommand];String.AppendString[h.text, commandString];houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];intC.mailFileBracketsHouse _ h _ h.nextHouse _  MakeHouse[houseType: brackets, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[maxBracketStringLength], lineNumber: 2,    confirm: TRUE];commandString _ "Quit"L;houseRightX _ rightMargin;houseLeftX _ houseRightX - dsD.GetStringWidth[commandString, boldFace];h _ h.nextHouse _ intC.quitCommandHouse _  MakeHouse[houseType: command, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[commandString.length], lineNumber: 2,    confirm: TRUE, command: QuitCommand];String.AppendString[h.text, commandString];np _ MakeCommandNbr[hp];END;  -- of InitMailCommandNbr --MakeHouse: PROCEDURE    [houseType: HouseType, leftX, rightX: ScreenXCoord, text: STRING,    lineNumber: CARDINAL _ 0, fixedEdge: HouseFixedEdgeType _ left,    confirm: BOOLEAN _ FALSE, indicDone: BOOLEAN _ TRUE,    usePicture: BOOLEAN _ FALSE, command: CommandProcedure _ NullCommand]  RETURNS [hp: HousePtr] =BEGINhp _ AllocateStateNode[SIZE[House]];hp^ _ House  [nextHouse: NIL,  lineNumber: lineNumber,  topY: 0,  bottomY: 0,  leftX: leftX,  rightX: rightX,  text: text,  fixedEdge: fixedEdge,  typeface: IF houseType = command THEN boldFace ELSE plainFace,  needsConfirmation: confirm,  trackerIndicateDone: indicDone,  callable: houseType = command,  command: command,  houseRefresher: IF houseType = brackets THEN BracketsHouseRefresher    ELSE TextHouseRefresher];END;  -- of MakeHouse --MakeCommandNbr: PROCEDURE [houses: HousePtr] RETURNS [np: NbrPtr] =BEGINnp _ AllocateStateNode[SIZE[command Nbr]];np^ _ Nbr  [nextNbr: NIL, nLines: 0, topY: 0, bottomY: 0, leftX: leftMargin, rightX: rightMargin,  cursorShape: charArrow,  nbrVariant: command[houses: houses, nbrTracker: CommandTracker]];END;  -- of MakeCommandNbr --InitTOCTextNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in the TOCTextNbr.BEGINline: LinePtr _ intC.linePoolPtr;intC.linePoolPtr _ line.nextLine;np _ intC.tocTextNbr _ AllocateStateNode[SIZE[tocText Nbr]];np^ _ Nbr  [nextNbr: NIL,  nLines: 0,  topY: 0,  bottomY: 0,  leftX: 0,  rightX: rightMargin,  cursorShape: lineArrow,  nbrVariant: tocText    [lines: line,    firstLineOffScreen: line,    toc: NIL,    displayFormatted: TRUE,    haveToc: FALSE,    nbrTracker: TOCTracker]];line.nextLine _ NIL;line.y _ 0;line.state _ empty;line.linePair _ LinePair[0, 0];END;  -- of InitTOCTextNbr --InitTOCCommandNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in the DMCommandNbr.BEGINh, hp: HousePtr;houseLeftX, houseRightX: ScreenXCoord;commandString: STRING _ [maxCommandString];commandString _ "Display"L;houseLeftX _  leftMargin + commandIndent;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];hp _ h _ intC.displayCommandHouse _  MakeHouse[houseType: command, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[commandString.length],    command: DisplayMessageCommand];String.AppendString[h.text, commandString];commandString _ "Delete"L;houseLeftX _ houseRightX + interCommandSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];h _ h.nextHouse _ intC.deleteCommandHouse _  MakeHouse[houseType: command, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[commandString.length],    command: DeleteCommand];String.AppendString[h.text, commandString];commandString _ "Undelete"L;houseLeftX _ houseRightX + interCommandSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];h _ h.nextHouse _ intC.undeleteCommandHouse _  MakeHouse[houseType: command, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[commandString.length],    command: UndeleteCommand];String.AppendString[h.text, commandString];IF intC.disableWriting THEN	BEGIN	commandString _ ""L;	houseLeftX _ houseRightX;	ENDELSE BEGIN	commandString _  "Move to"L;	houseLeftX _ houseRightX + interCommandSpacing;	houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];	END;h _ h.nextHouse _ intC.moveToCommandHouse _   MakeHouse[houseType: command, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[commandString.length],    confirm: TRUE, command: MoveMessageToFileCommand];String.AppendString[h.text, commandString];IF intC.disableWriting THEN  {commandString _ NIL; houseLeftX _ houseRightX}ELSE BEGIN  houseLeftX _ houseRightX + preBracketSpacing;  houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];  commandString _ AllocateStateString[maxBracketStringLength];  END;intC.moveToBracketsHouse _ h _ h.nextHouse _  MakeHouse[houseType: brackets, leftX: houseLeftX, rightX: houseRightX,    text: IF intC.disableWriting THEN NIL ELSE AllocateStateString[maxBracketStringLength],    confirm: TRUE];IF intC.disableWriting THEN h.houseRefresher _ TextHouseRefresher;houseRightX _ rightMargin;IF intC.disableWriting THEN {commandString _ ""L; houseLeftX _ houseRightX}ELSE BEGIN  commandString _  "Hardcopy"L;  houseLeftX _ houseRightX - dsD.GetStringWidth[commandString, boldFace];  END;intC.hardcopyCommandHouse _ h _ h.nextHouse _   MakeHouse[houseType: command, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[commandString.length],    confirm: TRUE, indicDone: FALSE, command: HardcopyCommand];String.AppendString[h.text, commandString];np _ MakeCommandNbr[hp];END;  -- of InitTOCCommandNbr --InitDMTextNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in the DMTextNbr.BEGINline: LinePtr _ intC.linePoolPtr;intC.linePoolPtr _ line.nextLine;np _ intC.dmTextNbr _ AllocateStateNode[SIZE[messageText Nbr]];np^ _ Nbr  [nextNbr: NIL,  nLines: 0,  topY: 0,  bottomY: 0,  leftX: 0,  rightX:  rightMargin,  cursorShape: charArrow,  nbrVariant: messageText    [haveMessage: FALSE,    editable: FALSE,    lines: line,    firstLineOffScreen: line,    message: NIL,    protectedFieldPtr: NIL,    insertionBuffer: NIL,    deletionBuffer: NIL,    endString: endOfMessageString,    nbrTracker: TextNbrTracker]];line.nextLine _ NIL;line.y _ 0;line.state _ trailingBlankLine;line.rightX _  leftMargin;line.firstCharIndex _ 0;END;  -- of InitDMTextNbr --InitCMCommandNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in the CMCommandNbr.BEGINh, hp: HousePtr;houseLeftX, houseRightX: dsD.ScreenXCoord;commandString: STRING _ [maxCommandString];commandString _ "New form"L;houseLeftX _  leftMargin + commandIndent;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];hp _ h _ intC.newFormCommandHouse _  MakeHouse[houseType: command, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[commandString.length],    confirm: TRUE, command: NewFormCommand];String.AppendString[h.text, commandString];commandString _ "Answer"L;houseLeftX _ houseRightX + interCommandSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];h _ h.nextHouse _ intC.answerCommandHouse _  MakeHouse[houseType: command, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[commandString.length],    confirm: TRUE, command: AnswerCommand];String.AppendString[h.text, commandString];commandString _ "Forward"L;houseLeftX _ houseRightX + interCommandSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];h _ h.nextHouse _ intC.forwardCommandHouse _  MakeHouse[houseType: command, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[commandString.length],    confirm: TRUE, command: ForwardCommand];String.AppendString[h.text, commandString];commandString _ "Get"L;houseLeftX _ houseRightX + interCommandSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];intC.getCommandHouse _ h _ h.nextHouse _  MakeHouse[houseType: command, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[commandString.length],    confirm: TRUE, command: GetCommand];String.AppendString[h.text, commandString];IF intC.disableWriting THEN {commandString _ ""L; houseLeftX _ houseRightX}ELSE BEGIN	commandString _  "Put"L;	houseLeftX _ houseRightX + interCommandSpacing;	houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];	END;h _ h.nextHouse _ intC.putCommandHouse _  MakeHouse[houseType: command, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[commandString.length],    confirm: TRUE, command: PutCommand];String.AppendString[h.text, commandString];commandString _ "Copy"L;houseLeftX _ houseRightX + interCommandSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];intC.copyCommandHouse _ h _ h.nextHouse _  MakeHouse[houseType: command, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[commandString.length],    confirm: TRUE, command: CopyCommand];String.AppendString[h.text, commandString];commandString _ "Run"L;houseLeftX _ houseRightX + interCommandSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth[commandString, boldFace];h _ h.nextHouse _ intC.runCommandHouse _  MakeHouse[houseType: command, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[commandString.length],    confirm: TRUE, indicDone: FALSE, command: RunCommand];String.AppendString[h.text, commandString];commandString _ "delivered"L;houseRightX _  rightMargin;houseLeftX _ houseRightX - dsD.GetStringWidth[commandString, italicFace];h _ h.nextHouse _ intC.deliverCommandHouse _  MakeHouse[houseType: text, leftX: houseLeftX, rightX: houseRightX,    text: AllocateStateString[commandString.length], fixedEdge: right,    confirm: TRUE, command: SendCommand];h.typeface _ italicFace;np _ MakeCommandNbr[hp];END;  -- of InitCMCommandNbr --InitCMTextNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in the CMTextNbr.BEGINline: LinePtr _ intC.linePoolPtr;intC.linePoolPtr _ line.nextLine;np _ intC.cmTextNbr _ AllocateStateNode[SIZE[messageText Nbr]];np^ _ Nbr  [nextNbr: NIL,  nLines: 0,  topY: 0,  bottomY: 0,  leftX: 0,  rightX:  rightMargin,  cursorShape: charArrow,  nbrVariant: messageText  [haveMessage: TRUE,  editable: TRUE,  lines: line,  firstLineOffScreen: line,  message: NIL,  protectedFieldPtr: NIL,  insertionBuffer: NIL,  deletionBuffer: NIL,  endString: endOfMessageString,  nbrTracker: TextNbrTracker]];line.nextLine _ NIL;line.y _ 0;line.state _ endOfMessage;line.rightX _  leftMargin;line.firstCharIndex _ 0;END;  -- of InitCMTextNbr --InitExceptionsNbr: PROCEDURE RETURNS [np: NbrPtr] =-- Allocates and partially fills in the ExceptionsNbr.BEGINline: LinePtr _ intC.linePoolPtr;intC.linePoolPtr _ line.nextLine;np _ AllocateStateNode[SIZE[messageText Nbr]];np^ _ Nbr  [nextNbr: NIL,  nLines: 0,  topY: 0,  bottomY: 0,  leftX:  leftMargin,  rightX:  rightMargin,  cursorShape: charArrow,  nbrVariant: messageText    [haveMessage: FALSE,    editable: FALSE,    lines: line,    firstLineOffScreen: line,    message: NIL,    protectedFieldPtr: NIL,    insertionBuffer: NIL,    deletionBuffer: NIL,    endString: NIL,    nbrTracker: ExceptionsTracker]];line.nextLine _ NIL;line.y _ 0;line.state _ trailingBlankLine;line.rightX _  leftMargin;line.firstCharIndex _ 0;END;  -- of InitExceptionsNbr --BuildSwappableMenus: PROCEDURE =BEGINhouse: House;houseLeftX, houseRightX: ScreenXCoord;currentString: STRING;bracketString: STRING _ [maxBracketStringLength];base: POINTER;nextSlot, segmentLimit: CARDINAL;currentSegment: lsD.StateSegment;InitSegment: PROCEDURE [seg: POINTER TO lsD.StateSegment, nPages: lsD.PageCount] =	BEGIN	seg^ _ currentSegment _ lsD.DefineStateSegment[nPages];	base _ lsD.SwapInStateSegment[currentSegment];	nextSlot _ 0;	segmentLimit _ nPages * AltoDefs.PageSize;	END;  -- of MakeSegment --AddToSegment: PROCEDURE =	-- adds contents of house and s to the current segment;	BEGIN	IF nextSlot + SIZE[House] > segmentLimit THEN exD.SysBug[];	Inline.COPY[from: @house, nwords: SIZE[House], to: base + nextSlot];	nextSlot _ nextSlot + SIZE[House];	IF nextSlot + String.WordsForString[currentString.maxlength] > segmentLimit		THEN exD.SysBug[];	Inline.COPY[from: currentString,							nwords: String.WordsForString[currentString.maxlength],							to: base + nextSlot];	nextSlot _ nextSlot + String.WordsForString[currentString.maxlength];	END;  -- of AddToSegment --FinishSegment: PROCEDURE =	BEGIN	lsD.WriteStateSegment[currentSegment];	lsD.ReleaseStateSegment[currentSegment];	END;  -- of FinishSegment --InitSegment[@intC.hardcopyMenuSegment, 1];currentString _ "Printer"L;houseLeftX _ leftMargin;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: FALSE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: SetPrinterCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ bracketString;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ "Form"L;houseLeftX _  leftMargin + 260;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: FALSE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: SetOverrideFormCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ bracketString;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ "Hardcopy"L;houseLeftX _  intC.hardcopyCommandHouse.leftX;houseRightX _ rightMargin;house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 0,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: FALSE,	callable: TRUE,	command: HardcopyConfirmCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ "Copies"L;houseLeftX _ leftMargin;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: FALSE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: SetCopiesCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ "99"L;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ "Two sided"L;houseLeftX _  leftMargin + 110;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: FALSE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: SetDuplexCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ "Yes"L;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[3],  -- length of "Yes" --	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ "Private"L;houseLeftX _ leftMargin + 260;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: FALSE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: SetPasswordProtectedCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ "Yes"L;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: AllocateStateString[3],  -- length of "Yes" --	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ "Cancel"L;houseRightX _  rightMargin;houseLeftX _ houseRightX - dsD.GetStringWidth[currentString, boldFace];house _ House	[nextHouse: LOOPHOLE[0],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: FALSE,	callable: TRUE,	command: HardcopyCancelCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];FinishSegment[];InitSegment[@intC.getPutMenuSegment, 1];currentString _ "File name"L;houseLeftX _  leftMargin;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, italicFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: italicFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ bracketString;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ ""L;houseRightX _  rightMargin;houseLeftX _  rightMargin - dsD.GetPictureParameters[resetMenuIcon].width;house _ House	[nextHouse: LOOPHOLE[0],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	picture: resetMenuIcon,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: FALSE,	callable: TRUE,	usePicture: TRUE,	command: ShortenEditorMenuCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];FinishSegment[];InitSegment[@intC.runMenuSegment, 1];currentString _ "Program"L;houseLeftX _  leftMargin;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, italicFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: italicFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ bracketString;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ ""L;houseRightX _  rightMargin;houseLeftX _  rightMargin - dsD.GetPictureParameters[resetMenuIcon].width;house _ House	[nextHouse: LOOPHOLE[0],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	picture: resetMenuIcon,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: FALSE,	callable: TRUE,	usePicture: TRUE,	command: ShortenEditorMenuCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];FinishSegment[];InitSegment[@intC.copyMenuSegment, 1];currentString _ "from"L;houseLeftX _  leftMargin;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, italicFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: italicFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ bracketString;houseLeftX _ houseRightX + 2;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ "to"L;houseLeftX _  leftMargin + 240;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, italicFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: italicFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ bracketString;houseLeftX _ houseRightX + 2;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ ""L;houseRightX _  rightMargin;houseLeftX _  rightMargin - dsD.GetPictureParameters[resetMenuIcon].width;house _ House	[nextHouse: LOOPHOLE[0],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	picture: resetMenuIcon,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: FALSE,	callable: TRUE,	usePicture: TRUE,	command: ShortenEditorMenuCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];FinishSegment[];InitSegment[@intC.findMenuSegment, 1];currentString _ "Find"L;houseLeftX _  leftMargin;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: FindCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ bracketString;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ ""L;houseRightX _  rightMargin;houseLeftX _  rightMargin - dsD.GetPictureParameters[resetMenuIcon].width;house _ House	[nextHouse: LOOPHOLE[0],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	picture: resetMenuIcon,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: FALSE,	callable: TRUE,	usePicture: TRUE,	command: ShortenEditorMenuCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];FinishSegment[];InitSegment[@intC.substituteMenuSegment, 1];currentString _ "Substitute"L;houseLeftX _  leftMargin;houseRightX _ houseLeftX  + dsD.GetStringWidth[currentString, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: TRUE,	callable: TRUE,	command: SubstituteCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ bracketString;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ " for"L;houseLeftX _  leftMargin + 210;houseRightX _ houseLeftX + dsD.GetStringWidth[currentString, italicFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: italicFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: FindCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];currentString _ bracketString;houseLeftX _ houseRightX + preBracketSpacing;houseRightX _ houseLeftX + dsD.GetStringWidth["{}"L, boldFace];house _ House	[nextHouse: LOOPHOLE[1],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	fixedEdge: left,	typeface: plainFace,	needsConfirmation: FALSE,	trackerIndicateDone: FALSE,	callable: FALSE,	command: NullCommand,	houseRefresher: BracketsHouseRefresher];AddToSegment[];currentString _ ""L;houseRightX _  rightMargin;houseLeftX _  rightMargin - dsD.GetPictureParameters[resetMenuIcon].width;house _ House	[nextHouse: LOOPHOLE[0],	lineNumber: 1,	topY: 0,	bottomY: 0,	leftX: houseLeftX,	rightX: houseRightX,	text: NIL,	picture: resetMenuIcon,	fixedEdge: left,	typeface: boldFace,	needsConfirmation: TRUE,	trackerIndicateDone: FALSE,	callable: TRUE,	usePicture: TRUE,	command: ShortenEditorMenuCommand,	houseRefresher: TextHouseRefresher];AddToSegment[];FinishSegment[];END;  -- of BuildSwappableMenus --NewDCB: PROCEDURE RETURNS [dcbPtr: dsD.DCBptr] =-- Returns  a pointer to a newly allocated blank DCB.BEGINdcbPtr _ Even[SIZE[dsD.DCB]];dcbPtr^ _ dsD.DCB	[next: dsD.DCBnil,	resolution: high,	background: drD.videoBackground,	indenting: 0,	width: 0,	bitmap: LOOPHOLE[0],	height: 0,	longBitmap: LOOPHOLE[LONG[0]]];END;  -- of NewDCB --Even: PRIVATE PROCEDURE [nWords: CARDINAL] RETURNS [p: POINTER] =-- Allocates nWords starting at an even address.BEGINp _ AllocateStateNode[nWords + 1];p _ p + Inline.BITAND[p, 1];END;  -- of Even --AllocateLinePool: PRIVATE PROCEDURE RETURNS [line: LinePtr] =-- Allocates enough lines to fill the screen as defined in dsD.numScanLines, links them--   together and returns a pointer to the top of the chain.BEGINnode: LinePtr;line _ NIL;THROUGH [0 .. intC.numScanLines / dsD.lineHeight + 5) DO	node _ AllocateStateNode[SIZE[Line]];	node.nextLine _ line;	node.state _ trailingBlankLine;	node.rightX _ inD.leftMargin;	line _ node;	ENDLOOP;END;  -- of AllocateLinePool --END.  -- of InitInteractor --z20461(529)\f1