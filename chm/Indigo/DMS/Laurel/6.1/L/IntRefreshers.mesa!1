-- file:  IntRefreshers.mesa-- edited by Brotz, May 24, 1982  1:56 PM-- edited by Schroeder, August 1, 1978  11:43 AM-- edited by Levin, April 12, 1983  3:52 PM-- edited by Taft, May 17, 1983  2:22 PMDIRECTORY  Ascii USING [SP],  displayCommon USING [bitmapInMDS, bitMapReady],  dsD: FROM "DisplayDefs" USING [bmWidth, ClearRectangle, GetCharRightX,    GetStringWidth, lineHeight, paint, PaintPicture, PutCharInBitMap, PutStringInBitMap,    ScreenXCoord],  inD: FROM "InteractorDefs" USING [DisplayTOCEntry, DisplayTOCTail, HousePtr, LinePtr,    rightMargin, ScreenXCoord, ScrollDownTOC, TOCTextNbrPtr, UpdateTOCThumbLine],  Inline USING [DIVMOD],  intCommon USING [freePagesHouse, TOCRegion],  Process USING [Detach, Pause, SecondsToTicks, Ticks],  String USING [AppendString],  tsD: FROM "TOCSelectionDefs" USING [FirstSelectedEntry],  vmD: FROM "VirtualMgrDefs" USING [TOCIndex],  VMSpecial USING [GetAltoDiskSpace];IntRefreshers: PROGRAM  IMPORTS disC: displayCommon, dsD, inD, Inline, intC: intCommon, Process, String, tsD, VMSpecial  EXPORTS inD =BEGINOPEN inD;TextHouseRefresher: PUBLIC PROCEDURE [hp: HousePtr] =-- Repaints one simple text house on the display screen, according to the parameters--   contained in hp^.BEGINIF NOT disC.bitMapReady THEN RETURN;dsD.ClearRectangle[hp.leftX,  hp.rightX,  hp.topY,  hp.bottomY];IF hp.usePicture THEN dsD.PaintPicture[hp.leftX, hp.topY, hp.picture, dsD.paint]ELSE BEGIN  SELECT hp.fixedEdge FROM    left => hp.rightX _ hp.leftX + dsD.GetStringWidth[hp.text, hp.typeface];    right => hp.leftX _ hp.rightX - dsD.GetStringWidth[hp.text, hp.typeface];    ENDCASE;  [] _ dsD.PutStringInBitMap[hp.leftX, hp.topY, hp.text, hp.typeface];  END;END;  -- of TextHouseRefresher --BracketsHouseRefresher: PUBLIC PROCEDURE [hp: HousePtr] =-- Repaints one brackets command house on the display screen.BEGINOPEN dsD;curX, limX, x: ScreenXCoord;i: CARDINAL;ClearRectangle[hp.leftX,  hp.rightX,  hp.topY,  hp.bottomY];curX _ PutCharInBitMap['{, hp.leftX, hp.topY, boldFace];limX _ (IF hp.nextHouse = NIL OR hp.nextHouse.lineNumber # hp.lineNumber  THEN inD.rightMargin ELSE hp.nextHouse.leftX) - GetStringWidth[" } "L, boldFace];-- space before bracket is for caretIF GetStringWidth[hp.text, plainFace]+curX <= limX THEN  curX _ PutStringInBitMap[curX, hp.topY, hp.text, hp.typeface]ELSE BEGIN  FOR i IN [0..5] DO    curX _ PutCharInBitMap[hp.text[i], curX, hp.topY, plainFace];    ENDLOOP;  curX _ x _ PutStringInBitMap[curX, hp.topY, "..."L, plainFace];  FOR i _ hp.text.length-1, i-1 DO    IF (x _ GetCharRightX[hp.text[i], x]) > limX THEN EXIT;    ENDLOOP;  FOR i IN [i + 1 .. hp.text.length - 1] DO    curX _ PutCharInBitMap[hp.text[i], curX, hp.topY, plainFace];    ENDLOOP;  END;hp.rightX _ PutCharInBitMap['}, curX, hp.topY, boldFace];END;  -- of BracketsHouseRefresher --NullHouseRefresher: PUBLIC PROCEDURE [hp: HousePtr] =-- Place-holder.BEGINEND;  -- of NullHouseRefresher --RefreshHouse: PUBLIC PROCEDURE [hp: HousePtr, text: STRING] =-- Resets hp.text to text and calls hp.houseRefresher.BEGINhp.text.length _ 0;String.AppendString[hp.text, text];hp.houseRefresher[hp];END;  -- of RefreshHouse --TOCTextPainter: PUBLIC PROCEDURE [tnp: TOCTextNbrPtr, key: CARDINAL] =-- Paints the TOC text neighborhood starting with the first selected entry.BEGINendLineNumber: CARDINAL;line: LinePtr;index: vmD.TOCIndex;IF ~tnp.haveToc THEN RETURN;intC.TOCRegion.dcb.width _ 0;index _ tsD.FirstSelectedEntry[tnp.toc, key];IF index = 0 THEN index _ 1;DisplayTOCTail[tnp, key, tnp.lines, index, 1];IF tnp.nLines > 0 AND tnp.firstLineOffScreen.state = empty THEN  BEGIN  -- scroll End of messages down to bottom line on screen.  endLineNumber _ 1;  FOR line _ tnp.lines, line.nextLine UNTIL line.state = end DO    endLineNumber _ endLineNumber + 1;    ENDLOOP;  ScrollDownTOC[tnp.lines.y + (tnp.nLines - endLineNumber) * dsD.lineHeight, tnp, key];  END;IF tnp.nLines > 1 AND index > 1 AND tnp.lines.linePair.index = index  AND tnp.lines.state # end THEN  BEGIN  -- try to scroll down one more entry for context.  prevNLines, nLines: CARDINAL;  [ , prevNLines] _ DisplayTOCEntry[tnp, key, index - 1, 0, NIL];  [ , nLines] _ DisplayTOCEntry[tnp, key, index, 0, NIL];  IF nLines + prevNLines < tnp.nLines THEN    ScrollDownTOC[tnp.lines.y + prevNLines * dsD.lineHeight, tnp, key];  END;intC.TOCRegion.dcb.width _ dsD.bmWidth;UpdateTOCThumbLine[tnp, key];END;  -- of TOCTextPainter --FreePagesHouseRefresher: PROCEDURE =-- Repaints the free pages house with count on the display screen.BEGINtext: STRING = intC.freePagesHouse.text;oldCount: CARDINAL _ LAST[CARDINAL];ticks: Process.Ticks = Process.SecondsToTicks[IF disC.bitmapInMDS THEN 5 ELSE 1];DO  count, remainder: CARDINAL;  ok: BOOLEAN;  [count, ok] _ VMSpecial.GetAltoDiskSpace[wait: FALSE];  WHILE ok AND count=oldCount DO    [count, ok] _ VMSpecial.GetAltoDiskSpace[wait: TRUE];    ENDLOOP;  IF ~ok THEN EXIT;  oldCount _ count;  FOR i: CARDINAL DECREASING IN [0 .. 5) DO    [count, remainder] _ Inline.DIVMOD[count, 10];    text[i] _ '0 + remainder;    IF count = 0 THEN      {FOR j: CARDINAL IN [0 .. i) DO text[j] _ Ascii.SP; ENDLOOP; EXIT};    ENDLOOP;  TextHouseRefresher[intC.freePagesHouse];  Process.Pause[ticks];  ENDLOOP;END;  -- of FreePagesHouseRefresher --Process.Detach[FORK FreePagesHouseRefresher[]];END.  -- of IntRefreshers --z20461(529)\f1