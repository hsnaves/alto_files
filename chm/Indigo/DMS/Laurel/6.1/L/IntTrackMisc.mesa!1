-- file:  IntTrackMisc.mesa-- edited by Brotz, April 30, 1982  11:05 AM-- edited by Levin, August 28, 1980  5:11 PMDIRECTORY  Ascii USING [DEL],  dsD: FROM "DisplayDefs" USING [ChangeCursor, ClearRectangle, GetCursor,    InvertRectangle, lineHeight, PutCharInBitMap, ScreenXCoord, ScreenYCoord],  Editor USING [cancelCode],  inD: FROM "InteractorDefs" USING [AcceptKeyboardInput, CaretIsBlinking, cursorX,    cursorY, IdleLoop, leftMargin, lineBarLeftX, MapTOCIndexToTopY, MapYToTOCIndex,    markLeftX, MouseButton, numberLeftX, realTimeClock, ScreenXCoord, ScreenYCoord,    ScrollDownTOC, ScrollUpTOC, SetCaretBlinking, StartBlinkingCaret, StopBlinkingCaret,    ThisIsAFirstLine, TOCTextNbrPtr, TrackerType],  intCommon USING [continuousScrollDelay, continuousScrollTimeOut, keystream, source,    target],  StreamDefs USING [StreamHandle],  tsD: FROM "TOCSelectionDefs" USING [TOCTextTracker],  vmD: FROM "VirtualMgrDefs" USING [GetTOCFixedPart, PutTOCFixedPart, TOCFixedPart,    TOCHandle, TOCIndex, UnlockTOC, WaitForLock];IntTrackMisc: PROGRAM  IMPORTS dsD, inD, intC: intCommon, tsD, vmD  EXPORTS inD =BEGINOPEN inD;-- Handles tracking in the TOC and DM regionsTOCTracker: PUBLIC PROCEDURE [tnp: TOCTextNbrPtr, trackerType: TrackerType] =-- Tracks cursor within the TOC text neighborhood.  Chooses among three subneighborhood--   cursor trackers depending on the cursor's position.BEGINx: ScreenXCoord;y: ScreenYCoord;xOffset, yOffset: INTEGER;cursorOk: BOOLEAN _ TRUE;dsD.ChangeCursor[charArrow];DO  [ , xOffset, yOffset] _ dsD.GetCursor[];  x _ cursorX^ + xOffset;  y _ cursorY^ + yOffset;  SELECT TRUE FROM    y ~IN [tnp.topY .. tnp.bottomY) => RETURN;    ~tnp.haveToc => NULL;    (x < lineBarLeftX) => {TOCScrollBarTracker[tnp]; cursorOk _ FALSE};    (x < leftMargin) => {tsD.TOCTextTracker[tnp]; cursorOk _ FALSE};    (x IN [markLeftX .. numberLeftX) AND trackerType = normal      AND tnp.displayFormatted) => {MarkTracker[tnp]; cursorOk _ FALSE};    ENDCASE => {IF ~cursorOk THEN dsD.ChangeCursor[charArrow]; cursorOk _ TRUE};  IdleLoop[];  AcceptKeyboardInput[];  ENDLOOP;END; -- of TOCTracker --TOCScrollBarTracker: PROCEDURE [tnp: TOCTextNbrPtr] =-- Sets cursor shape for scroll bar subneighborhood.  Watches for button up and down and--   calls TOC scroll routines as appropriate.BEGINLockAndScroll: PROCEDURE [y: ScreenYCoord, direction: {up, down}] =  BEGIN  toc: vmD.TOCHandle = tnp.toc;  keyExists: BOOLEAN = (intC.source.key # 0);  key: CARDINAL _ IF keyExists THEN intC.source.key ELSE vmD.WaitForLock[toc];  IF direction = up THEN ScrollUpTOC[y, tnp, key] ELSE ScrollDownTOC[y, tnp, key];  IF ~keyExists THEN vmD.UnlockTOC[toc, key];  END;  -- of LockAndScroll --state, newState: {neutral, up, down, continuousUp, continuousDown} _ neutral;x: ScreenXCoord;y: ScreenYCoord;startTime: CARDINAL;xOffset, yOffset: INTEGER;dsD.ChangeCursor[scroll];[ , xOffset, yOffset] _ dsD.GetCursor[];DO  x _ cursorX^ + xOffset;  y _ cursorY^ + yOffset;  IF x >= lineBarLeftX OR y ~IN [tnp.topY .. tnp.bottomY) THEN RETURN;  newState _ SELECT TRUE FROM    MouseButton[left, down] => IF state = continuousUp THEN state ELSE up,    MouseButton[right, down] => IF state = continuousDown THEN state ELSE down,    ENDCASE => neutral;  SELECT state FROM    up => IF newState = neutral THEN LockAndScroll[y, up];    down => IF newState = neutral THEN LockAndScroll[y, down];    continuousUp =>      IF inD.realTimeClock^ - startTime >= intC.continuousScrollDelay THEN        {startTime _ inD.realTimeClock^; LockAndScroll[tnp.topY, up]};    continuousDown =>      IF inD.realTimeClock^ - startTime >= intC.continuousScrollDelay THEN        {startTime _ inD.realTimeClock^; LockAndScroll[tnp.topY, down]};    ENDCASE;  SELECT TRUE FROM    (state = newState AND (state = up OR state = down)) =>      IF intC.continuousScrollTimeOut # 0        AND inD.realTimeClock^ - startTime >= intC.continuousScrollTimeOut THEN        BEGIN        state _ IF state = up THEN continuousUp ELSE continuousDown;        startTime _ inD.realTimeClock^ - intC.continuousScrollDelay;        END;    (newState # state) => BEGIN      IF (state _ newState) # neutral THEN startTime _ inD.realTimeClock^;      dsD.ChangeCursor        [SELECT state FROM up => scrollUp, down => scrollDown, ENDCASE => scroll];      END;    ENDCASE;  IdleLoop[];  AcceptKeyboardInput[];  ENDLOOP;END; -- of TOCScrollBarTracker --MarkTracker: PROCEDURE [tnp: TOCTextNbrPtr] =-- Tracks cursor within the mark subneighborhood.  Watches for button up and down,--   indicates cocked state on screen, changes marks on screen and in TOCEntry.BEGINstate: {neutral, cocked} _ neutral;x: ScreenXCoord;y, markY: ScreenYCoord;xOffset, yOffset: INTEGER;markC, thisEntry: vmD.TOCIndex;newMarkChar: CHARACTER;fp: vmD.TOCFixedPart;toc: vmD.TOCHandle = tnp.toc;key: CARDINAL _ 0;keystream: StreamDefs.StreamHandle = intC.keystream;InvertMark: PROCEDURE =  BEGIN  dsD.InvertRectangle[markLeftX, numberLeftX, markY, markY + dsD.lineHeight];  END;  -- of InvertMark --dsD.ChangeCursor[charArrow];[ , xOffset, yOffset] _ dsD.GetCursor[];DO  x _ cursorX^ + xOffset;  y _ cursorY^ + yOffset;  IF x ~IN [markLeftX .. numberLeftX) OR y ~IN [tnp.topY .. tnp.bottomY) THEN    BEGIN    IF state = cocked THEN {InvertMark[]; vmD.UnlockTOC[toc, key]};    RETURN;    END;  SELECT state FROM    neutral =>      IF MouseButton[left, down] AND ThisIsAFirstLine[y, tnp] THEN        BEGIN        key _ vmD.WaitForLock[toc];        thisEntry _ MapYToTOCIndex[y, tnp];        state _ cocked;        markC _ thisEntry;        [markY, ] _ MapTOCIndexToTopY[markC, tnp];        InvertMark[];        END;    cocked =>      IF MouseButton[left, up] THEN        BEGIN        keystream.reset[keystream];        dsD.ClearRectangle[markLeftX, numberLeftX, markY, markY + dsD.lineHeight];        StartBlinkingCaret[markLeftX, markY + dsD.lineHeight / 2];        dsD.ChangeCursor[invisibleCursor];        -- Read in mark and display it --        WHILE keystream.endof[keystream] DO          IdleLoop[];          ENDLOOP;        dsD.ChangeCursor[charArrow];        StopBlinkingCaret[];        state _ neutral;        vmD.GetTOCFixedPart[toc, key, markC, @fp];        SELECT newMarkChar _ keystream.get[keystream] FROM          Ascii.DEL, Editor.cancelCode => newMarkChar _ fp.mark;          '? => {fp.seen _ FALSE; fp.mark _ ' };          ENDCASE => {fp.seen _ TRUE; fp.mark _ newMarkChar};        [] _ dsD.PutCharInBitMap[newMarkChar, markLeftX, markY, plainFace];        vmD.PutTOCFixedPart[toc, key, markC, @fp];        vmD.UnlockTOC[toc, key];        key _ 0;        IF CaretIsBlinking[] THEN SetCaretBlinking[intC.target.point, intC.target.mnp];        END      ELSE -- left mouse button down, so track --        BEGIN        thisEntry _ MapYToTOCIndex[y, tnp];        IF ThisIsAFirstLine[y, tnp] THEN          BEGIN          IF thisEntry # markC THEN            BEGIN            InvertMark[];            markC _ thisEntry;            [markY, ] _ MapTOCIndexToTopY[markC, tnp];            InvertMark[];            END;          END        ELSE {InvertMark[]; vmD.UnlockTOC[toc, key]; key _ 0; state _ neutral};        END;    ENDCASE;  IdleLoop[];  AcceptKeyboardInput[];  ENDLOOP;END;  -- of MarkTracker --END.  -- of IntTrackMisc --z20461(529)\f1