-- PrintBravo.mesa; edited by Johnsson on June 25, 1980  9:22 AM-- converted to Laurel by Ken Pier,  July 30, 1981  11:21 AM-- last edited by Ken Pier,  21 Aug. 1981 10:29 am PDT (Friday)-- converted to Laurel 6.1 by Ken Pier,May 17, 1983  12:05 PMDIRECTORY  PrintDefs,  Press USING [    Character, GetCurrentPosition, Mica, SetCurrentFont, SetCurrentTabWidth,    SkipSomeSpace],  VMDefs: FROM "VMDefs" USING [FileHandle],  csD: FROM "CoreStreamDefs";PrintBravo: PROGRAM IMPORTS PrintDefs, Press, csD EXPORTS PrintDefs =  BEGIN    controlZ: CHARACTER = 32C;  endOfFile: CHARACTER = LAST[CHARACTER];  TAB: CHARACTER = 11C;  return: CHARACTER = 15C;  backSlash: CHARACTER = '\;  defaultLM: Press.Mica = 2998;    scanSH: csD.StreamHandle _ NIL;  copySH: csD.StreamHandle _ NIL;  bold: BOOLEAN;  italic: BOOLEAN;  graphic: BOOLEAN;  visible: BOOLEAN;  underline: BOOLEAN;  leftMargin: INTEGER;  firstLineLeftMargin: INTEGER;  rightMargin: INTEGER;  font: INTEGER;  setTabs: BOOLEAN;  tabs: ARRAY [0..15] OF CARDINAL;  newParagraph: BOOLEAN;  charactersInParagraph: INTEGER;  char: CHARACTER;    NotAtEnd: PROCEDURE[s: csD.StreamHandle] RETURNS [BOOLEAN] =     BEGIN RETURN[csD.GetLength[s] > csD.GetPosition[s]] END;      Get: PROCEDURE RETURNS [c: CHARACTER] =    BEGIN    eos: BOOLEAN _ FALSE;    c _ csD.Read[scanSH ! csD.EndOfStream => {c _ endOfFile; CONTINUE;};];    END;      CollectSuffixedInteger: PROCEDURE [c: CHARACTER] RETURNS [INTEGER] =    BEGIN    local: INTEGER _ 0;    IF c IN ['0..'9] THEN -- to avoid harm to char --      BEGIN      char _ c;      WHILE char IN ['0..'9] DO	local _ local*10 + (char - '0); char _ Get[]; ENDLOOP;      END;    RETURN[local];    END;      IndentStuff: PROCEDURE =    BEGIN    k: INTEGER _ IF newParagraph THEN firstLineLeftMargin ELSE leftMargin;    k _ k - defaultLM;    IF k < 1 THEN RETURN;    Press.SkipSomeSpace[k];    RETURN;    END;      FontStuff: PROCEDURE =    BEGIN    Press.SetCurrentFont[      font, (IF bold THEN bold ELSE medium),      (IF italic THEN italic ELSE regular)];    RETURN;    END;      SetTab: PROCEDURE =    BEGIN    stop, value: CARDINAL;    char _ Get[];    IF char IN ['0..'9] THEN stop _ char - '0 ELSE stop _ char - 'a;    char _ Get[];    IF char = ', THEN      BEGIN      value _ MAX[0, CollectSuffixedInteger[Get[]]];      tabs[stop] _ value;      setTabs _ TRUE;      END    ELSE -- uniform tabs      BEGIN      value _ stop;      WHILE char IN ['0..'9] DO	value _ value*10 + (char - '0); char _ Get[]; ENDLOOP;      Press.SetCurrentTabWidth[value];      setTabs _ FALSE;      END;    UNTIL char = ') DO char _ Get[] ENDLOOP;    char _ Get[];    RETURN;    END;      AdvanceToTab: PROCEDURE =    BEGIN    x: Press.Mica _ Press.GetCurrentPosition[].x + defaultLM;    FOR stop: CARDINAL IN [0..15] DO      IF tabs[stop] # LAST[CARDINAL] AND tabs[stop] > CARDINAL[x] THEN	{Press.SkipSomeSpace[tabs[stop] - x]; EXIT};      REPEAT FINISHED => Press.Character[TAB];      ENDLOOP;    RETURN;    END;      BravoIt: PUBLIC PROCEDURE [fh: VMDefs.FileHandle] =    BEGIN    j: INTEGER;    tempPos: csD.Position;    c: CHARACTER;    setTabs _ FALSE;    tabs _ ALL[LAST[CARDINAL]];    scanSH _ csD.Open[fh, byte, read];    copySH _ csD.Open[fh, byte, read];    BEGIN ENABLE UNWIND => BEGIN scanSH _ PrintDefs.DestroyS[scanSH];                                 copySH _ PrintDefs.DestroyS[copySH]; END;    IF ~NotAtEnd[scanSH] THEN RETURN;    charactersInParagraph _ 0;    char _ Get[]; -- need a running start --      WHILE NotAtEnd[scanSH] DO      newParagraph _ TRUE;      Press.Character[return]; -- return before every para, even first --      italic _ bold _ graphic _ visible _ underline _ FALSE;      leftMargin _ firstLineLeftMargin _ defaultLM;      font _ 0;      tempPos _ csD.GetPosition[scanSH] - 1;      csD.SetPosition[copySH, tempPos]; -- for the later copy --      UNTIL char = controlZ OR char = endOfFile DO	charactersInParagraph _ charactersInParagraph + 1; char _ Get[]; ENDLOOP;      WHILE char # backSlash AND char # return AND char # endOfFile DO	SELECT char FROM	  'l => leftMargin _ CollectSuffixedInteger['0];	  'd => firstLineLeftMargin _ CollectSuffixedInteger['0];	  'r => rightMargin _ CollectSuffixedInteger['0];	  '( => SetTab[];	  ENDCASE => char _ Get[];	ENDLOOP;      IF char = backSlash THEN	BEGIN	WHILE char # return AND char # endOfFile DO	  SELECT char FROM	    'b => BEGIN bold _ TRUE; char _ Get[]; END;	    'B => BEGIN bold _ FALSE; char _ Get[]; END;	    'i => BEGIN italic _ TRUE; char _ Get[]; END;	    'I => BEGIN italic _ FALSE; char _ Get[]; END;	    'g => BEGIN graphic _ TRUE; char _ Get[]; END;	    'G => BEGIN graphic _ FALSE; char _ Get[]; END;	    'v => BEGIN visible _ TRUE; char _ Get[]; END;	    'V => BEGIN visible _ FALSE; char _ Get[]; END;	    'u => BEGIN underline _ TRUE; char _ Get[]; END;	    'U => BEGIN underline _ FALSE; char _ Get[]; END;	    'f => font _ CollectSuffixedInteger['0];	    'o => -- skip for now --[] _ CollectSuffixedInteger['0];	    '0, '1, '2, '3, '4, '5, '6, '7, '8, '9 =>	      BEGIN	      j _ CollectSuffixedInteger[char];	      -- have new run ... first set in ^ stuff: --	      IF newParagraph THEN IndentStuff[];	      newParagraph _ FALSE;	      FontStuff[];	      THROUGH [0..j) DO		IF charactersInParagraph > 0 THEN		  BEGIN		  c _ csD.Read[copySH];		  IF c = TAB AND setTabs THEN AdvanceToTab[]		  ELSE Press.Character[c];		  IF c = return THEN IndentStuff[];		  charactersInParagraph _ charactersInParagraph - 1;		  END;		ENDLOOP;	      END;	    ENDCASE => char _ Get[];	  ENDLOOP;	END;      IF char = return THEN char _ Get[];      IF charactersInParagraph > 0 THEN	BEGIN	IF newParagraph THEN IndentStuff[];	newParagraph _ FALSE;	FontStuff[];	WHILE charactersInParagraph > 0 DO	  c _ csD.Read[copySH];	  IF c = TAB AND setTabs THEN AdvanceToTab[] ELSE Press.Character[c];	  IF c = return THEN IndentStuff[];	  charactersInParagraph _ charactersInParagraph - 1;	  ENDLOOP;	END;  ENDLOOP;    scanSH _ PrintDefs.DestroyS[scanSH];    copySH _ PrintDefs.DestroyS[copySH];     END;--of ENABLED UNWIND block    END;--of PROC BravoIt        END...