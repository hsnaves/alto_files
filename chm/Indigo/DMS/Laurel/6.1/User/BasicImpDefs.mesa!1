-- file BasicImpDefs.mesa-- edited by Brotz and Hilton, September 23, 1982  2:12 PMDIRECTORY  BasicDefs,  BasicOps,  ControlDefs,  SegmentDefs,  vmD: FROM "VirtualMgrDefs";BasicImpDefs: DEFINITIONS =BEGIN OPEN BasicDefs;-- Global VariablesautoIncrement: CARDINAL;autoOn: BOOLEAN;  -- used for automatic numbering --autoStart: CARDINAL;charTablePtr: POINTER TO CharTable;cM: vmD.ComposedMessagePtr;codeCm: vmD.ComposedMessagePtr;currentProgLine: ProgramLineDescPtr;lineCodeCm: vmD.ComposedMessagePtr;constantHead: VariablePtr;contPc: ProgramLineDescPtr;dataItem: CARDINAL;dataLinePc: ProgramLineDescPtr;endOfLine: BOOLEAN;fnEvalStack: FnEvalRecordPtr;goSubHead: GoSubStackPtr;haveToken: BOOLEAN;inputLine: STRING;inputLineIndex: CARDINAL;isProgramLine: BOOLEAN;loadedConfigs: LoadedConfigRecPtr;nextStackHead: NextStackPtr;noMoreData: BOOLEAN;optionBase: CARDINAL;optionBaseCalled: BOOLEAN;-- optionBaseCalled will be set to TRUE when the first DIM statement is called--   or when OPTION BASE is calledprogramLineDescHead: ProgramLineDescPtr;realPosOrNeg: PositiveOrNegative;stack: ARRAY (0 .. stackLimit) OF BasicValue;stackPointer: CARDINAL;stackLimit: CARDINAL = 20;statementSeparatorChar: CHARACTER;token: STRING;trigMode: TrigonometricMode;userInputLine: STRING;userInputLineIndex: CARDINAL;noMoreInput: BOOLEAN;variableHead: VariablePtr;-- ModulesBasicCommand: PROGRAM;BasicFunction: PROGRAM;BasicParser: PROGRAM;BasicProgram: PROGRAM;BasicScanner: PROGRAM;BasicVariable: PROGRAM;BasicInterpA: PROGRAM;BasicInterpB: PROGRAM;-- ProceduresAllocateArray: PROCEDURE [rowIndex, columnIndex: CARDINAL, varPtr:  VariablePtr]; AllocateAndInsert:  PROCEDURE [programLineNumber, textStartIndex: CARDINAL];-- Inserts (or replaces) a program line descriptor at the appropriate place in--   the line descriptor chain according to programLineNumber.  Calls--   InsertMessage to insert the program text in cM.AllocateConstant: PROCEDURE [bv: BasicValue] RETURNS [varPtr: VariablePtr];AllocateVariableRecord: PROCEDURE [name: STRING, next: VariablePtr]  RETURNS [new: VariablePtr];AppendByte: PROCEDURE  [cm: vmD.ComposedMessagePtr, byte: BasicOps.Byte];-- Appends a byte to the cm (for code generation).AppendPointer: PROCEDURE  [cm: vmD.ComposedMessagePtr, pointer: POINTER];-- Appends a pointer to the cm (for code generation).CheckForEqualSign: PROCEDURE;-- Raises ParseError if an equal sign is not found while parsing.CheckForVariable: PROCEDURE;-- Raises ParseError if a variable is not found while parsing.ChooseLineNumber: PROCEDURE [cm: vmD.ComposedMessagePtr, pc: vmD.CharIndex]  RETURNS [CARDINAL];ClearStack: PROCEDURE;-- Clears execution stack.CommandCleanUp: PROCEDURE;-- Frees all pointers to the stack of NextStackRec(ords) and also all --   pointers to the GoSubRec(ords).Compare: PROCEDURE [bvp1, bvp2: BasicValuePtr] RETURNS [result: INTEGER];-- Returns -1 if bvp1 < bvp2, 0 if bvp1 = bvp2, 1 if bvp1 > bvp2.ConvertToCardinal: PROCEDURE [bv: BasicValuePtr] RETURNS [n: CARDINAL];Expression: PROCEDURE;-- Expression is the first procedure of a recursive descent expression--   parser.  It in turn calls procedures which parse the expression into--   'Relation', 'ArithmeticExpression', 'Term', 'Factor' and 'Primary'. FetchByte: PROCEDURE [cm: vmD.ComposedMessagePtr, pc: vmD.CharIndex]  RETURNS [byte: BasicOps.Byte, newPc: vmD.CharIndex];FetchPointer: PROCEDURE [cm: vmD.ComposedMessagePtr, pc: vmD.CharIndex]  RETURNS [pointer: POINTER, newPc: vmD.CharIndex];FindInfixReservedWord: PROCEDURE [word: STRING] RETURNS [wordStart: CARDINAL];-- Starting at inputLineIndex, finds the index in inputLine, "wordStart", at which the--   reserved word "word" begins.  Use this procedure to find where an infix reserved word--   such as THEN, ELSE, TO, STEP, etc. begins so as to fake the GetToken procedure into--   terminating tokens before such a word.FindLineNumber: PROCEDURE [lineNumber: CARDINAL]  RETURNS [tempPc: ProgramLineDescPtr];-- Travels down single linked chain of ProgramLineDesc records until the--   temporary program counter (tempPc) equals NIL or until the target--   lineNumber is found.GetInputValue: PROCEDURE [isString: BOOLEAN] RETURNS [value: BasicValue];GetRealNumber: PROCEDURE [integerPart: STRING] RETURNS [realNum: REAL];-- Ends having gotten the next token after the complete real number.GetSubstring: PROCEDURE [varPtr: VariablePtr] RETURNS [value: BasicValue];-- This procedure has not been updatedGetToken: PROCEDURE RETURNS [BOOLEAN];-- Parses a program text line (global string s) by characters and appends the--   characters onto a global string 'token'.  Tokens are deblanked and are--   one of five types - letter (alphanumeric), digit, colon, punctuation, and--   illegal.  GetToken returns TRUE when it does find a token, FALSE--   otherwise. InitBuiltInFunctionRegistry: PROCEDURE;InitCharTable: PROCEDURE;-- Initializes charTable (an array of all Ascii characters) into one of six--   types - letter (alphanumeric + '$), digit, colon, punctuation, white--   (SP,TAB, CR), and illegal.InterpretCode: PROCEDURE  [cm: vmD.ComposedMessagePtr, pc: vmD.CharIndex];-- Executes the code stored in cm starting at index pc.--   May raise RunTimeErrorSignal.IsReservedWord: PROCEDURE [targetWord: STRING] RETURNS [BOOLEAN];LastChar: PROCEDURE [string: STRING] RETURNS [char: CHARACTER];ListOperation: PROCEDURE [proc: PROC [ProgramLineDescPtr]];ListSourceAndCodeLine: PROCEDURE [line: ProgramLineDescPtr];LookUpVariable: PROCEDURE [varString: STRING] RETURNS [varPtr: VariablePtr];-- Looks up the variable varString from the single linked variable chain--   and returns the pointer to that variable.  If no such variable exists--   then LookUpVariable allocates storage for the new variable and--   initializes its record fields.NextStatement: PROCEDURE;-- Searches a program line for multiple statements by scanning for a colon--   token which is not nested within a set of quotation marks.  It then--   executes the statement after the colon.  If a statement does not exist--   after a colon, an ErrorCode is written and the program counter is--   set to NIL.  If, however, s.length is reached (s being the global string--   containing the program text) NextStatement then calls--   RetrievesProgramText which gets the next program line.OutputAutoLineNumber: PROCEDURE;ParseConstant: PROCEDURE RETURNS [value: BasicValue];ParseError: PROCEDURE [s: STRING];-- Prints out the error string and raises ParseErrorSignal.ParseErrorSignal: ERROR;-- Raised by ParseError.ParseStatement: PROCEDURE [savedIndex: CARDINAL];-- Parses the text in inputLine, generating code into lineCodeCm.--   May raise ParseErrorSignal.ParseSubscripts: PROCEDURE RETURNS [nIndices: CARDINAL];-- Parses one or two subscripts and returns how many it found.Pop: PROCEDURE RETURNS [bv: BasicValue];PopVariable: PROCEDURE [varPtr: VariablePtr];-- Restores the variable pushed below varPtr for function return.  Destroys variable--   currently at varPtr.ProgramCleanUp: PROCEDURE;-- Frees all ProgramLineDescPtrs and the VirtualMessageObject (cM).Push: PROCEDURE [vp: BasicValue];PushDownVariable: PROCEDURE [varPtr: VariablePtr];-- Creates a new variable at varPtr for a function's parameter, saving the old variable.PushInteger: PROCEDURE [i: INTEGER];QuitSignal: SIGNAL;RunTimeError: PROCEDURE [s: STRING];-- Prints out the error string and raises RunTimeErrorSignal.RunTimeErrorSignal: ERROR;-- Raised by RunTimeError.ScanQuotedString: PROCEDURE RETURNS [quoteString: STRING];-- Allocates and returns a string containing the contents of inputLine from inputLineIndex--   up to a terminating quote.  Two double quote marks in a row are reduced to a single--   double quote mark in the returned string.SearchForOpCodeByLines:  PROCEDURE [cm: vmD.VirtualMessagePtr, pc: ProgramLineDescPtr, opcode: BasicOps.Byte]  RETURNS [newPc: ProgramLineDescPtr];-- Looks for a line whose first compiled opcode is "opcode".  The search begins with "pc".--   If not found, then returns NIL.TokenIsLineNumber: PROCEDURE RETURNS[b: BOOLEAN, programLineNumber: CARDINAL];-- Determines whether or not the first token of each string is a number.--     If so, it is a program line.VariableCleanUp: PROCEDURE;-- Frees pointers to all stringValues, variable names and pointers to --   VariableRecords.-- TypesArrayRecord: TYPE = RECORD  [lb1, ub1, lb2, ub2: CARDINAL,   base: ARRAY [0..0) OF BasicValue];ArrayRecordPtr: TYPE = POINTER TO ArrayRecord;BasicValueNil: BasicValue = BasicValue[string, string[stringValue: NIL]];BasicValueZero: BasicValue = BasicValue[integer, integer[integerValue: 0]];CharType: TYPE = {letter, digit, statementSeparator, punctuation, white, illegal};CharTable: TYPE = ARRAY CHARACTER[0C..177C] OF CharType;FnEvalRecord: TYPE = RECORD  [next: FnEvalRecordPtr,  fn: UserFunctionVariablePtr,  parameter: VariablePtr,  returnPc: vmD.CharIndex,  returnProgLine: ProgramLineDescPtr];FnEvalRecordPtr: TYPE = POINTER TO FnEvalRecord;GoSubRec: TYPE = RECORD  [next: GoSubStackPtr,  returnPc: ProgramLineDescPtr];GoSubStackPtr: TYPE = POINTER TO GoSubRec;LoadedConfigRec: TYPE = RECORD  [next: LoadedConfigRecPtr,  cm: ControlDefs.ControlModule,  bcdFile: SegmentDefs.FileHandle];LoadedConfigRecPtr: TYPE = POINTER TO LoadedConfigRec;NextStackRec: TYPE = RECORD  [next: NextStackPtr,  varPtr: VariablePtr,  stepDirection: INTEGER,  stepValue,  finalValue: BasicValue,  progLine: ProgramLineDescPtr];NextStackPtr:  TYPE = POINTER TO NextStackRec;PositiveOrNegative: TYPE = {positive, negative};ProgramLineDesc: TYPE = RECORD  [next: ProgramLineDescPtr,  lineNumber: CARDINAL,  start,  end,  codeStart,  codeEnd: vmD.CharIndex];ProgramLineDescPtr:  TYPE = POINTER TO ProgramLineDesc;TrigonometricMode: TYPE = {radians, degrees, grads};VariableRecord: TYPE = RECORD   [next, pushDown: VariablePtr,  name: STRING,  value: BasicValue,  varPart: SELECT type: VariableType FROM    numeric => [arrayPtr: ArrayRecordPtr],     string => NULL,    builtInFunction => [proc: BuiltInFunction],    userFunction => [defLineNumber: CARDINAL],    ENDCASE];VariablePtr: TYPE = POINTER TO VariableRecord;UserFunctionVariablePtr: TYPE = POINTER TO userFunction VariableRecord;VariableType: TYPE = {numeric, string, array, builtInFunction, userFunction};END.  -- of BasicImpDefs --(635)\f1