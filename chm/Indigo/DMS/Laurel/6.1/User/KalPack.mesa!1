-- KalPack.mesa, Peter A. Arndt; Laurel 6--	Laurel version of Alto Kaleidoscope-- config entries: KalPack-- last revised by: Arndt, January 14, 1982  8:50 AMe2(353)\f1 3b12B27i38I1i-- last revised by: Brotz, January 18, 1982  3:44 PMe2\f1i-- last revised by: Taft, May 6, 1983  4:00 PMe2\f1iDIRECTORYe8\f1displayCommon USING [bitMapPtr, firstDCB],l3705d3352\f1i13IDMSTimeDefs USING [currentTime],l3705d3352\f1i11IdsD: FROM "DisplayDefs" USING [backgtype, bmWidth, ClearRectangle, DCBnil, DCBptr, ScreenYCoord, SetCursor, yOrigin],l3705d3352\f1i3IEditor USING [RefreshSoThatFirstCharStartsLine],l3705d3352\f1i6IImageDefs USING [BcdTime],l3705d3352\f1i9IinD: FROM "InteractorDefs" USING [GetNewMailCommand, IdleLoop, IndicateCommandBusy, IndicateCommandFinished, leftMargin, mouseX, mouseY, MoveDMCMBoundary, MoveTOCDMBoundary, rightMargin],l3705d3352\f1i3IInline USING [BITAND, BITNOT, BITOR, BITSHIFT, BITXOR, LongCOPY],l3705d3352\f1i6IintCommon USING [displayCommandHouse, dmcmBoundaryPadNbr, dmTextNbr, newMailCommandHouse, newMessagesHouse, tocdmBoundaryPadNbr, tocTextNbr],l3705d3352\f1i9IIODefs USING [CR, DEL, ESC, GetInputStream, GetOutputStream, LineOverflow, NumberFormat, ReadChar, ReadEditedString, Rubout, SetInputStream, SetOutputStream, SP, WriteChar, WriteDecimal, WriteLine, WriteNumber, WriteString],l3705d3352\f1i6ILaurelExecDefs USING [FlashTypescriptRegion],l3705d3352\f1i14ISegmentDefs USING [FileNameError, memConfig],l3705d3352\f1i11IStreamDefs USING [Append, DiskHandle, NewByteStream, Read, StreamHandle, userAbort, Write],l3705d3352\f1i10IString USING [AppendDecimal, AppendNumber, AppendString, InvalidNumber, LowerCase, StringToNumber, UpperCase],l3705d3352\f1i6ITime USING [Append, Unpack];l3705d3352\f1i4IKalPack: PROGRAMe8\f1b7BIMPORTS disC: displayCommon, dsD, Editor, ImageDefs, inD, intC: intCommon, Inline, IODefs, LaurelExecDefs, SegmentDefs, StreamDefs, String, Time =l3705d3352\f1BEGIN OPEN IODefs;e4\f1-- types:Generator: TYPE = RECORD [a, b, c: INTEGER, periodcount: CARDINAL];e4\f1i9I-- constants:size: CARDINAL = dsD.bmWidth * 16;wordsPerSL: CARDINAL = dsD.bmWidth;reflect: CARDINAL = (size - 1) * wordsPerSL;screenAreaWords: CARDINAL = wordsPerSL * size;e4\f1i13I-- variables:Bitmap: LONG POINTER;istrm: StreamDefs.StreamHandle _ GetInputStream [];period: CARDINAL _ 10000;persistence: CARDINAL _ 5000;xstateb: Generator _ [1, -1849, 3, ];xstatee: Generator;ystateb: Generator _ [1, 1809, 3, ];ystatee: Generator;e4\f1i13I-- variables for spotting and erasing:ptr: LONG POINTER;x0, x1, y0, y1: CARDINAL;x0Words, x1Words, y0Words, y1Words: CARDINAL;x0Bits, x1Bits, y0Bits, y1Bits: CARDINAL;x0Ptr, x1Ptr, y0Ptr, y1Ptr: LONG POINTER;e4\f1i38IAdvance: PROC = INLINEBEGIN OPEN Inline;     -- advance state of Generator records-- advance the spotting (begin) generatorsxstateb.a _ BITXOR [(xstateb.a + xstateb.b), xstateb.b];ystateb.a _ BITXOR [(ystateb.a + ystateb.b), ystateb.b];xstateb.periodcount _ ystateb.periodcount _ ystateb.periodcount - 1;IF ystateb.periodcount = 0 THEN	BEGIN	xstateb.b _ BITXOR [(xstateb.b + xstateb.c), xstateb.c];	ystateb.b _ BITXOR [(ystateb.b + ystateb.c), ystateb.c];	xstateb.periodcount _ ystateb.periodcount _ period;	END;-- and now advance the erasing generatorsxstatee.a _ BITXOR [(xstatee.a + xstatee.b), xstatee.b];ystatee.a _ BITXOR [(ystatee.a + ystatee.b), ystatee.b];xstatee.periodcount _ ystatee.periodcount _ ystatee.periodcount - 1;IF ystatee.periodcount # 0 THEN RETURN;xstatee.b _ BITXOR [(xstatee.b + xstatee.c), xstatee.c];ystatee.b _ BITXOR [(ystatee.b + ystatee.c), ystatee.c];xstatee.periodcount _ ystatee.periodcount _ period;END;		-- of proc Advancel3352d2999e6\f1b7B9b6B24i37I1i25b1B16I398i41I396i11b7BIClearScreen: PROC ={dsD.ClearRectangle [inD.leftMargin, inD.rightMargin, intC.dmTextNbr.topY, intC.dmTextNbr.topY + size];};		-- of proc ClearScreenl3352d2999e6\f1b11B115i11b11BIConfirm: PROC RETURNS [confirmed: BOOLEAN] =BEGINDO	SELECT String.LowerCase [ReadChar []] FROM		'y, CR, ESC, SP => confirmed _ TRUE;		'n, DEL => confirmed _ FALSE;		ENDCASE =>			BEGIN			WriteLine ["Yes (or CR) or No (or DEL)?"L];			LOOP;			END;	EXIT;ENDLOOP;WriteLine [IF confirmed THEN "Yes"L ELSE "No"L];END;		-- of proc Confirml3352d2999e6\f1b7B319i11b7BIDirtyWork: PROC = INLINE-- does [most of] the preparation assignments for Erases and SpotsBEGIN OPEN Inline;temp: CARDINAL;x1 _ (size - 1) - x0;y1 _ (size - 1) - y0;-- assign the global variables:x0Words _ BITSHIFT [x0, -4];x1Words _ BITSHIFT [x1, -4];y0Words _ BITSHIFT [y0, -4];y1Words _ BITSHIFT [y1, -4];x0Bits _ BITAND [x0, 17B];   x0Bits _ BITSHIFT [100000B, -x0Bits];x1Bits _ BITAND [x1, 17B];   x1Bits _ BITSHIFT [100000B, -x1Bits];y0Bits _ BITAND [y0, 17B];   y0Bits _ BITSHIFT [100000B, -y0Bits];y1Bits _ BITAND [y1, 17B];   y1Bits _ BITSHIFT [100000B, -y1Bits];temp _ x0 * wordsPerSL;x0Ptr _ Bitmap + temp;x1Ptr _ Bitmap + reflect - temp;temp _ y0 * wordsPerSL;y0Ptr _ Bitmap + temp;y1Ptr _ Bitmap + reflect - temp;END;		-- of proc DirtyWorkl3352d2999e6\f1b9B9b6B1i66I80i31I551i11b9BIErases: PROC = INLINEBEGIN OPEN Inline;     -- Same as Spots except this erasesbits: UNSPECIFIED;-- do most of the assigning:x0 _ BITSHIFT [xstatee.a, -8];y0 _ BITSHIFT [ystatee.a, -8];IF x0 >= (size / 2) OR y0 >= (size / 2) THEN RETURN;		-- clip to sizeIF x0 >= y0 THEN RETURN;     -- Discard points in other triangle (octant)DirtyWork [];-- and the rest:x0Bits _ BITNOT [x0Bits];x1Bits _ BITNOT [x1Bits];y0Bits _ BITNOT [y0Bits];y1Bits _ BITNOT [y1Bits];-- ok, now do the erasing:ptr _ y0Ptr + x0Words;LongCOPY[ptr, 1, @bits];bits _ BITAND [bits, x0Bits];   -- (x0, y0)LongCOPY[@bits, 1, ptr];ptr _ x0Ptr + y0Words;LongCOPY[ptr, 1, @bits];bits _ BITAND [bits, y0Bits];   -- (y0, x0)LongCOPY[@bits, 1, ptr];ptr _ y0Ptr + x1Words;LongCOPY[ptr, 1, @bits];bits _ BITAND [bits, x1Bits];   -- (x1, y0)LongCOPY[@bits, 1, ptr];ptr _ x1Ptr + y0Words;LongCOPY[ptr, 1, @bits];bits _ BITAND [bits, y0Bits];   -- (y0, x1)LongCOPY[@bits, 1, ptr];ptr _ y1Ptr + x1Words;LongCOPY[ptr, 1, @bits];bits _ BITAND [bits, x1Bits];   -- (x1, y1)LongCOPY[@bits, 1, ptr];ptr _ x1Ptr + y1Words;LongCOPY[ptr, 1, @bits];bits _ BITAND [bits, y1Bits];   -- (y1, x1)LongCOPY[@bits, 1, ptr];ptr _ y1Ptr + x0Words;LongCOPY[ptr, 1, @bits];bits _ BITAND [bits, x0Bits];   -- (x0, y1)LongCOPY[@bits, 1, ptr];ptr _ x0Ptr + y1Words;LongCOPY[ptr, 1, @bits];bits _ BITAND [bits, y1Bits];   -- (y1, x0)LongCOPY[@bits, 1, ptr];END;		-- of proc Erasesl3352d2999e6\f1b6B9b6B24i35I20i28I117i11I34i44I15i16I105i26I81i11I106i11I106i11I106i11I106i11I106i11I106i11I106i11I32i11b6BIFillDisplay: PROC = INLINEBEGIN OPEN Inline;     -- advance state of Generator recordsxstateb.a _ BITXOR [(xstateb.a + xstateb.b), xstateb.b];ystateb.a _ BITXOR [(ystateb.a + ystateb.b), ystateb.b];xstateb.periodcount _ ystateb.periodcount _ ystateb.periodcount - 1;IF ystateb.periodcount # 0 THEN RETURN;xstateb.b _ BITXOR [(xstateb.b + xstateb.c), xstateb.c];ystateb.b _ BITXOR [(ystateb.b + ystateb.c), ystateb.c];xstateb.periodcount _ ystateb.periodcount _ period;END;		-- of proc FillDisplayl3352d2999e6\f1b11B9b6B24i37I396i11b11BIKal: PROC =BEGINbackground: dsD.backgtype = disC.firstDCB.background;ctLoops: CARDINAL = 200;dmcm: dsD.ScreenYCoord;newMail: STRING = intC.newMessagesHouse.text;state: {noMail, waitingForConfirm, null} _ noMail;time: CARDINAL;tocdm: dsD.ScreenYCoord;l3352d2999e6\f1b3BSalutations ["Kal version 6.3"L];IF SegmentDefs.memConfig.AltoType IN [AltoI..AltoIIXM] AND  ~SegmentDefs.memConfig.useXM THEN  {WriteString["Sorry, your machine is incapable of running Kal."]; RETURN};ReadKalDotParams [];[tocdm, dmcm] _ SetUpScreen [];StartKalDisplay [];time _ DMSTimeDefs.currentTime.lowbits + 60;DO	WHILE istrm.endof [istrm] DO		THROUGH [0 .. ctLoops) DO     -- Main loop (all INLINE)			Advance [];     -- Advance and put 8 spots, then erase 8 spots			Spots [];			Erases [];		ENDLOOP;		IF StreamDefs.userAbort THEN GOTO Leave;		IF DMSTimeDefs.currentTime.lowbits >= time THEN			BEGIN			IF (time _ DMSTimeDefs.currentTime.lowbits + 60) < 60 THEN time _ LAST [CARDINAL];			inD.IdleLoop []; inD.IdleLoop [];		-- do clock update, mail check			SELECT state FROM				waitingForConfirm => LaurelExecDefs.FlashTypescriptRegion [];				noMail => IF newMail.length # 0 AND newMail [0] = 'Y THEN					BEGIN		-- new mail					WriteString ["You have new mail; shall I stop? "L];					LaurelExecDefs.FlashTypescriptRegion [];					state _ waitingForConfirm;					END;				ENDCASE;			END;	ENDLOOP;	IF state = waitingForConfirm THEN		{IF NOT Confirm [] THEN {state _ null; LOOP;} ELSE EXIT;};	SELECT String.UpperCase [ReadChar []] FROM		'Q, DEL =>			BEGIN			WriteString ["Quit [confirm] "L];			IF Confirm [] THEN EXIT;			LOOP;			END;		'? => {WriteLine ["?  Commands: Q (quit)"L]; LOOP;};		ENDCASE;	ReadParams [istrm, @xstateb, @ystateb ! Rubout => {WriteChar [CR]; CONTINUE; -- ... -- }];	ClearScreen [];   -- the parameters have [probably] changed	StartKalDisplay [];REPEAT	Leave => NULL;ENDLOOP;IF StreamDefs.userAbort THEN StreamDefs.userAbort _ FALSEELSE SaveParams [];ResetScreen [tocdm, dmcm, background];IF state = waitingForConfirm AND intC.tocTextNbr.haveToc THEN	BEGIN		-- get new mail, then move the cursor over "Display"	inD.IndicateCommandBusy [intC.newMailCommandHouse];	inD.GetNewMailCommand [intC.newMailCommandHouse, TRUE];	inD.IndicateCommandFinished [intC.newMailCommandHouse];	inD.mouseX^ _ intC.displayCommandHouse.leftX + 24;	inD.mouseY^ _ intC.displayCommandHouse.bottomY - 4;	END;END;		-- of proc Kall3352e3\f1 72f0 15f1 302i25I20i46I265i30I162i11I598i41I241i52I285i11b3BIReadN: PROC [default: UNSPECIFIED, signed: BOOLEAN] RETURNS [UNSPECIFIED, CHARACTER] =BEGIN OPEN String;     -- read number, echo default if ESC typed.ENABLE InvalidNumber, LineOverflow => {WriteChar ['?]; RETRY;};l3352d2999e6\f1b5B105i42Iatomfound: PROC [c: CHARACTER] RETURNS [BOOLEAN] = {RETURN [c = SP OR c = CR OR c = ESC];};		-- of proc atomfoundl3704d3351e3\f1b9B84i11b9BIs: STRING _ [10];saveNumber: STRING _ [10];lastch: CHARACTER;IF signed THEN AppendDecimal [s, default]ELSE AppendNumber [s, default, 10];AppendString [saveNumber, s];[lastch] _ ReadEditedString [s, atomfound, TRUE];IF s.length = 0 AND lastch = SP THEN WriteString [saveNumber];WriteChar [IF lastch = CR THEN CR ELSE SP];RETURN [IF s.length # 0 THEN StringToNumber [s, 10] ELSE default, lastch];END;		-- of proc ReadNl3351e3\f1 410i11b5BIReadKalDotParams: PROC =BEGIN OPEN StreamDefs;parstream: StreamHandle = NewByteStream ["Kal.params"L, Read ! SegmentDefs.FileNameError =>	 GOTO NoParamsFile];ReadParams [parstream, @xstateb, @ystateb];parstream.destroy [parstream];EXITS	NoParamsFile => NULL;END;		-- of proc ReadKalDotParamsl3352d2999e6\f1b16B256i11b16BIReadParams: PROC [istrm: StreamDefs.StreamHandle, xs, ys: POINTER TO Generator] =BEGIN     -- Get new parameters from keyboard (usually)lastch: CHARACTER;currentStream: StreamDefs.StreamHandle = GetInputStream [];SetInputStream [istrm];WriteDecimal [xs.a];   WriteChar [SP];     -- Write old valuesWriteDecimal [xs.b];   WriteChar [SP];WriteDecimal [xs.c];   WriteChar [SP];   WriteNumber [period, NumberFormat [10, FALSE, TRUE, 0]];   WriteChar [SP];WriteNumber [persistence, NumberFormat [10, FALSE, TRUE, 0]];   WriteChar [SP];WriteDecimal [ys.a];   WriteChar [SP];WriteDecimal [ys.b];   WriteChar [SP];WriteDecimal [ys.c];WriteLine [".  New a, b, c, period, persistence, a', b', c':"L];	BEGIN	[xs.a, lastch] _ ReadN [xs.a, TRUE];   IF lastch = CR THEN GOTO Nomore;	[xs.b, lastch] _ ReadN [xs.b, TRUE];   IF lastch = CR THEN GOTO Nomore;	[xs.c, lastch] _ ReadN [xs.c, TRUE];   IF lastch = CR THEN GOTO Nomore;	[period, lastch] _ ReadN [period, FALSE]; IF lastch = CR THEN GOTO Nomore;	[persistence, lastch] _ ReadN [persistence, FALSE];	IF lastch = CR THEN GOTO Oldkal;     -- Set up for old kal if exactly 5 parameters	[ys.a, lastch] _ ReadN [ys.a, TRUE];   IF lastch = CR THEN GOTO Nomore;	[ys.b, lastch] _ ReadN [ys.b, TRUE];   IF lastch = CR THEN GOTO Nomore;	[ys.c, lastch] _ ReadN [ys.c, TRUE];   IF lastch = CR THEN GOTO Nomore;	WriteChar [CR];	EXITS		Nomore => NULL;		Oldkal =>     -- Old kaleidoscope			BEGIN			ys.a _ Inline.BITSHIFT [xs.a, 8];			ys.b _ Inline.BITSHIFT [xs.b, 8];			ys.c _ Inline.BITSHIFT [xs.c, 8];			END;	END;SetInputStream [currentStream];END;		-- of proc ReadParamsl3352d2999e6\f1b10B82i45I147i19I794i45I278i19I173i11b10BIResetScreen: PROC [tocdm, dmcm: dsD.ScreenYCoord, background: dsD.backgtype] =BEGINClearScreen [];Editor.RefreshSoThatFirstCharStartsLine [firstChar: intC.dmTextNbr.lines.firstCharIndex, firstLine: intC.dmTextNbr.lines, mnp: intC.dmTextNbr];SetBackground [background];inD.MoveTOCDMBoundary [intC.tocdmBoundaryPadNbr, tocdm];inD.MoveDMCMBoundary [intC.dmcmBoundaryPadNbr, dmcm];END;		-- of proc ResetScreenl3352d2999e6\f1b11B379i11b11BISalutations: PROC [version: STRING] =BEGIN OPEN Time;time: STRING _ [20];WriteChar [CR];WriteString [version];WriteString [", of "L];Append [time, Unpack [ImageDefs.BcdTime []]];time.length _ time.length - 3;		-- remove the secondsWriteLine [time];time.length _ 0;Append [time, Unpack []];WriteLine [time];WriteChar [CR];END;		-- of proc Salutationsl3352d2999e6\f1b11B206i21I102i11b11BISaveParams: PROC =-- writes the current parameters to Kal.params if the user desiresBEGINWriteString ["Shall I save the current parameters? "L];IF Confirm [] THEN	BEGIN OPEN StreamDefs;	diskH: DiskHandle = NewByteStream ["Kal.params"L, Append + Write];	output: StreamHandle = GetOutputStream [];	SetOutputStream [diskH];	WriteDecimal [xstateb.a];   WriteChar [SP];	WriteDecimal [xstateb.b];   WriteChar [SP];	WriteDecimal [xstateb.c];   WriteChar [SP];	WriteDecimal [LOOPHOLE [period]];   WriteChar [SP];	WriteDecimal [LOOPHOLE [persistence]];   WriteChar [SP];	WriteDecimal [ystateb.a];   WriteChar [SP];	WriteDecimal [ystateb.b];   WriteChar [SP];	WriteDecimal [ystateb.c];   WriteChar [CR];	SetOutputStream [output];	diskH.destroy [diskH];	END;END;		-- of proc SaveParamsl3352d2999e6\f1b10B9i66I688i11b10BISetBackground: PROC [background: dsD.backgtype] =BEGINFOR chain: dsD.DCBptr _ disC.firstDCB, chain.next UNTIL chain = dsD.DCBnil DO	chain.background _ background;ENDLOOP;END;		-- of proc SetBackgroundl3352d2999e6\f1b13B168i11b13BISetUpScreen: PROC RETURNS [tocdm, dmcm: dsD.ScreenYCoord] =BEGINtocdm _ intC.tocdmBoundaryPadNbr.topY;dmcm _ intC.dmcmBoundaryPadNbr.topY;inD.MoveTOCDMBoundary [intC.tocdmBoundaryPadNbr, 90];inD.MoveDMCMBoundary [intC.dmcmBoundaryPadNbr, (intC.dmTextNbr.topY + 480)];SetBackground [black];Bitmap _ LOOPHOLE [((intC.dmTextNbr.topY - dsD.yOrigin) * dsD.bmWidth) + disC.bitMapPtr];ClearScreen [];dsD.SetCursor [charArrow];END;		-- of proc SetUpScreenl3352d2999e6\f1b11B424i11b11BISpots: PROC = INLINEBEGIN OPEN Inline;     -- Draw 8 spots with kaleidoscopic symmetrybits: UNSPECIFIED;-- assign the global variables:x0 _ BITSHIFT [xstateb.a, -8];y0 _ BITSHIFT [ystateb.a, -8];IF x0 >= (size / 2) OR y0 >= (size / 2) THEN RETURN;		-- clip to sizeIF x0 >= y0 THEN RETURN;     -- Discard points in other triangle (octant)DirtyWork [];-- ok, now do the spotting:ptr _ y0Ptr + x0Words;LongCOPY[ptr, 1, @bits];bits _ BITOR [bits, x0Bits];   -- (x0, y0)LongCOPY[@bits, 1, ptr];ptr _ x0Ptr + y0Words;LongCOPY[ptr, 1, @bits];bits _ BITOR [bits, y0Bits];   -- (y0, x0)LongCOPY[@bits, 1, ptr];ptr _ y0Ptr + x1Words;LongCOPY[ptr, 1, @bits];bits _ BITOR [bits, x1Bits];   -- (x1, y0)LongCOPY[@bits, 1, ptr];ptr _ x1Ptr + y0Words;LongCOPY[ptr, 1, @bits];bits _ BITOR [bits, y0Bits];   -- (y0, x1)LongCOPY[@bits, 1, ptr];ptr _ y1Ptr + x1Words;LongCOPY[ptr, 1, @bits];bits _ BITOR [bits, x1Bits];   -- (x1, y1)LongCOPY[@bits, 1, ptr];ptr _ x1Ptr + y1Words;LongCOPY[ptr, 1, @bits];bits _ BITOR [bits, y1Bits];   -- (y1, x1)LongCOPY[@bits, 1, ptr];ptr _ y1Ptr + x0Words;LongCOPY[ptr, 1, @bits];bits _ BITOR [bits, x0Bits];   -- (x0, y1)LongCOPY[@bits, 1, ptr];ptr _ x0Ptr + y1Words;LongCOPY[ptr, 1, @bits];bits _ BITOR [bits, y1Bits];   -- (y1, x0)LongCOPY[@bits, 1, ptr];END;		-- of proc Spotsl3352d2999e6\f1b5B9b6B24i43I20i31I117i11I34i44I15i27I80i11I105i11I105i11I105i11I105i11I105i11I105i11I105i11I32i11b5IStartKalDisplay: PROC =-- performs the initial spotting to establish the displayBEGINi: CARDINAL;xstateb.periodcount _  ystateb.periodcount _ period;xstatee _ xstateb;ystatee _ ystateb;-- Run the b(egin) generators ahead:FOR i IN [1 .. persistence] DO	FillDisplay [];	Spots [];	IF ~istrm.endof [istrm] THEN EXIT;		-- what?  why?ENDLOOP;END;		-- of proc StartKalDisplayl3352d2999e6\f1b15B9i57I111i36I97i14I16i11b15BI-- mainline code:Kal [];END.		-- of program KalPacke6\f1i17I15i14b7BI