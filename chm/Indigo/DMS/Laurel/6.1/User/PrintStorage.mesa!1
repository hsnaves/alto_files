-- PrintStorage.mesa-- Edited by Levin, September 9, 1980  5:17 PM-- Edited by Brotz, July 15, 1981  4:35 PMDIRECTORY  AltoDefs,  FSPDefs,  PrintDefs,  Mopcodes,  SegmentDefs,  Storage,  SystemDefs;PrintStorage: PROGRAM  IMPORTS FSPDefs, SegmentDefs, realSystemDefs: SystemDefs  EXPORTS SystemDefs, Storage, PrintDefs = PUBLICBEGIN-- Interface for Laurel ExecutiveclientPages: CARDINAL _ 0;clientWords: CARDINAL _ 0;-- SystemDefs Interface for Laurel Client BCDsAllocatePages, AllocateResidentPages, Pages: PROCEDURE [npages: CARDINAL]  RETURNS [base: POINTER] =  BEGIN  OPEN SegmentDefs;  seg: DataSegmentHandle _ MakeDataSegment[DefaultMDSBase, npages, HardDown];  seg.type _ 89;  base _ DataSegmentAddress[seg];  AddSegmentToList[base];  END;AllocateSegment, AllocateResidentSegment, Words: PROCEDURE [nwords: CARDINAL]  RETURNS [base: POINTER] =  {RETURN[AllocatePages[PgsForWords[nwords]]]};FreePages, FreeSegment, FreeWords: PROCEDURE [base: POINTER] =  BEGIN  RemoveSegmentFromList[base];  RealFreePages[base];  END;RealFreePages: PROCEDURE [base: POINTER] =  BEGIN OPEN SegmentDefs;    seg: DataSegmentHandle = VMtoDataSegment[base];    IF seg # NIL THEN DeleteDataSegment[seg];   END;SegmentListRec: TYPE = RECORD [next: SegmentList, base: POINTER];SegmentList: TYPE = POINTER TO SegmentListRec;segmentList: SegmentList _ NIL;AddSegmentToList: PRIVATE PROCEDURE [base: POINTER] =  BEGIN  sl: SegmentList _ AllocateHeapNode[SIZE[SegmentListRec]];  sl^ _ SegmentListRec[next: segmentList, base: base];  segmentList _ sl;  END;RemoveSegmentFromList: PRIVATE PROCEDURE [base: POINTER] =  BEGIN  sl: SegmentList _ segmentList;  slPrev: SegmentList _ NIL;  UNTIL sl = NIL DO    IF base = sl.base THEN      {IF slPrev = NIL THEN segmentList _ sl.next ELSE slPrev.next _ sl.next; RETURN};    slPrev _ sl;    sl _ sl.next;    ENDLOOP;  END;SegmentSize: PROCEDURE [base: POINTER] RETURNS [nwords: CARDINAL] =  {RETURN[realSystemDefs.SegmentSize[base]]};HeapZone: PROCEDURE RETURNS [FSPDefs.ZonePointer] =  {IF execHeap = NIL THEN StartExecStorage[]; RETURN[execHeap]};PruneHeap, Prune: PROCEDURE RETURNS [BOOLEAN] =    BEGIN RETURN[execHeap # NIL AND FSPDefs.PruneZone[execHeap]] END;Even: PROCEDURE [u: UNSPECIFIED] RETURNS [UNSPECIFIED] =  {RETURN[realSystemDefs.Even[u]]};Quad: PROCEDURE [u: UNSPECIFIED] RETURNS [UNSPECIFIED] =  {RETURN[realSystemDefs.Quad[u]]};UsedNodeSize: FSPDefs.BlockSize = SIZE[inuse FSPDefs.NodeHeader];FreeNodeSize: FSPDefs.BlockSize = SIZE[free FSPDefs.NodeHeader];ZoneHeaderSize: FSPDefs.BlockSize = SIZE[FSPDefs.ZoneHeader];execHeap: FSPDefs.ZonePointer _ NIL;LargeNode: CARDINAL = 150;Node, AllocateHeapNode: PROCEDURE [nwords: CARDINAL] RETURNS [p: POINTER] =    BEGIN OPEN FSPDefs;    IF execHeap = NIL THEN StartExecStorage[];    IF INTEGER[nwords] < 0 THEN ERROR ZoneTooSmall[execHeap];    IF nwords + UsedNodeSize > LargeNode THEN      BEGIN      p _ Pages[PgsForWords[nwords + UsedNodeSize]];      p^ _ NodeHeader[length: nwords + UsedNodeSize, extension: inuse[]];      clientWords _ clientWords + FSPDefs.NodeSize[p + 1];      RETURN[p + 1]      END;    p _ MakeNode[execHeap, nwords      ! NoRoomInZone =>        BEGIN        Expand[PgsForWords[nwords + ZoneOverhead + UsedNodeSize]];        RESUME        END];    clientWords _ clientWords + FSPDefs.NodeSize[p];    END;Expand: PROCEDURE [pages: CARDINAL] =BEGINFSPDefs.AddToNewZone[z: execHeap, base: GetMorePages[pages],    length: pages*AltoDefs.PageSize, deallocate: RealFreePages];END;GetMorePages: PROCEDURE [pages: CARDINAL] RETURNS [POINTER] =BEGIN OPEN SegmentDefs;seg: DataSegmentHandle _ MakeDataSegment[DefaultMDSBase, pages, HardDown];seg.type _ 89;RETURN[DataSegmentAddress[seg]];END;Free, FreeHeapNode: PROCEDURE [p: POINTER] =BEGIN OPEN SegmentDefs, FSPDefs;pp: POINTER;IF p = NIL THEN RETURN;clientWords _ clientWords - FSPDefs.NodeSize[p];IF LOOPHOLE[(pp _ p - 1), POINTER TO inuse NodeHeader].length > LargeNode  AND DataSegmentAddress[VMtoDataSegment[pp]] = pp THEN  {FreePages[pp]; RETURN};FreeNode[execHeap, p];END;String, AllocateHeapString: PROCEDURE [nchars: CARDINAL] RETURNS [s: STRING] =BEGINs _ AllocateHeapNode[WdsForString[nchars]];s^ _ StringBody[length: 0, maxlength: nchars, text:];RETURN[s]END;PgsForWords: PRIVATE PROCEDURE [nwords: CARDINAL] RETURNS [CARDINAL] = INLINE  {RETURN[(nwords + AltoDefs.PageSize - 1) / AltoDefs.PageSize]};WdsForString: PRIVATE PROCEDURE [nchars: CARDINAL] RETURNS [CARDINAL] = INLINE  {RETURN[2 + (nchars + 1) / 2]};FreeString, FreeHeapString: PROCEDURE [s: STRING] = LOOPHOLE[Free];CopyString: PROCEDURE [s: STRING, longer: CARDINAL _ 0] RETURNS [STRING] =    BEGIN    ns: STRING;    IF s = NIL THEN RETURN[IF longer = 0 THEN NIL ELSE String[longer]];    ns _ AllocateHeapString[s.length + longer];    CPY[from: @s.text, to: @ns.text, nwords: (s.length + 1)/2];    ns.length _ s.length;    RETURN[ns];    END;ExpandString: PROCEDURE [s: POINTER TO STRING, longer: CARDINAL _ 0] =    BEGIN    ns: STRING;    IF s^ = NIL THEN {IF longer # 0 THEN s^ _ String[longer]; RETURN};    ns _ AllocateHeapString[s.maxlength + longer];    CPY[from: @s.text, to: @ns.text, nwords: (s.length + 1)/2];    ns.length _ s.length;    FreeHeapString[s^];    s^ _ ns;    END;CPY: PRIVATE PROCEDURE [from: POINTER, nwords: CARDINAL, to: POINTER] =  MACHINE CODE {Mopcodes.zBLT};StartExecStorage: PROCEDURE =  {execHeap _ FSPDefs.MakeNewZone      [GetMorePages[2], 2*AltoDefs.PageSize, RealFreePages]};FinishPrintStorage: PROCEDURE =  BEGIN  UNTIL segmentList = NIL DO    FreePages[segmentList.base];    ENDLOOP;  IF execHeap # NIL THEN {FSPDefs.DestroyZone[execHeap]; execHeap _ NIL};  END;END.  -- of PrintStorage --