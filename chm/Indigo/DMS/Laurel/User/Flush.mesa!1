-- Inbox management program to run in Laurel ---- [Indigo]<DMS>Laurel>User>Flush.mesa ---- Mike Schroeder, 14 Oct. 1982 4:49 pm PDT (Thursday) --DIRECTORY  IODefs, RetrieveDefs, String;Flush: PROGRAMIMPORTS IODefs, RetrieveDefs, String =BEGINOPEN IODefs;Yes: PROCEDURE RETURNS [BOOLEAN] =BEGIN  WriteString[" (y or n)? "L];  DO    SELECT String.LowerCase[ReadChar[]] FROM      'y => {WriteChar['y]; RETURN[TRUE]};      'n => {WriteChar['n]; RETURN[FALSE]};      ENDCASE => WriteChar['?];    ENDLOOP;  END; --Yes--Run: PROCEDURE =BEGIN  user: STRING = [64];  pwd: STRING = [32];  server: STRING = [32];  messages: STRING = [4];  msgCount: CARDINAL;  h: RetrieveDefs.Handle = RetrieveDefs.Create[60];  noMore: BOOLEAN;  serverState: RetrieveDefs.ServerState;  retProcs: RetrieveDefs.AccessProcs;  failed: BOOLEAN;  dots: STRING = " ... "L;  firstTime: BOOLEAN _ TRUE;  WriteString["Inbox flushing program for Grapevine administrators."];  DO    WriteChar[CR];    WriteChar[CR];    IF firstTime      THEN firstTime _ FALSE      ELSE {WriteString["Quit"L]; IF Yes[] THEN EXIT ELSE WriteChar[CR]};    WriteString["Account name: "L];    user.length _ 0;    ReadID[user ! Rubout => {WriteString[" xxx"L]; LOOP}];    WriteChar[CR];    WriteString["Password: "L];    pwd.length _ 0;    DO      c: CHARACTER = ReadChar[];      SELECT c FROM        DEL => GOTO delTyped;        CR, SP, ESC => EXIT;        ENDCASE => {WriteChar['*]; String.AppendChar[pwd, c]};      REPEAT delTyped => {WriteString[" xxx"L]; LOOP};      ENDLOOP;    WriteString[dots];    RetrieveDefs.NewUser[h, user, pwd];    SELECT RetrieveDefs.MailboxState[h] FROM      badName =>        {WriteString["bad name."]; LOOP};      badPwd =>        {WriteString["bad password."]; LOOP};      cantAuth, allDown, someEmpty =>        {WriteString["some necessary servers down."]; LOOP};      allEmpty =>        {WriteString["all inboxes empty."]; LOOP};      notEmpty =>        NULL;       ENDCASE => ERROR;    WriteChar[CR];    WriteString["Do you really want to throw away all messages for this user"L];    IF NOT Yes[] THEN LOOP;    failed _ FALSE;    DO      WriteChar[CR];      [noMore, serverState, retProcs] _ RetrieveDefs.NextServer[h];      IF noMore THEN EXIT;      RetrieveDefs.ServerName[h, server];      WriteString["   "L];      WriteString[server];      WriteString[dots];      SELECT serverState FROM        unknown => {WriteString["no response"L]; failed _ TRUE; LOOP};        empty => {WriteString["was empty"L]; LOOP};        notEmpty => NULL;        ENDCASE => ERROR;      BEGIN        ENABLE RetrieveDefs.Failed => BEGIN        failed _ TRUE;        WriteString [SELECT why FROM          communicationFailure => "communication failure"L,          connectionRejected => "connection rejected"L,          noSuchServer, badCredentials, unknownFailure => "failed"L,          ENDCASE => ERROR];        LOOP;        END;        msgCount _ 0;        UNTIL NOT retProcs.nextMessage[h].msgExists DO          msgCount _ msgCount+1;          ENDLOOP;        retProcs.accept[h]; --flushes the inbox--        END;      messages.length _ 0;      String.AppendDecimal[messages, msgCount];      WriteString[messages];      WriteString[" messages flushed"L];      ENDLOOP;    WriteString["Inbox flushing "L];    IF failed THEN WriteString["not completely "L];    WriteString["successful."L];    ENDLOOP;  RetrieveDefs.Destroy[h];  WriteChar[CR];  WriteChar[CR];  WriteLine["Done."L];  END; --Run--Run[];END.