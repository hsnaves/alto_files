--waterlily.mesa	Karen Kolling          	January 8, 1981  12:05 PMz20320l3316d2998e1(0,8480)(1,13696)(3,15552)(14,10795)\b17B13bz20320l3316d2998e1(1,65535)(3,65535)DIRECTORYz20320l3316d2998e1(0,65535)DisplayDefs: FROM "DisplayDefs"USING[DisplayOff, DisplayOn, SetSystemDisplaySize],z20320l3776d3392e1ImageDefs: FROM "ImageDefs"USING[MakeImage, StopMesa],z20320l3776d3392e1IODefs: FROM "IODefs"USING[ControlA, ControlH, ControlQ, ControlR, ControlW, ControlX, ControlZ, CR, NumberFormat, ReadEditedString, SP, SetInputStream, SetOutputStream, TAB, WriteChar, WriteLine, WriteNumber, WriteString],z20320l3776d3392e1SegmentDefs: FROM "SegmentDefs"USING[Append, FileNameError, Read, Write],z20320l3776d3392e1StreamDefs: FROM "StreamDefs"USING[CursorTrack, DiskHandle, DisplayHandle, GetDefaultDisplayStream, GetDefaultKey, KeyboardHandle, NewByteStream, StreamError, StreamHandle],z20320l3776d3392e1StringDefs: FROM "StringDefs"USING[AppendChar, AppendString, AppendSubString, StringBoundsFault, StringToNumber, SubStringDescriptor],z20320l3776d3392e1SystemDefs:  FROM "SystemDefs"USING [AllocateHeapNode, AllocateHeapString, AllocateSegment, FreeHeapNode, FreeHeapString, FreeSegment],z20320l3776d3392e1TimeDefs:  FROM "TimeDefs"USING [AppendFullDayTime, DefaultTime, UnpackDT];z20320l3776d3392e1z20320l3316d2998e1z20320l3316d2998e1waterlily: PROGRAM IMPORTS DisplayDefs, ImageDefs, IODefs, SegmentDefs, StreamDefs, StringDefs, SystemDefs, TimeDefs =z20320l3316d2998e1\b9BBEGINz20320l3316d2998e1z20320l3316d2998e1--part of this algorithm cribbed from Heckel, Paul.  A Technique For Isolating Differences Between Files.  Comm. ACM 21,4 (April 1978), 264-268.  Pointer to which courtesy of Ed Taft.z20320l3316d2998e1z20320l3316d2998e1Alarm: PROCEDURE = BEGIN AlarmCalled END;z20320l3316d2998e1\b5BAlarmCalled: SIGNAL = CODE;z20320l3316d2998e1z20320l3392d2998e1symbolTable: ARRAY [0..27) OF SymbolTableKey _ ALL[NIL];  --a thru z plus one other.z20320l3392d2998e1SymbolTableKey: TYPE = POINTER TO SymbolTableEntry;z20320l3392d2998e1SymbolTableEntry: TYPE = RECORD[left, right: SymbolTableKey, timesInOldFile, timesInNewFile: INTEGER, lineNumberInOldFile, lineNumberInNewFile: INTEGER, text: STRING];z20320l3392d2998e1SymbolTableProcedure: TYPE = PROCEDURE[pntr: SymbolTableKey];z20320l3392d2998e1z20320l3392d2998e1duplicateList: POINTER TO DuplicateRecord _ NIL;z20320l3392d2998e1DuplicateRecord: TYPE = RECORD[lineNum: INTEGER, symPntr: SymbolTableKey, nextDupRec: POINTER TO DuplicateRecord];z20320l3392d2998e1z20320l3392d2998e1oldArray: DESCRIPTOR FOR ARRAY [0..0) OF FileArrayEntry;z20320l3392d2998e1newArray: DESCRIPTOR FOR ARRAY [0..0) OF FileArrayEntry;z20320l3392d2998e1FileArrayEntry: TYPE = RECORD[symTablePntr: SymbolTableKey, lineNumInOtherFile: INTEGER, typeOfPntr: {symTable, lineNum}];z20320l3392d2998e1newArrayPntr, oldArrayPntr: POINTER;z20320l3392d2998e1totalLinesInNewFile: INTEGER _ 0;z20320l3392d2998e1totalLinesInOldFile: INTEGER _ 0;z20320l3392d2998e1z20320l3392d2998e1newFile: StreamDefs.DiskHandle;z20320l3392d2998e1oldFile: StreamDefs.DiskHandle;z20320l3392d2998e1difFile: StreamDefs.DiskHandle;z20320l3392d2998e1newFileName: STRING;z20320l3392d2998e1oldFileName: STRING;z20320l3392d2998e1difFileName: STRING;z20320l3392d2998e1z20320l3392d2998e1display: StreamDefs.DisplayHandle;z20320l3392d2998e1keyboard: StreamDefs.KeyboardHandle;z20320l3392d2998e1z20320l3392d2998e1Asterisks: STRING = "**************************************";z20320l3392d2998e1z20320l3392d2998e1--these switches are global or local.z20320l3392d2998e1switchBravoNewFile, switchBravoOldFile: BOOLEAN _ TRUE;z20320l3392d2998e1switchIgnoreEmptyLinesNewFile, switchIgnoreEmptyLinesOldFile: BOOLEAN _ TRUE;z20320l3392d2998e1z20320l3392d2998e1--these switches are global only.z20320l3392d2998e1switchLinesForMatch: INTEGER _ 3;z20320l3392d2998e1switchLinesForContext: INTEGER _ 1;z20320l3392d2998e1switchPause: BOOLEAN _ TRUE;z20320l3392d2998e1z20320l3392d2998e1anyDifferencesSeen: BOOLEAN _ FALSE;z20320l3392d2998e1indexN, indexO: INTEGER;z20320l3392d2998e1z20320l3392d2998e1SetSymbolTableEntry: PROCEDURE [nextLine: STRING, newOrOld: {new, old}, lineNumCurrentFile: INTEGER, leadingChar: CHARACTER] =z20320l3392d2998e1\b19BBEGINz20320l3392d3648e1index: CARDINAL _ (IF leadingChar IN ['A..'Z] THEN (leadingChar  - 'A) ELSE IF leadingChar IN ['a..'z] THEN (leadingChar  - 'a) ELSE 26);z20320l4288d3648e1pntr: SymbolTableKey _ symbolTable[index];z20320l4288d3648e1oldPntr: POINTER TO SymbolTableKey _ @symbolTable[index];z20320l4288d3648e1DOz20320l4662d3648e1IF pntr = NILz20320l4662d3648e1THEN GOTO notfoundz20320l5932d4918e1ELSEz20320l5932d4918e1SELECT CompareStrings[nextLine, pntr.text] FROMz20320l7202d6188e1greaterthan => oldPntr _ @pntr.right;z20320l7202d6656e1equalto => GOTO found;z20320l7202d6656e1lessthan => oldPntr _ @pntr.left;z20320l7202d6656e1ENDCASE => Alarm[];z20320l7202d6188e1pntr _ oldPntr^;z20320l4662d3648e1REPEATz20320l4662d3648e1notfound => BEGINz20320l4662d3648e1pntr _ SystemDefs.AllocateHeapNode[SIZE[SymbolTableEntry]];z20320l6528d6080e1pntr^ _ [left: NIL, right: NIL, timesInOldFile: (IF newOrOld = old THEN 1 ELSE 0), timesInNewFile: (IF newOrOld = new THEN 1 ELSE 0), lineNumberInOldFile: (IF newOrOld = old THEN lineNumCurrentFile ELSE 0), lineNumberInNewFile: (IF newOrOld = new THEN lineNumCurrentFile ELSE 0), text: ];z20320l6528d6080e1pntr.text _ SystemDefs.AllocateHeapString[nextLine.length];z20320l6528d6080e1StringDefs.AppendString[pntr.text, nextLine];z20320l6528d6080e1oldPntr^ _ pntr;z20320l6528d6080e1END;z20320l6528d6080e1found => BEGINz20320l4662d3648e1SELECT newOrOld FROMz20320l4662d5440e1new => BEGINz20320l8128d5920e1IF pntr.timesInNewFile = 0z20320l8128d7456e1THEN pntr.lineNumberInNewFile _ lineNumCurrentFilez20320l9398d8726e1ELSE EnterDuplicateRecord[pntr, lineNumCurrentFile];z20320l9398d8726e1IF pntr.timesInNewFile < 2 THEN pntr.timesInNewFile _ pntr.timesInNewFile + 1;z20320l8128d7456e1END;z20320l8128d7456e1old => BEGINz20320l7202d5920e1IF pntr.timesInOldFile = 0z20320l8128d7456e1THEN pntr.lineNumberInOldFile _ lineNumCurrentFilez20320l9398d8726e1ELSE EnterDuplicateRecord[pntr, lineNumCurrentFile];z20320l9398d8726e1IF pntr.timesInOldFile < 2 THEN pntr.timesInOldFile _ pntr.timesInOldFile + 1;z20320l7872d7200e1END;z20320l7872d7200e1ENDCASE => Alarm[];z20320l7872d5920e1END;z20320l4662d5440e1ENDLOOP;z20320l4662d3648e1END;z20320l3392d3648e1z20320l3392d2998e1\bz20320l3392d2998e1EnterDuplicateRecord: PROCEDURE [pntr: SymbolTableKey, lineNumCurrentFile: INTEGER] =z20320l3392d2998e1\b20BBEGINz20320l4192d3648e1tempDupRec: POINTER TO DuplicateRecord _ SystemDefs.AllocateHeapNode[SIZE[DuplicateRecord]];z20320l4192d3648e1tempDupRec.nextDupRec _ duplicateList;z20320l4192d3648e1duplicateList _ tempDupRec;z20320l4192d3648e1duplicateList.lineNum _ lineNumCurrentFile;z20320l4192d3648e1duplicateList.symPntr _ pntr;z20320l4192d3648e1END;z20320l4192d3648e1z20320l3392d2998e1ScanSymbolTable: PROCEDURE [Test: SymbolTableProcedure] =z20320l3392d2998e1\b15BBEGINz20320l3392d3648e1index: CARDINAL;z20320l3392d3648e1ProcessEntry: PROCEDURE[pntr: SymbolTableKey, Test: SymbolTableProcedure] =z20320l3392d3648e1BEGINz20320l3392d4256e1IF pntr = NIL THEN RETURN;z20320l6464d4256e1Test[pntr];z20320l3956d4256e1ProcessEntry[pntr.right, Test];z20320l5932d4256e1ProcessEntry[pntr.left, Test];z20320l5932d4256e1END;z20320l3392d4256e1FOR index IN [0..27) DO ProcessEntry[symbolTable[index], Test]; ENDLOOP;z20320l3392d3648e1END;z20320l3392d3648e1z20320l3392d2998e1CompareStrings: PROCEDURE [firstString, secondString: STRING] RETURNS [{greaterthan, equalto, lessthan}] =z20320l3392d2998e1\b14BBEGINz20320l3392d3648e1index: CARDINAL _ 0;z20320l3392d3648e1UNTIL ((index >= firstString.length) OR (index >= secondString.length))z20320l3392d3648e1DOz20320l3392d4192e1IF firstString[index] > secondString[index] THEN RETURN[greaterthan];z20320l3392d4192e1IF firstString[index] < secondString[index] THEN RETURN[lessthan];z20320l3392d4192e1index _ index + 1;z20320l3392d4192e1ENDLOOP;z20320l3392d4192e1IF firstString.length = secondString.length THEN RETURN[equalto];z20320l3392d3648e1IF firstString.length > secondString.length THEN RETURN[greaterthan];z20320l3392d3648e1RETURN[lessthan];z20320l3392d3648e1END;z20320l3392d3648e1z20320l3392d2998e1z20320l3392d2998e1--this routine has two functions: (1) to get the leading non-sp, non-tab character, and (2) to determine if the line should be skipped.z20320l3392d2998e1GetLeadingNonSemiBlankCharacter: PROCEDURE [line: STRING, localSwitchIgnoreEmpties: BOOLEAN] RETURNS [leadingChar: CHARACTER, skipLine: BOOLEAN] =z20320l3392d2998e1\b31BBEGINz20320l3392d3648e1index: CARDINAL _ 0;z20320l4662d3648e1WHILE index < line.lengthz20320l4662d3648e1DOz20320l4662d4256e1IF ((line[index] # IODefs.SP) AND (line[index] # IODefs.TAB)) THEN GOTO found;z20320l4662d4256e1index _ index + 1;z20320l4662d4256e1REPEAT found => RETURN[leadingChar: line[index], skipLine: FALSE];z20320l4662d4256e1ENDLOOP;z20320l4662d4256e1z20320l4662d3648e1--here on an "empty" line.z20320l4662d3648e1RETURN[leadingChar: IODefs.SP, skipLine: localSwitchIgnoreEmpties];z20320l4128d3648e1END;z20320l3392d3648e1z20320l3392d2998e1z20320l3392d2998e1\beof: SIGNAL = CODE;z20320l3392d2998e1ReadLineFromFile: PROCEDURE [InputFile: StreamDefs.DiskHandle, line: STRING, localSwitchBravo, localSwitchIgnoreEmpties: BOOLEAN] RETURNS [char: CHARACTER] =z20320l3392d2998e1\b16BBEGINz20320l3392d3648e1SignalEof: PROCEDURE = BEGIN eof END;z20320l3392d3648e1eofSeen: BOOLEAN _ FALSE;z20320l3392d3648e1skipLine: BOOLEAN;z20320l3392d3648e1z20320l3392d3648e1DOz20320l3392d3648e1line.length _ 0;z20320l3392d3648e1DOz20320l3392d4064e1IF InputFile.endof[InputFile] THEN GOTO saweof;z20320l5932d4064e1line[line.length] _ InputFile.get[InputFile];z20320l3392d4064e1IF (localSwitchBravo AND (line[line.length] = IODefs.ControlZ))z20320l4000d4064e1THENz20320l4662d4918e1DOz20320l8566d6198e1IF InputFile.endof[InputFile] THEN GOTO saweof;z20320l8566d6198e1IF InputFile.get[InputFile] = IODefs.CR THEN GOTO eoline;z20320l8566d6198e1ENDLOOP;z20320l8566d6198e1IF line[line.length] = IODefs.CR THEN EXIT;z20320l3392d4064e1line.length _ line.length + 1;z20320l3392d4064e1REPEATz20320l7008d4064e1saweof => IF line.length = 0 THEN SignalEof[] ELSE eofSeen _ TRUE;z20320l7008d4544e1eoline => NULL;z20320l7008d4544e1ENDLOOP;z20320l3392d4064e1[char, skipLine] _ GetLeadingNonSemiBlankCharacter[line, localSwitchIgnoreEmpties];z20320l4064d3648e1IF NOT skipLine THEN EXIT;z20320l3392d3648e1IF eofSeen THEN SignalEof[];z20320l3392d3648e1ENDLOOP;z20320l3392d3648e1z20320l3392d3648e1END;z20320l3392d3648e1z20320l3392d2998e1z20320l3392d2998e1LegalCharInFilename: PROCEDURE[char: CHARACTER] RETURNS[BOOLEAN] =z20320l3392d2998e1\b19BBEGINz20320l3392d3648e1SELECT char FROMz20320l3392d3648e1IN ['A..'Z], IN ['a..'z], IN ['0..'9], '+, '-, '., '!, '$ => RETURN[TRUE];z20320l3392d4128e1ENDCASE => RETURN[FALSE];z20320l3392d4128e1END;z20320l3392d3648e1z20320l3392d2998e1z20320l3392d2998e1\bSkipSpacesAndTabs: PROCEDURE[char: CHARACTER, InputStream: StreamDefs.StreamHandle] RETURNS[nextChar: CHARACTER] =z20320l3392d2998e1\b17BBEGINz20320l3392d3648e1nextChar _ char;z20320l3392d3648e1WHILE ((nextChar = IODefs.SP) OR (nextChar = IODefs.TAB))z20320l6476d3648e1DO nextChar _ InputStream.get[InputStream]; ENDLOOP;z20320l6476d4192e1END;z20320l3392d3648e1z20320l3392d3648e1TerminalHoHoDisplayOutput: PROCEDURE[string: STRING, pause: BOOLEAN] =z20320l3392d3008e1\b25BBEGINz20320l3392d3648e1IODefs.WriteChar[IODefs.CR];z20320l3392d3648e1IODefs.WriteLine[string];z20320l3392d3648e1IF pausez20320l3392d3648e1THENz20320l4662d4918e1BEGINz20320l5932d6188e1IODefs.WriteString["TYPE ANY CHARACTER TO EXIT: "L];z20320l5932d6188e1IODefs.SetInputStream[keyboard];z20320l5932d6188e1[] _ keyboard.get[keyboard];z20320l5932d6188e1END;z20320l5932d6188e1ImageDefs.StopMesa[];z20320l3392d3648e1END;z20320l3392d3648e1z20320l3392d2998e1OpenDifFileAndWriteHeader: PROCEDURE =z20320l3392d2998e1\b25BBEGINz20320l3392d3648e1dayTime: STRING _ [24];z20320l4416d3648e1subStr: StringDefs.SubStringDescriptor;z20320l4416d3648e1index: CARDINAL _ 0;z20320l4416d3648e1DOz20320l4416d4128e1IF ((index >= oldFileName.length) OR (oldFileName[index] = '.)) THEN EXIT;z20320l4416d4128e1index _ index + 1;z20320l4416d4128e1ENDLOOP;z20320l4416d4128e1difFileName _ SystemDefs.AllocateHeapString[index + 4];z20320l4416d3648e1subStr _ [oldFileName, 0, index];z20320l4416d3648e1StringDefs.AppendSubString[difFileName, @subStr];z20320l4416d3648e1StringDefs.AppendString[difFileName, ".dif"];z20320l4416d3648e1difFile _ StreamDefs.NewByteStream[difFileName, SegmentDefs.Write + SegmentDefs.Append];z20320l4416d3648e1IODefs.SetOutputStream[difFile];z20320l4416d3648e1TimeDefs.AppendFullDayTime[dayTime, TimeDefs.UnpackDT[TimeDefs.DefaultTime]]; --current time.z20320l4416d3648e1IODefs.WriteString["Waterlily                          Version 1.6                             "]; IODefs.WriteLine[dayTime];z20320l4416d3648e1IODefs.WriteString["Differences between files "]; IODefs.WriteString[oldFileName]; IODefs.WriteString[" and "]; IODefs.WriteString[newFileName]; IODefs.WriteLine[":"]; IODefs.WriteChar[IODefs.CR];z20320l4416d3648e1END;z20320l3392d3648e1z20320l3392d2998e1FinishUp: PROCEDURE[openDifFile, writeAndCloseDifFile: BOOLEAN, difMsg: STRING, displayMsg: STRING, pause: BOOLEAN] =z20320l3392d2998e1\b8BBEGINz20320l3392d3648e1IF openDifFile THEN OpenDifFileAndWriteHeader[];z20320l4416d3648e1IF writeAndCloseDifFilez20320l4416d3648e1THENz20320l5686d4918e1BEGINz20320l6956d6188e1IODefs.WriteLine[difMsg];z20320l6956d6188e1difFile.destroy[difFile];z20320l6956d6188e1END;z20320l6956d6188e1DisplayDefs.DisplayOn[];z20320l4416d3648e1IODefs.SetOutputStream[display];z20320l4416d3648e1TerminalHoHoDisplayOutput[displayMsg, pause];z20320l4416d3648e1END;z20320l4416d3648e1z20320l3392d3008e1TotalNStepsCursor: CARDINAL _ 9;z20320l3392d3008e1CenterX: CARDINAL _ (605/2) - 8;z20320l3392d3008e1YOffset: CARDINAL _ 20; -- must be >= 16.z20320l3392d3008e1CursorYInitial: CARDINAL _ 807 - YOffset;z20320l3392d3008e1CursorYFinal: CARDINAL _ YOffset - 16;z20320l3392d3008e1CursorYInc: CARDINAL _ (CursorYInitial - CursorYFinal)/TotalNStepsCursor;z20320l3392d3008e1currentStepCursor: CARDINAL _ 0;z20320l3392d3008e1cursorX: POINTER TO CARDINAL = LOOPHOLE[426B];z20320l3392d3008e1cursorY:  POINTER TO CARDINAL = LOOPHOLE[427B];z20320l3392d3008e1z20320l3392d3008e1InitializeCursor: PROCEDURE =z20320l3392d3008e1\b16BBEGINz20320l3392d3648e1cursorPntrs: ARRAY [0..16) OF POINTER TO CARDINAL = [LOOPHOLE[431B], LOOPHOLE[432B], LOOPHOLE[433B], LOOPHOLE[434B], LOOPHOLE[435B], LOOPHOLE[436B], LOOPHOLE[437B], LOOPHOLE[440B], LOOPHOLE[441B], LOOPHOLE[442B], LOOPHOLE[443B], LOOPHOLE[444B], LOOPHOLE[445B], LOOPHOLE[446B], LOOPHOLE[447B], LOOPHOLE[450B]];z20320l4096d3648e1cursorValues: ARRAY [0..16) OF CARDINAL = [105757B, 104211B, 104211B, 104217B, 124214B, 124212B, 174211B, 0B, 102042B, 102042B, 102024B, 102024B, 102010B, 102010B, 173610B, 0B];z20320l4096d3648e1index: CARDINAL;z20320l4096d3648e1StreamDefs.CursorTrack[FALSE];z20320l3392d3648e1cursorX^ _ CenterX;z20320l3392d3648e1cursorY^ _ CursorYInitial;z20320l3392d3648e1FOR index IN [0..16)z20320l3392d3648e1DOz20320l3392d4128e1cursorPntrs[index]^ _ cursorValues[index];z20320l3392d4128e1ENDLOOP;z20320l3392d4128e1END;z20320l3392d3648e1z20320l3392d2998e1StepCursor: PROCEDURE =z20320l3392d3008e1\b10BBEGINz20320l3392d3648e1currentStepCursor _ currentStepCursor + 1;z20320l3392d3648e1IF currentStepCursor > TotalNStepsCursor THEN Alarm[];z20320l3392d3648e1cursorY^ _ cursorY^ - CursorYInc;z20320l3392d3648e1END;z20320l3392d3648e1z20320l3392d2998e1z20320l3392d2998e1ReadComDotCmOrPrompt: PROCEDURE =z20320l3392d3008e1\b20BBEGINz20320l3392d3488e1comDotCm: StreamDefs.DiskHandle _ StreamDefs.NewByteStream["com.cm"L, SegmentDefs.Read];z20320l3936d3488e1newFileSeen, oldFileSeen: BOOLEAN _ FALSE;z20320l3936d3488e1SignalSyntaxError: PROCEDURE = BEGIN SyntaxError END;z20320l3936d3488e1SyntaxError: SIGNAL = CODE;z20320l3936d3488e1z20320l3936d3488e1ProcessGlobalSwitches: PROCEDURE[char: CHARACTER] RETURNS[nextChar: CHARACTER] =z20320l3936d3488e1BEGINz20320l3936d3872e1DOz20320l3936d3872e1IF char = '/ THEN char _ comDotCm.get[comDotCm];z20320l3936d3872e1SELECT char FROMz20320l6476d3872e1'H, 'h => BEGINz20320l6476d4352e1DisplayDefs.SetSystemDisplaySize[nTextLines: 30, nPages: 25]; -- 25  is a guess that seems to work.z20320l6336d6048e1TerminalHoHoDisplayOutput["This is the format of the command line:Waterlily <globalswitches> filename1<localswitches> filename2<localswitches>where the global switches acceptable are:b        bravo format files.  everything between ^Z and CR is ignored. default = TRUE.i         ignore blank and empty lines. default = TRUE.p        on empty file or no difs encountered, pause instead of writing dif file. default = TRUE./#m    number of lines to consider a match. default = 3./#c     number of trailing lines to output for context. default = 1.The local switches acceptable are b and i.Examples of command lines are:Waterlily  file1  file2Waterlily /-b  foo1  foo2Waterlily /6m  foo1/-b  foo2/-b-iWaterlily             (this form will prompt for the filenames.)The differences found are written on the file filename1.dif."L, TRUE];z20320l6336d6048e1END;z20320l6336d6048e1'b, 'B => BEGINz20320l6476d4352e1switchBravoNewFile _ TRUE; switchBravoOldFile _ TRUE;z20320l6476d6048e1END;z20320l6476d6048e1'p, 'P => BEGIN switchPause _ TRUE; END;z20320l6476d4352e1 'i, 'I => BEGINz20320l6476d4352e1switchIgnoreEmptyLinesNewFile _ TRUE; switchIgnoreEmptyLinesOldFile _ TRUE;z20320l6476d5920e1END;z20320l6476d5920e1'- => BEGINz20320l6476d4352e1char _ comDotCm.get[comDotCm];z20320l6476d5408e1SELECT char FROMz20320l6476d5408e1'b, 'B => BEGINz20320l6476d5888e1switchBravoNewFile _ FALSE; switchBravoOldFile _ FALSE;z20320l7488d7584e1END;z20320l6476d7584e1'i, 'I => BEGINz20320l6476d5888e1switchIgnoreEmptyLinesNewFile _ FALSE; switchIgnoreEmptyLinesOldFile _ FALSE;z20320l7488d7296e1END;z20320l6476d7584e1'p, 'P => BEGIN switchPause _ FALSE; END;z20320l6476d5888e1ENDCASE => SignalSyntaxError[];z20320l6476d5888e1END;z20320l6476d5408e1IN ['0..'9] => BEGINz20320l6476d4352e1number: CARDINAL;z20320l8864d6912e1numberString: STRING _ [5];z20320l8864d6912e1WHILE char IN ['0..'9]z20320l8864d6912e1DOz20320l8864d7520e1IF numberString.length > 5 THEN SignalSyntaxError[];z20320l8864d7520e1numberString[numberString.length] _ char;z20320l8864d7520e1numberString.length _ numberString.length + 1;z20320l8864d7520e1char _ comDotCm.get[comDotCm];z20320l8864d7520e1ENDLOOP;z20320l8864d7520e1number _ StringDefs.StringToNumber[numberString, 10 ! ANY => SignalSyntaxError[]];z20320l7360d6912e1SELECT char FROMz20320l8864d6912e1'm, 'M => BEGINz20320l10134d7392e1IF number <1 THEN Alarm[];z20320l8864d9248e1switchLinesForMatch _ number;z20320l10134d9248e1END;z20320l10134d9248e1'c, 'C => switchLinesForContext _ number;z20320l8864d7392e1ENDCASE => SignalSyntaxError[];z20320l8864d7392e1END;z20320l8864d6912e1ENDCASE => SignalSyntaxError[];z20320l6476d4352e1char _ comDotCm.get[comDotCm];z20320l6476d3872e1SELECT char FROMz20320l6476d3872e1'-, 'b, 'B, 'h, 'H, 'i, 'I, 'p, 'P, '/, IN ['0..'9] => LOOP;z20320l6476d4352e1IODefs.SP, IODefs.TAB => BEGINz20320l6476d4352e1char _ SkipSpacesAndTabs[char, comDotCm];z20320l9632d9376e1IF (char = '/)z20320l9632d9376e1THEN LOOPz20320l10902d10646e1ELSE RETURN[char];z20320l10902d10646e1END;z20320l6476d9376e1ENDCASE => RETURN[char];z20320l6476d4352e1ENDLOOP;z20320l6476d3872e1END;z20320l3936d3872e1z20320l3936d3488e1ProcessLocalSwitches: PROCEDURE [switchBravo, switchIgnore: POINTER TO BOOLEAN] RETURNS[nextChar: CHARACTER] =z20320l3712d3488e1BEGINz20320l3936d3872e1nextChar _ comDotCm.get[comDotCm];z20320l3936d3872e1DOz20320l3936d3872e1SELECT nextChar FROMz20320l3936d3872e1'b, 'B => switchBravo^ _ TRUE;z20320l6476d4352e1 'i, 'I => switchIgnore^ _ TRUE;z20320l6476d4352e1'- => BEGINz20320l6476d4352e1nextChar _ comDotCm.get[comDotCm];z20320l6476d5408e1SELECT nextChar FROMz20320l6476d5408e1'b, 'B => switchBravo^ _ FALSE;z20320l6476d5888e1'i, 'I => switchIgnore^ _ FALSE;z20320l6476d5888e1ENDCASE => SignalSyntaxError[];z20320l6476d5888e1END;z20320l6476d5408e1ENDCASE => SignalSyntaxError[];z20320l6476d4352e1nextChar _ comDotCm.get[comDotCm];z20320l6476d3872e1SELECT nextChar FROMz20320l6476d3872e1'/ => nextChar _ comDotCm.get[comDotCm];z20320l6476d4352e1'-, 'b, 'B, 'i, 'I => NULL;z20320l6476d4352e1ENDCASE => RETURN[nextChar];z20320l6476d4352e1ENDLOOP;z20320l3936d3872e1END;z20320l3936d3872e1z20320l3936d3488e1z20320l3936d3488e1FileNotAccessible: SIGNAL = CODE;z20320l3936d3488e1z20320l3936d3488e1OpenFile: PROCEDURE[fileSeen: POINTER TO BOOLEAN, tempFileName: STRING, fileName: POINTER TO STRING, file: POINTER TO StreamDefs.DiskHandle] =z20320l3712d3488e1BEGINz20320l4224d3872e1SignalFileNotAccessible: PROCEDURE = BEGIN FileNotAccessible END;z20320l4224d3872e1file^ _ StreamDefs.NewByteStream[tempFileName, SegmentDefs.Read ! SegmentDefs.FileNameError => SignalFileNotAccessible[]];z20320l4224d3872e1fileName^ _ SystemDefs.AllocateHeapString[tempFileName.length];z20320l4224d3872e1StringDefs.AppendString[fileName^, tempFileName];z20320l4224d3872e1fileSeen^ _ TRUE;z20320l4224d3872e1END;z20320l4224d3872e1z20320l3936d3488e1ProcessFilename: PROCEDURE[char: CHARACTER] RETURNS[nextChar: CHARACTER] =z20320l3936d3488e1BEGINz20320l3936d3872e1tempFileName: STRING _ [100];z20320l5738d3872e1IF newFileSeen AND oldFileSeen THEN SignalSyntaxError[];z20320l3936d3872e1--guaranteed at least one legal char on entry.z20320l4320d3872e1nextChar _ char;z20320l4320d3872e1WHILE LegalCharInFilename[nextChar]z20320l3936d3872e1DOz20320l3936d4480e1StringDefs.AppendChar[tempFileName, nextChar];z20320l6476d4480e1nextChar _ comDotCm.get[comDotCm];z20320l6476d4480e1ENDLOOP;z20320l3936d4480e1IF NOT oldFileSeenz20320l3936d3872e1THENz20320l5738d5142e1BEGINz20320l7008d6412e1OpenFile[@oldFileSeen, tempFileName, @oldFileName, @oldFile];z20320l7008d6412e1IF nextChar = '/ THEN nextChar _ ProcessLocalSwitches[@switchBravoOldFile, @switchIgnoreEmptyLinesOldFile];z20320l7008d6412e1ENDz20320l7008d6412e1ELSEz20320l8278d5152e1BEGINz20320l9548d6422e1OpenFile[@newFileSeen, tempFileName, @newFileName, @newFile];z20320l7008d6422e1IF nextChar = '/ THEN nextChar _ ProcessLocalSwitches[@switchBravoNewFile, @switchIgnoreEmptyLinesNewFile];z20320l7008d6432e1END;z20320l6476d6432e1nextChar _ SkipSpacesAndTabs[nextChar, comDotCm];z20320l6476d3872e1END;z20320l3936d3872e1z20320l3936d3488e1Prompt: PROCEDURE =z20320l3936d3488e1BEGINz20320l3936d3872e1PromptForFile: PROCEDURE[typeOfFile: STRING, fileSeen: POINTER TO BOOLEAN, fileName: POINTER TO STRING, file: POINTER TO StreamDefs.DiskHandle, switchBravo, switchIgnore: POINTER TO BOOLEAN] =z20320l4096d3872e1BEGINz20320l3936d4256e1tempFileName: STRING _ [100];z20320l3936d4256e1nextChar: CHARACTER;z20320l3936d4256e1EditedCharCheck: PROCEDURE[char: CHARACTER] RETURNS[BOOLEAN] =z20320l3936d4256e1BEGINz20320l5568d4800e1RETURN[NOT ((LegalCharInFilename[char]) OR (char = IODefs.ControlH) OR (char = IODefs.ControlA) OR (char = IODefs.ControlW) OR (char = IODefs.ControlQ) OR (char = IODefs.ControlX) OR (char = IODefs.ControlR))];z20320l5568d4800e1END;z20320l5568d4800e1IODefs.SetInputStream[keyboard];z20320l3936d4256e1DOz20320l3936d4256e1BEGINz20320l3936d4256e1ENABLEz20320l6336d4256e1BEGINz20320l7606d5526e1StringDefs.StringBoundsFault => GOTO err;z20320l7606d5526e1StreamDefs.StreamError => IF error = StreamAccess THEN GOTO err;z20320l7606d5526e1END;z20320l7606d5526e1IODefs.WriteString[""L]; IODefs.WriteString[typeOfFile]; IODefs.WriteString[" file: "L];z20320l4768d4256e1tempFileName.length _ 0;z20320l4544d4256e1nextChar _ IODefs.ReadEditedString[tempFileName, EditedCharCheck, TRUE];z20320l4544d4256e1IF ((tempFileName.length = 0) OR (nextChar # IODefs.CR)) THEN GOTO err;z20320l4544d4256e1OpenFile[fileSeen, tempFileName, fileName, file! FileNotAccessible => GOTO err];z20320l4544d4256e1EXIT;z20320l4544d4256e1EXITS err => IODefs.WriteString["File not found or syntax error"L];z20320l6656d4256e1END;z20320l3936d4256e1ENDLOOP;END;z20320l3936d4256e1IF NOT oldFileSeenz20320l3936d3872e1THEN PromptForFile["Old"L, @oldFileSeen, @oldFileName, @oldFile, @switchBravoOldFile, @switchIgnoreEmptyLinesOldFile];z20320l5578d5142e1IF NOT newFileSeenz20320l3936d3872e1THEN PromptForFile["New"L, @newFileSeen, @newFileName, @newFile, @switchBravoNewFile, @switchIgnoreEmptyLinesNewFile];z20320l5578d5142e1IODefs.WriteString[""L]; z20320l4308d3872e1END;z20320l3936d3872e1z20320l3936d3488e1z20320l3936d3488e1BEGINz20320l3936d3488e1ENABLEz20320l3936d3488e1BEGINz20320l3936d4000e1StreamDefs.StreamError => IF error = StreamAccess THEN TerminalHoHoDisplayOutput["Syntax error.", TRUE];z20320l4832d4000e1FileNotAccessible => TerminalHoHoDisplayOutput["File not found.", TRUE];z20320l4832d4000e1SyntaxError => TerminalHoHoDisplayOutput["Syntax error.", TRUE];z20320l4832d4000e1END;z20320l3936d4000e1char: CHARACTER _ IODefs.SP;z20320l3936d3488e1char _ SkipSpacesAndTabs[char, comDotCm];z20320l3936d3488e1WHILE LegalCharInFilename[char]z20320l3936d3488e1DO char _ comDotCm.get[comDotCm]; ENDLOOP; --skip past some form of "Waterlily".z20320l3936d4032e1char _ SkipSpacesAndTabs[char, comDotCm];z20320l3936d3488e1IF (char = '/) THEN char _ ProcessGlobalSwitches[char];z20320l3936d3488e1IF LegalCharInFilename[char] THEN char _ ProcessFilename[char];z20320l3936d3488e1IF LegalCharInFilename[char] THEN char _ ProcessFilename[char];z20320l3936d3488e1char _ SkipSpacesAndTabs[char, comDotCm];z20320l6476d3488e1IF ((char # IODefs.CR) AND (char # ';)) THEN SignalSyntaxError[];z20320l3936d3488e1comDotCm.destroy[comDotCm];z20320l3936d3488e1END;z20320l3936d3488e1IF NOT (newFileSeen AND oldFileSeen) THEN Prompt[]; --does its own error checking since it can recover.z20320l3936d3488e1END;z20320l3936d3008e1z20320l3392d2998e1z20320l3392d2998e1--  main body of module.z20320l3392d2998e1z20320l3392d2998e1ImageDefs.MakeImage["Waterlily.image"];z20320l3936d3008e1display _ StreamDefs.GetDefaultDisplayStream[];z20320l3392d3008e1keyboard _ StreamDefs.GetDefaultKey[];z20320l3392d3008e1z20320l3392d2998e1IODefs.SetOutputStream[display]; --we don't stream out to anything but the display until writing into the dif file.z20320l3392d2998e1display.put[display, IODefs.CR]; -- avoid mesa bug in typescript handling involving image files.z20320l3392d3008e1ReadComDotCmOrPrompt[];z20320l3392d3008e1DisplayDefs.DisplayOff[black];z20320l3392d3008e1InitializeCursor[];z20320l3392d3008e1z20320l3392d3008e1z20320l3936d3008e1BEGINz20320l3936d3008e1z20320l3936d3008e1ScanDuplicateList: PROCEDURE[array: DESCRIPTOR FOR ARRAY [0..0) OF FileArrayEntry] =z20320l3392d3008e1BEGINz20320l3936d3488e1tempDuplicateList: POINTER TO DuplicateRecord;z20320l3936d3488e1UNTIL duplicateList = NILz20320l3392d3488e1DOz20320l3392d4032e1array[duplicateList.lineNum] _ [symTablePntr: duplicateList.symPntr, lineNumInOtherFile: 0, typeOfPntr: symTable];z20320l4352d4032e1tempDuplicateList _ duplicateList;z20320l4352d4032e1duplicateList _ duplicateList.nextDupRec;z20320l4352d4032e1SystemDefs.FreeHeapNode[tempDuplicateList];z20320l4352d4032e1ENDLOOP;z20320l3392d4032e1END;z20320l3936d3488e1z20320l3936d3488e1--Pass 1.z20320l3392d2998e1nextLine: STRING _ SystemDefs.AllocateHeapString[1500];z20320l3392d2998e1leadingChar: CHARACTER;z20320l3392d2998e1DOz20320l3392d2998e1leadingChar _ ReadLineFromFile[newFile, nextLine, switchBravoNewFile, switchIgnoreEmptyLinesNewFile ! eof => GOTO donewithfile];z20320l3392d2998e1SetSymbolTableEntry[nextLine, new, totalLinesInNewFile, leadingChar];z20320l3392d2998e1totalLinesInNewFile _ totalLinesInNewFile + 1;z20320l3392d2998e1REPEAT donewithfile => IF totalLinesInNewFile = 0 THEN GOTO emptyfile;z20320l3392d2998e1ENDLOOP;z20320l3392d2998e1StepCursor[];z20320l3392d3008e1z20320l3392d2998e1z20320l3392d2998e1--Pass 1 and 1/2.z20320l3392d2998e1newArrayPntr _ SystemDefs.AllocateSegment[totalLinesInNewFile*SIZE[FileArrayEntry]];z20320l3392d2998e1newArray _ DESCRIPTOR[newArrayPntr, totalLinesInNewFile];z20320l3392d2998e1z20320l3392d2998e1BEGINz20320l3392d2998e1Test: SymbolTableProcedure =z20320l3392d2998e1BEGINz20320l3392d3488e1IF (pntr.timesInNewFile >= 1) THEN newArray[pntr.lineNumberInNewFile] _ [symTablePntr: pntr, lineNumInOtherFile: 0, typeOfPntr: symTable];z20320l3968d3488e1END;z20320l3392d3488e1ScanSymbolTable[Test];z20320l3392d2998e1END;z20320l3392d2998e1z20320l3392d2998e1ScanDuplicateList[newArray];z20320l3392d3008e1StepCursor[];z20320l3392d3008e1z20320l3392d2998e1z20320l3392d2998e1--Pass 2.z20320l3392d2998e1DOz20320l3392d2998e1leadingChar _ ReadLineFromFile[oldFile, nextLine, switchBravoOldFile, switchIgnoreEmptyLinesOldFile ! eof => GOTO donewithfile];z20320l3392d2998e1SetSymbolTableEntry[nextLine, old, totalLinesInOldFile, leadingChar];z20320l3392d2998e1totalLinesInOldFile _ totalLinesInOldFile + 1;z20320l3392d2998e1REPEAT donewithfile => IF totalLinesInOldFile = 0 THEN GOTO emptyfile;z20320l3392d2998e1ENDLOOP;z20320l3392d2998e1SystemDefs.FreeHeapString[nextLine];z20320l3392d2998e1StepCursor[];z20320l3392d3008e1z20320l3392d2998e1z20320l3392d2998e1--Pass 2 and 1/2.z20320l3392d2998e1oldArrayPntr _ SystemDefs.AllocateSegment[totalLinesInOldFile*SIZE[FileArrayEntry]];z20320l3392d2998e1oldArray _ DESCRIPTOR[oldArrayPntr, totalLinesInOldFile];z20320l3392d2998e1z20320l3392d2998e1BEGINz20320l3392d2998e1Test: SymbolTableProcedure =z20320l3392d2998e1BEGINz20320l6464d3488e1IF (pntr.timesInOldFile >= 1) THEN oldArray[pntr.lineNumberInOldFile] _ [symTablePntr: pntr, lineNumInOtherFile: 0, typeOfPntr: symTable];z20320l3956d3488e1END;z20320l3392d3488e1ScanSymbolTable[Test];z20320l3392d2998e1END;z20320l3392d2998e1z20320l3392d2998e1ScanDuplicateList[oldArray];z20320l3392d3008e1StepCursor[];z20320l3936d3008e1z20320l3936d3008e1EXITS emptyfile => FinishUp[openDifFile: (NOT switchPause), writeAndCloseDifFile: (NOT switchPause), difMsg: "At least one of these files is effectively empty.", displayMsg: "At least one of these files is effectively empty.", pause: switchPause];z20320l7200d3008e1END;z20320l3936d3008e1z20320l3392d2998e1z20320l3392d2998e1--Pass 3.z20320l3392d2998e1BEGINz20320l3392d2998e1Test: SymbolTableProcedure =z20320l3392d2998e1BEGINz20320l6464d3488e1IF ((pntr.timesInOldFile = 1) AND (pntr.timesInNewFile = 1))z20320l6464d3488e1THENz20320l12282d4758e1BEGINz20320l6496d6028e1newArray[pntr.lineNumberInNewFile].typeOfPntr _ lineNum;z20320l6496d6028e1newArray[pntr.lineNumberInNewFile].lineNumInOtherFile _ pntr.lineNumberInOldFile;z20320l6496d6028e1oldArray[pntr.lineNumberInOldFile].typeOfPntr _ lineNum;z20320l6496d6028e1oldArray[pntr.lineNumberInOldFile].lineNumInOtherFile _ pntr.lineNumberInNewFile;z20320l6496d6028e1END;z20320l6496d6028e1END;z20320l3392d3488e1z20320l3392d2998e1ScanSymbolTable[Test];z20320l3392d3008e1END;z20320l3392d3008e1StepCursor[];z20320l3392d3008e1z20320l3392d2998e1z20320l3392d2998e1--Pass 4.z20320l3392d2998e1indexN _ 0;z20320l3392d3008e1WHILE indexN < totalLinesInNewFilez20320l3392d3008e1DOz20320l3392d3744e1IF (newArray[indexN].typeOfPntr = lineNum)z20320l3392d3744e1THENz20320l7202d5014e1BEGINz20320l9742d6284e1indexO _ newArray[indexN].lineNumInOtherFile + 1;z20320l6688d6272e1indexN _ indexN + 1;z20320l6688d6272e1WHILE ((indexN < totalLinesInNewFile) AND (indexO < totalLinesInOldFile))z20320l6688d6272e1DOz20320l7202d7008e1IF ((newArray[indexN].typeOfPntr = symTable) AND (oldArray[indexO].typeOfPntr = symTable) AND (newArray[indexN].symTablePntr = oldArray[indexO].symTablePntr))z20320l7680d7008e1THENz20320l10220d8278e1BEGINz20320l12760d9548e1newArray[indexN].typeOfPntr _ lineNum;z20320l12760d9548e1oldArray[indexO].typeOfPntr _ lineNum;z20320l12760d9548e1newArray[indexN].lineNumInOtherFile _ indexO;z20320l12760d9548e1oldArray[indexO].lineNumInOtherFile _ indexN;z20320l12760d9548e1ENDz20320l12760d9548e1ELSE IF ((newArray[indexN].typeOfPntr # lineNum) OR (oldArray[indexO].typeOfPntr # lineNum) OR (newArray[indexN].lineNumInOtherFile # indexO) OR (oldArray[indexO].lineNumInOtherFile # indexN)) THEN GOTO endofthisset;z20320l10220d8278e1indexN _ indexN + 1;z20320l7202d7008e1indexO _ indexO + 1;z20320l7202d7008e1REPEAT endofthisset => NULL;z20320l7202d7008e1ENDLOOP;z20320l7202d7008e1ENDz20320l7202d6272e1ELSE indexN _ indexN + 1;z20320l7202d5014e1ENDLOOP;z20320l3392d3744e1StepCursor[];z20320l3392d3008e1z20320l3392d2998e1z20320l3392d2998e1--Pass 5.z20320l3392d2998e1indexN _ totalLinesInNewFile - 1;z20320l3392d3008e1WHILE indexN >= 0z20320l3392d3008e1DOz20320l3392d3744e1IF (newArray[indexN].typeOfPntr = lineNum)z20320l3392d3744e1THENz20320l7202d5014e1BEGINz20320l9742d6284e1indexO _ newArray[indexN].lineNumInOtherFile - 1;z20320l7202d6272e1indexN _ indexN - 1;z20320l7202d6272e1WHILE ((indexN >= 0) AND (indexO >= 0))z20320l6976d6272e1DOz20320l7328d6880e1IF ((newArray[indexN].typeOfPntr = symTable) AND (oldArray[indexO].typeOfPntr = symTable) AND (newArray[indexN].symTablePntr = oldArray[indexO].symTablePntr))z20320l7328d6880e1THENz20320l10220d8150e1BEGINz20320l11490d9430e1newArray[indexN].typeOfPntr _ lineNum;z20320l11490d9430e1oldArray[indexO].typeOfPntr _ lineNum;z20320l11490d9430e1newArray[indexN].lineNumInOtherFile _ indexO;z20320l11490d9430e1oldArray[indexO].lineNumInOtherFile _ indexN;z20320l11490d9430e1ENDz20320l11490d9430e1ELSE IF ((newArray[indexN].typeOfPntr # lineNum) OR (oldArray[indexO].typeOfPntr # lineNum) OR (newArray[indexN].lineNumInOtherFile # indexO) OR (oldArray[indexO].lineNumInOtherFile # indexN)) THEN GOTO endofthisset;z20320l8950d8160e1indexN _ indexN - 1;z20320l7202d6880e1indexO _ indexO - 1;z20320l7202d6880e1REPEAT endofthisset => NULL;z20320l7202d6880e1ENDLOOP;z20320l7202d6880e1ENDz20320l7202d6272e1ELSE indexN _ indexN - 1;z20320l5932d5024e1ENDLOOP;z20320l3392d3744e1StepCursor[];z20320l3392d3008e1z20320l3392d3008e1z20320l3392d2998e1--Passes 6 and 7.z20320l3392d2998e1BEGINz20320l3392d2998e1CancelMatch: PROCEDURE[array1, array2: DESCRIPTOR FOR ARRAY [0..0) OF FileArrayEntry, totalNumOfLinesFile1, index: INTEGER] =z20320l3392d2998e1BEGINz20320l3392d3552e1UNTIL (array1[index].typeOfPntr = symTable)z20320l4000d3552e1DOz20320l3392d4032e1array1[index].typeOfPntr _ symTable;z20320l4480d4032e1array2[array1[index].lineNumInOtherFile].typeOfPntr _ symTable;z20320l4480d4032e1index _ index + 1;z20320l4480d4032e1IF ((index >= totalNumOfLinesFile1) OR (array1[index].lineNumInOtherFile # array1[index - 1].lineNumInOtherFile + 1)) THEN EXIT;z20320l4480d4032e1ENDLOOP;z20320l3392d4032e1END;z20320l3392d3552e1z20320l3392d2998e1--Pass 6.z20320l3392d2998e1IF switchLinesForMatch > 1z20320l3392d2998e1THENz20320l4662d4268e1BEGINz20320l5932d5538e1indexN _ 0;z20320l5932d5538e1WHILE (indexN < totalLinesInNewFile)z20320l5932d5538e1DOz20320l7202d6156e1IF newArray[indexN].typeOfPntr = lineNumz20320l7202d6156e1THENz20320l8472d7426e1BEGINz20320l9742d8696e1oldIndexN: INTEGER _ indexN;z20320l9742d8696e1indexN _ indexN + 1;z20320l9742d8696e1WHILE ((indexN < totalLinesInNewFile) AND (newArray[indexN].lineNumInOtherFile = newArray[indexN - 1].lineNumInOtherFile + 1))z20320l9004d8696e1DO indexN _ indexN + 1; ENDLOOP;z20320l9742d9324e1IF (((indexN - oldIndexN) < switchLinesForMatch) AND (indexN < totalLinesInNewFile)) THEN CancelMatch[newArray, oldArray, totalLinesInNewFile, oldIndexN];z20320l9742d8696e1ENDz20320l9742d8696e1ELSE indexN _ indexN + 1;z20320l8472d7426e1ENDLOOP;z20320l5932d6156e1END;z20320l5932d5538e1StepCursor[];z20320l3392d2998e1z20320l3392d2998e1--Pass 7.z20320l3392d2998e1BEGINz20320l3392d2998e1DumpOutDiffAndMoveAhead: PROCEDURE =z20320l3392d2998e1BEGINz20320l3392d3552e1index: INTEGER;z20320l3392d3552e1LeadingNumber: PROCEDURE[char: CHARACTER, number: INTEGER] =z20320l3392d3552e1BEGINz20320l3392d3968e1IODefs.WriteChar[char]; IODefs.WriteChar['/]; IODefs.WriteNumber[index, numFormat]; IODefs.WriteString[") "];z20320l4352d3968e1END;z20320l3392d3968e1z20320l3392d3968e1IF NOT anyDifferencesSeenz20320l3392d3552e1THENz20320l4662d4822e1BEGINz20320l5932d6092e1OpenDifFileAndWriteHeader[];z20320l6560d6092e1IODefs.WriteString[Asterisks]; IODefs.WriteLine[Asterisks];z20320l6560d6092e1anyDifferencesSeen _ TRUE;z20320l5932d6092e1END;z20320l5932d6092e1IF ((indexN >= totalLinesInNewFile) OR (indexO >= totalLinesInOldFile))z20320l3392d3552e1THENz20320l4662d4822e1BEGINz20320l5932d6092e1indexN _ totalLinesInNewFile;z20320l5932d6092e1indexO _ totalLinesInOldFile;z20320l5932d6092e1ENDz20320l5932d6092e1ELSEz20320l4662d4822e1IF newArray[indexN].typeOfPntr = lineNumz20320l5932d6092e1THEN indexO _ newArray[indexN].lineNumInOtherFilez20320l7202d7362e1ELSE indexN _ oldArray[indexO].lineNumInOtherFile;z20320l7202d7362e1z20320l5932d6092e1FOR index IN [startDifO..indexO)z20320l3392d3552e1DO LeadingNumber['1, index]; IODefs.WriteLine[oldArray[index].symTablePntr.text]; ENDLOOP;z20320l4608d4032e1FOR index IN [indexO..indexO + switchLinesForContext)z20320l3392d3552e1WHILE (index < totalLinesInOldFile)z20320l3392d4032e1DO LeadingNumber['1, index]; IODefs.WriteLine[oldArray[index].symTablePntr.text]; ENDLOOP;z20320l4608d4032e1IODefs.WriteLine[Asterisks];z20320l3392d3552e1FOR index IN [startDifN..indexN)z20320l3392d3552e1DO LeadingNumber['2, index]; IODefs.WriteLine[newArray[index].symTablePntr.text]; ENDLOOP;z20320l4608d4032e1FOR index IN [indexN..indexN + switchLinesForContext)z20320l3392d3552e1WHILE (index < totalLinesInNewFile)z20320l3392d4032e1DO LeadingNumber['2, index]; IODefs.WriteLine[newArray[index].symTablePntr.text]; ENDLOOP;z20320l4608d4032e1IODefs.WriteString[Asterisks]; IODefs.WriteLine[Asterisks];z20320l3936d3552e1z20320l3392d3552e1index _ indexN + 1;z20320l4000d3552e1WHILE ((index < totalLinesInNewFile) AND (newArray[index].typeOfPntr # symTable))z20320l4000d3552e1DOz20320l3392d4032e1IF (newArray[index].lineNumInOtherFile # newArray[index - 1].lineNumInOtherFile + 1) THEN EXIT;z20320l4480d4032e1index _ index + 1;z20320l4480d4032e1ENDLOOP;z20320l3392d4032e1indexO _ indexO + (index - indexN);z20320l3392d3552e1indexN _ index;z20320l3392d3552e1startDifN _ indexN;z20320l3392d3552e1startDifO _ indexO;z20320l3392d3552e1END;z20320l3392d3552e1z20320l3392d2998e1TryToResolveConflicts: PROCEDURE [array1, array2: DESCRIPTOR FOR ARRAY [0..0) OF FileArrayEntry, index1, index2: INTEGER] RETURNS[okToDumpDiff: BOOLEAN] =z20320l3392d2998e1BEGINz20320l3392d3552e1lastRange1: INTEGER _ index1 + array1[index1].lineNumInOtherFile - index2;z20320l9144d3552e1tempIndex: INTEGER;z20320l9144d3552e1FOR tempIndex IN [index2..array1[index1].lineNumInOtherFile)z20320l9144d3552e1DOz20320l9144d4032e1IF array2[tempIndex].typeOfPntr = lineNumz20320l9144d4032e1THENz20320l11684d5302e1BEGINz20320l14224d6572e1IF array2[tempIndex].lineNumInOtherFile > lastRange1z20320l14540d6572e1THEN CancelMatch[array2, array1, totalLinesInOldFile, tempIndex]z20320l9600d7842e1ELSEz20320l17346d7842e1BEGINz21156l9600d9112e1CancelMatch[array1, array2, totalLinesInNewFile, index1];z21156l9600d9112e1RETURN[okToDumpDiff: FALSE];z21156l9600d9112e1END;z21156l9600d9112e1END;z20320l14224d6572e1ENDLOOP;z20320l9144d4032e1RETURN[okToDumpDiff: TRUE];z20320l3392d3552e1END;z20320l3392d3552e1z20320l3392d2998e1startDifN: INTEGER;z20320l3392d2998e1startDifO: INTEGER;z20320l3392d2998e1dumpDiff: BOOLEAN;z20320l3392d2998e1z20320l3392d2998e1numFormat: IODefs.NumberFormat;z20320l3392d2998e1columns: [0..255] _ 1;z20320l3392d2998e1max: INTEGER _ MAX[totalLinesInNewFile, totalLinesInOldFile];z20320l3392d2998e1DOz20320l3392d2998e1max _ max/10;z20320l3392d2998e1IF max = 0 THEN EXIT;z20320l3392d2998e1columns _ columns + 1;z20320l3392d2998e1ENDLOOP;z20320l3392d2998e1numFormat _ [base: 10, zerofill: TRUE, unsigned: TRUE, columns: columns]; z20320l3392d3008e1z20320l3392d2998e1indexN _ 0;z20320l3392d2998e1indexO _ 0;z20320l3392d2998e1WHILE ((indexN < totalLinesInNewFile) AND (indexO < totalLinesInOldFile) AND (newArray[indexN].typeOfPntr = lineNum) AND (oldArray[indexO].typeOfPntr = lineNum) AND (newArray[indexN].lineNumInOtherFile = indexO) AND (oldArray[indexO].lineNumInOtherFile = indexN))z20320l3392d2998e1DOz20320l3392d3616e1indexN _ indexN + 1;z20320l3392d3616e1indexO _ indexO + 1;z20320l3392d3616e1ENDLOOP;z20320l3392d3616e1z20320l3392d2998e1startDifN _ indexN;z20320l3392d2998e1startDifO _ indexO;z20320l3392d2998e1dumpDiff _ FALSE;z20320l3392d2998e1WHILE ((indexN < totalLinesInNewFile) AND (indexO < totalLinesInOldFile))z20320l3392d2998e1DOz20320l3392d3616e1IF ((newArray[indexN].typeOfPntr = lineNum) OR (oldArray[indexO].typeOfPntr = lineNum))z20320l4064d3616e1THENz20320l5334d4886e1BEGINz20320l6604d6156e1IF ((newArray[indexN].typeOfPntr = lineNum) AND (oldArray[indexO].typeOfPntr = lineNum))z20320l6604d6156e1THENz20320l7874d7426e1BEGINz20320l9144d8696e1IF ((newArray[indexN].lineNumInOtherFile = indexO) AND (oldArray[indexO].lineNumInOtherFile = indexN)) THEN GOTO dumpoutthedifference;z20320l9144d8696e1IF (newArray[indexN].lineNumInOtherFile - indexO) > (oldArray[indexO].lineNumInOtherFile - indexN)z20320l9144d8696e1THEN CancelMatch[newArray, oldArray, totalLinesInNewFile, indexN]z20320l10414d9966e1ELSE CancelMatch[oldArray, newArray, totalLinesInOldFile, indexO];z20320l10414d9966e1END;z20320l9144d8696e1IF (newArray[indexN].typeOfPntr = lineNum) z20320l6604d6156e1THEN dumpDiff _ TryToResolveConflicts[newArray, oldArray, indexN, indexO]z20320l9600d7426e1ELSE dumpDiff _ TryToResolveConflicts[oldArray, newArray, indexO, indexN];z20320l9600d7426e1EXITSz20320l6604d6156e1dumpoutthedifference => dumpDiff _ TRUE;z20320l6604d6656e1END;z20320l6604d6156e1IF dumpDiffz20320l4064d3616e1THENz20320l5334d4886e1BEGINz20320l6604d6156e1DumpOutDiffAndMoveAhead[];z20320l6604d6156e1dumpDiff _ FALSE;z20320l6604d6156e1ENDz20320l6604d6156e1ELSEz20320l5334d4886e1BEGINz20320l6604d6156e1indexN _ indexN + 1;z20320l6604d6156e1indexO _ indexO + 1;z20320l6604d6156e1END;z20320l6604d6156e1ENDLOOP;z20320l3392d3616e1IF ((startDifN < totalLinesInNewFile) OR (startDifO < totalLinesInOldFile)) THEN DumpOutDiffAndMoveAhead[];z20320l3392d2998e1END;z20320l3392d2998e1StepCursor[];z20320l3392d2998e1IF currentStepCursor # TotalNStepsCursor THEN Alarm[];z20320l3392d2998e1z20320l3392d2998e1SystemDefs.FreeSegment[newArrayPntr];z20320l3392d2998e1SystemDefs.FreeSegment[oldArrayPntr];z20320l3392d2998e1z20320l3392d2998e1IF anyDifferencesSeenz20320l3392d2998e1THENz20320l4662d4268e1BEGINz20320l5932d5538e1msgString: STRING = "Differences written on file ";z20320l5932d5526e1tempString: STRING _ SystemDefs.AllocateHeapString[difFileName.length + msgString.length + 1];z20320l5932d5526e1StringDefs.AppendString[tempString, msgString];z20320l5932d5526e1StringDefs.AppendString[tempString, difFileName];z20320l5932d5526e1StringDefs.AppendString[tempString, "."];z20320l5932d5538e1FinishUp[openDifFile: FALSE, writeAndCloseDifFile: TRUE, difMsg: "End of differences seen.", displayMsg: tempString, pause: FALSE];z20320l5932d5538e1ENDz20320l5932d5538e1ELSEz20320l4662d4268e1FinishUp[openDifFile: (NOT switchPause), writeAndCloseDifFile: (NOT switchPause), difMsg: "No differences encountered.", displayMsg: "No differences encountered.", pause: switchPause];z20320l5932d5538e1z20320l5932d3008e1END;z20320l3392d2998e1z20320l3392d2998e1z20320l3392d2998e1z20320l3392d2998e1z20320l3392d2998e1END.z20320l3392d2998e1\4bEdit Logz20320l3392d2998e1c\b8Bz20320l3392d2998e1cInitial: by Karen Kolling: November 13, 1979  12:18 PM (1792)l3648d2998Change: March 11, 1980  11:40 AM:  Version 1.1.  increased pages for display in help message from 20 to 25 so top of msg doesn't scroll off screen for larger system fonts.  Added output of CR as first character, to avoid mesa image bug that prefixed mesa.typescript with garbage. l3648d2998l3648d2998Change: May 5, 1980  4:04 PM:  Version 1.4. removed quick and dirty that required that each file be read from the disk twice.  changed dif file name from waterlily.dif to <firstfilename>.dif.  added global switch /p.l3648d2998l3648d2998Change: May 8, 1980  5:39 PM:  Version 1.5. changed array allocations to use segments and then deallocated them so room at end to prevent punt.l3648d2998Change: January 8, 1981  12:06 PM:  Version 1.6. changed the Desc assignments to newArray and oldArray to include the number of lines, for mesa 6.l3648d2998l3648d2998