-- FILE:  <Juniper>RamLoad.mesa  Last Edited by Mitchell, October 31, 1979  10:35 AMz20320l3316d2998(0,65535)(14,10795)DIRECTORYz20320l3316d2998e24AltoDefs: FROM "AltoDefs" USING[PageNumber, BytesPerPage, BytesPerWord],z20320l3634x0e1InlineDefs: FROM "InlineDefs" USING[BITAND],z20320l3634x0e1NovaOps: FROM "NovaOps" USING[NovaJSR],z20320l3634x0e1PrivateRamDefs: FROM "PrivateRamDefs",z20320l3634x0e1RamDefs: FROM "RamDefs",z20320l3634x0e1SegmentDefs: FROM "SegmentDefs" USING[FileHandle, FileSegmentHandle, NewFile, NewFileSegment, DefaultBase, DefaultPages, GetEndOfFile, Read, OldFileOnly, SwapIn, FileSegmentAddress, ReleaseFile, Unlock, SwapOut, DeleteFileSegment];z20320l3634x0e1RamLoad: PROGRAM IMPORTS InlineDefs, NovaOps, sg: SegmentDefs EXPORTS RamDefs =z20320l3316d2998x0e6BEGIN  OPEN RamDefs, PrivateRamDefs; -- module bodyz20320l3316d2998x0e1\12i23ILoadRamAndBoot: PUBLIC PROCEDURE[m: MuImage, boot: BOOLEAN] RETURNS [constDiffs: CARDINAL]  =-- loads the ram from the MuImage, checks the constants and returns number of constant mismatches.  If boot=TRUE, also does a silent boot: first, a silent boot is done to guarantee that the machine is in ground state (everything running in ROM0 - ok for Mesa?) and then, after loading the ram image, another silent boot is done as specified in the blv field of the MuImage.z20320l3316d2998x0e6k80\b14BBEGIN --LoadRamAndBootz20320l3952d3634x0e1muCode: ARRAY [0..2) OF MicroCode _	-- to be loaded at loc 0z20320l3952d3634x0e1\35t15 25t0[z20320l4587d4269x0e1[r: 0, aluF: Bus, bs: ReadR, f1: SwMode, f2: Noop, loadT: no, loadLM: no, next: 1],z20320l4587d4269x0e1[r: 0, aluF: Bus, bs: ReadR, f1: Noop, f2: Noop, loadT: no, loadLM: no, next: EmSTART]z20320l4587d4269x0e1];z20320l4587d4269x0e1\t15resetToProm: RamImage = DESCRIPTOR[muCode];z20320l3952d3634x0e1IF NOT RamExists[] THEN RETURN[177777B];z20320l3952d3634x0e1IF boot THENz20320l3952d3634x0e1BEGINz20320l4587d4269x0e1WriteRam[0, resetToProm];z20320l4587d4269x0e1\12t15 11t0SilentBoot[BootLocusVector[177776B]];	-- blv value to reset to ROM0z20320l4587d4269x0e1\37t15END;z20320l4587d4269x0e1\t15constDiffs _ CheckConstants[DESCRIPTOR[m.constVector]];z20320l3952d3634x0e1\t15WriteRam[0, DESCRIPTOR[m.ramVector]];	-- load the ramz20320l3952d3634x0e1\t15 38t0IF boot THEN SilentBoot[m.blv];	-- start it running wherever the MuImage specifiesz20320l3952d3634x0e1\31t15 51t0END; --LoadRamAndBootz20320l3952d3634x0e1ReadBlv: PUBLIC PROCEDURE[m: MuImage] RETURNS [BootLocusVector] =z20320l3316d2998x0e6jk80\b7BBEGIN RETURN [m.blv] END;z20320l3951d3633jk80NoEtherNetBoard: PUBLIC ERROR = CODE;z20320l3316d2998x0e6k80\b15BSilentBoot: PUBLIC PROCEDURE[blv: BootLocusVector] =-- check to see that a silent boot is possible (I.e., that Alto has an EtherNet board), sets boot locus vector and does the StartIO to cause a silent boot.z20320l3316d2998x0e6k80\b10BBEGIN --SilentBootz20320l3951d3633x0k80IF InlineDefs.BITAND[StartIO[0], 77777B]=77777B THEN ERROR NoEtherNetBoard;z20320l3951d3633x0k80\3i10ISetBootLocusVector[blv];z20320l3951d3633x0k80[]_StartIO[100000B];	-- boot it.z20320l3951d3633x0k80\20t15 12t0END;  --SilentBootz20320l3951d3633x0k80SetBootLocusVector: PROCEDURE[blv: BootLocusVector]  =-- Removes part of the code in the Ram (so be sure no task is running in the ram before doing this or the Alto will be zapped), writes some microcode into the same place and jumps to it to set the boot locus vector and then puts the previous ram contents back.  A subsequent StartIO can be used to do a silent boot (see, e.g., LoadRamAndBoot above).z20320l3316d2998x0e6k80BEGIN --SetBootLocusVectorz20320l3952d3634x0e1muCode: ARRAY [0..4) OF MicroCode _	-- microcode to go at loc 1000Bz20320l3952d3634x0e1\35t15 32t0[z20320l4587d4269x0e1[r: 0, aluF: Bus, bs: ReadR, f1: Task, f2: Noop, loadT: no, loadLM: no, next: 1001B],z20320l4587d4269x0e1[r: 3--AC0--, aluF: Bus, bs: ReadR, f1: RmrGets, f2: Noop, loadT: no, loadLM: no, next: 1002B],z20320l4587d4269x0e1[r: 0, aluF: Bus, bs: ReadR, f1: SwMode, f2: Noop, loadT: no, loadLM: no, next: 1003B],z20320l4587d4269x0e1\33t15 6t0[r: 0, aluF: Bus, bs: ReadR, f1: Noop, f2: Noop, loadT: no, loadLM: no, next: EmSTART]z20320l4587d4269x0e1];z20320l4587d4269x0e1\t15 2t0ldBLV: RamImage = DESCRIPTOR[muCode];z20320l3952d3634x0e1sv: ARRAY [0..4) OF MicroCode;z20320l3952d3634x0e1svDesc: RamImage = DESCRIPTOR[sv];z20320l3952d3634x0e1ReadRam[1000B, svDesc];	-- save part of the ramz20320l3952d3634x0e1\23t15 24t0WriteRam[1000B, ldBLV];z20320l4587d4269x0e1[]_JumpToRam[1000B, blv];	-- execute the code and give it the blv parameterz20320l4587d4269x0e1\25t15 50t0WriteRam[1000B, svDesc];	-- put saved ram contents backz20320l3952d3634x0e1\24t15 31t0END; --SetBootLocusVectorz20320l3952d3634x0e1CheckConstants: PROCEDURE[c: ConstantImage] RETURNS [constDiffs: CARDINAL]  =z20320l3316d2998x0e6k80BEGIN  --CheckConstantsz20320l3952d3634x0e1muCode: ARRAY [0..2) OF MicroCode _z20320l3952d3634x0e1[z20320l4587d4269x0e1[r: 0, aluF: Bus, bs: 0, f1: SwMode, f2: ReadConst, loadT: no, loadLM: yes, next: 1001B],z20320l4587d4269x0e1\41t15 9t0[r: 3--ACO--, aluF: Bus, bs: RGets, f1: Noop, f2: Noop, loadT: no, loadLM: no, next: EmSTART]z20320l4587d4269x0e1];z20320l4587d4269x0e1readConsti: RamImage _ DESCRIPTOR[muCode];z20320l3952d3634x0e1old: ARRAY [0..2) OF MicroCode;z20320l3952d3634x0e1descOld: RamImage = DESCRIPTOR[old];z20320l3952d3634x0e1i, const: CARDINAL;z20320l3952d3634x0e1ibits: MACHINE DEPENDENT RECORD[blank: [0..377B], high5: [0..37B], low3: [0..7B]];z20320l3952d3634x0e1constDiffs _ 0;z20320l3952d3634x0e1ReadRam[1000B, descOld];	-- salt what is in RAM awayz20320l3952d3634x0e1\24t15FOR i IN [1..maxConstAddr]z20320l3952d3634x0e1\t15 13t0 13t15DOz20320l4587d4269x0e1\t15ibits _ LOOPHOLE[i];	-- to look at bits of iz20320l4587d4269x0e1\t15readConsti[0].r _ ibits.high5;	-- compile high-order microcode wordz20320l4587d4269x0e1\10t15readConsti[0].bs _ ibits.low3;	-- r,bs fields used to address constant memoryz20320l4587d4269x0e1\t15WriteRam[1000B, readConsti];z20320l4587d4269x0e1\t15 16t0 10t15const _ JumpToRam[1000B, 0];z20320l4587d4269x0e1\t15IF c[i]#const AND c[i]#0 THEN constDiffs _ constDiffs+1; z20320l4587d4269x0e1\t15 57t0ENDLOOP;z20320l4587d4269x0e1WriteRam[1000B, descOld];	-- restore RAM contentsz20320l3952d3634x0e1\t15 49t0END; --CheckConstantsz20320l3952d3634x0e1RamExists: PROCEDURE RETURNS [BOOLEAN]  =-- Returns TRUE if Ram attached, FALSE if not.z20320l3316d2998x0e6k80BEGIN --RamExistsz20320l3952d3634x0e1sv, y: ARRAY [0..1) OF MicroCode;z20320l3952d3634x0e1test: ARRAY [0..1) OF MicroCode _[[r: 31, aluF: undefAlu1, bs: ReadR, f1: Noop, f2: taskSpec5, loadT: no, loadLM: no, next: 525B]];z20320l3952d3634x0e1svDesc: RamImage _ DESCRIPTOR[sv];z20320l3952d3634x0e1yDesc: RamImage _ DESCRIPTOR[y];z20320l3952d3634x0e1testDesc: RamImage _ DESCRIPTOR[test];z20320l3952d3634x0e1ReadRam[774B, svDesc];	-- save Ram wordz20320l3952d3634x0e1\22t15 17t0WriteRam[774B, testDesc]; ReadRam[774B, yDesc];z20320l3952d3634x0e1WriteRam[774B, svDesc];	-- restore Ram wordz20320l3952d3634x0e1\23t15 20t0RETURN[ y[0]=test[0] ];z20320l3952d3634x0e1END; --RamExistsz20320l3952d3634x0e1RamWord: TYPE = MACHINE DEPENDENT RECORD [high, low: CARDINAL];z20320l3316d2998x0e6k80ReadRam: PROCEDURE[a: MicroAddress, v: RamImage]  =-- Read Ram words beginning at location a; LENGTH[v] RamWords are read into v.z20320l3316d2998x0e6k80BEGIN --ReadRamz20320l3952d3634x0e1code: ARRAY [0..3) OF CARDINAL _	-- reads RAM half-word (16 bits) addressed by AC0 into AC0z20320l3952d3634x0e1\32t15 59t0[z20320l4587d4269x0e1105000B,	-- MOV 0,1z20320l4587d4269x0e1\8t15061011B,	-- RDRAMz20320l4587d4269x0e1\t15 17t0001400B	-- JMP 0,3z20320l4587d4269x0e1\t15 11t0 7t15];z20320l4587d4269x0e1\t15selectHighWord: CARDINAL = 2000B;	-- to select high-order 16 bits of a RAM wordz20320l3952d3634x0e1\33t15 46t0high, low: CARDINAL;z20320l3952d3634x0e1i: CARDINAL;z20320l3952d3634x0e1FOR i IN [0..LENGTH[v])z20320l3952d3634x0e1DOz20320l4587d4269x0e1high _ NovaOps.NovaJSR[JSR, BASE[code], a+i+selectHighWord];z20320l4587d4269x0e1\7i7Ilow _ NovaOps.NovaJSR[JSR, BASE[code], a+i];z20320l4587d4269x0e1\6i7Iv[i] _ LOOPHOLE[RamWord[high: high, low: low], MicroCode];z20320l4587d4269x0e1\34i2IENDLOOP;z20320l4587d4269x0e1END; --ReadRamz20320l3952d3634x0e1WriteRam: PROCEDURE[a: MicroAddress, v: RamImage]  =-- Beginning at Ram location a, write LENGTH[v] RamWords into the Ram.  The loop to do this is written entirely in Nova code so that it can operate even if the microcode being loaded temporarily clobbers Mesa microcode (as is the case when using XMesa on wide-bodied Altos).z20320l3316d2998x0e6k80BEGIN --WriteRamz20320l3952d3634x0e1code: ARRAY [0..14) OF CARDINAL _z20320l3952d3634x0e1[z20320l4587d4269x0e1111000B,	--	MOV	0,2	;move ptr to parameter record to indexable registerz20320l4587d4269x0e1(635)55003B,		-- 	STA		3,3,2	; save return address in parameter recordz20320l4587d4269x0e125001B,		-- 	LDA		1,1,2	;load ram addressz20320l4587d4269x0e135002B,		-- LOOP:	LDA	3,2,2	;get @v[i]z20320l4587d4269x0e121400B,		-- 	LDA		0,0,3	;load v[i].high into ac0 for wrtramz20320l4587d4269x0e135401B,		-- 	LDA		3,1,3	;load v[i].low into ac3 for wrtramz20320l4587d4269x0e1061012B,	-- 	WRTRAMz20320l4587d4269x0e1125420B,	-- 	INCZ	1,1		; increment the ram addressz20320l4587d4269x0e111002B,		-- 	ISZ		2,2		; increment the vector address twicez20320l4587d4269x0e111002B,		-- 	ISZ		2,2z20320l4587d4269x0e115000B,		-- 	DSZ	0,2		; decrement count and check if donez20320l4587d4269x0e1770B,		-- 	JMP	LOOP	; nope, go around againz20320l4587d4269x0e135003B,		-- 	LDA		3,3,2	; finished, load the return addressz20320l4587d4269x0e11400B		-- 	JMP	0,3		; returnz20320l4587d4269x0e1];z20320l4587d4269x0e1(0,65535)\t15acs: MACHINE DEPENDENT RECORD[n, ramAddr, vecAddr, svAc3: UNSPECIFIED];z20320l3952d3634x0e1acs _ [n: LENGTH[v], ramAddr: a, vecAddr:BASE[v], svAc3: NIL];   -- prepare parameters for Alto codez20320l3952d3634x0e1\62t15 38t0[] _ NovaOps.NovaJSR[JSR, BASE[code], @acs];z20320l3952d3634x0e1\t15 5i7IEND; --WriteRamz20320l3952d3634x0e1JumpToRam: PROCEDURE[ac1: MicroAddress, ac0: UNSPECIFIED] RETURNS[fromAc0: CARDINAL]  =-- Jump to the Ram location given by ac1, passing ac0 in Alto AC0.z20320l3316d2998x0e6k80BEGIN --JumpToRamz20320l3952d3634x0e1code: ARRAY [0..5) OF CARDINAL _z20320l3952d3634x0e1[z20320l4587d4269x0e1111000B,	-- MOV 0,2z20320l4587d4269x0e1\8t15021000B,	-- LDA 0,0,2z20320l4587d4269x0e1\t15025001B,	-- LDA 1,1,2z20320l4587d4269x0e1\t15 21t0061010B,	-- JMPRAMz20320l4587d4269x0e1\8t15001400B	-- JMP 0,3z20320l4587d4269x0e1\t15 11t0 7t15];z20320l4587d4269x0e1\t15acs: MACHINE DEPENDENT RECORD[ac0: UNSPECIFIED, ac1: CARDINAL --MicroAddress--]_ [ac0, ac1];z20320l3952d3634x0e1fromAc0 _ NovaOps.NovaJSR[JSR, BASE[code], @acs];z20320l3952d3634x0e1\10i7IEND; --JumpToRamz20320l3952d3634x0e1StartIO: PUBLIC PROCEDURE[ac0: UNSPECIFIED] RETURNS [fromAc0: CARDINAL]  =-- Do an SIO with ac0 passed in the Alto AC0.z20320l3316d2998x0e6k80\b7BBEGIN --StartIOz20320l3952d3634x0e1code: ARRAY [0..2) OF CARDINAL _z20320l3952d3634x0e1[z20320l4587d4269x0e1061004B,	-- SIOz20320l4587d4269x0e1\8t15001400B	-- JMP 0,3z20320l4587d4269x0e1\t15 11t0 7t15];z20320l4587d4269x0e1\t15fromAc0 _ NovaOps.NovaJSR[JSR,BASE[code], ac0];z20320l3952d3634x0e1\7t15 3i7I30t0END; --StartIOz20320l3952d3634x0e1muFH: sg.FileHandle _ NIL;z20320l3316d2998x0e6k80\6i2ImuSeg: sg.FileSegmentHandle _ NIL;z20320l3316d2998x0e6k80\7i3IcheckConstVec: ARRAY [1..13] OF CARDINAL =  -- what first constants in a Packed Mu file should be[1, 2, 177776B, 177777B, 177777B, 17B, 177777B, 3, 4, 5, 6, 7, 10B];z20320l3316d2998x0e6k80MuFileAlreadyOpen: PUBLIC ERROR = CODE;z20320l3316d2998x0e6k80\b17BSuspiciousPackedMuFile: PUBLIC ERROR = CODE;z20320l3316d2998x0k80\b22BReadPackedMuFile: PUBLIC PROCEDURE[name: STRING] RETURNS[theImage: MuImage]  =-- Read and swap in a Packed Mu file and check it to increase our confidence that it is a valid MuImage as prepared by the program PackMu.Run.z20320l3316d2998x0e6k80\b16BBEGIN OPEN sg; --ReadPackedMuFilez20320l3952d3634x0e1\11i2IlastPage: AltoDefs.PageNumber;z20320l3952d3634x0e1\10i8IlastByteCount: [0..AltoDefs.BytesPerPage];z20320l3952d3634x0e1\19i8Ii: CARDINAL;z20320l3952d3634x0e1IF muFH # NIL THEN ERROR MuFileAlreadyOpen;z20320l3952d3634x0e1theImage_NIL;z20320l3952d3634x0e1muFH _ NewFile[name: name, access: Read, version: OldFileOnly];z20320l3952d3634x0e1\7i7I21i4I11i11IBEGINz20320l4587d4269x0e1[page: lastPage, byte: lastByteCount] _ GetEndOfFile[muFH];z20320l4587d4269x0e1\40i12IIF lastPage#12B THEN GOTO FileLooksBad;z20320l4587d4269x0e1IF lastByteCount MOD AltoDefs.BytesPerWord # 0 THEN GOTO FileLooksBad;z20320l4587d4269x0e1\21i9ImuSeg _ NewFileSegment[file: muFH, base: DefaultBase, pages: DefaultPages, access: Read];z20320l4587d4269x0e1\8i14I19i11I9i12I10i4ISwapIn[muSeg];z20320l4587d4269x0e1\i6ItheImage _ FileSegmentAddress[muSeg];z20320l4587d4269x0e1\11i18IFOR i IN [1..13] DO IF checkConstVec[i]#theImage.constVector[i] THEN GOTO FileLooksBad; ENDLOOP;z20320l4587d4269x0e1EXITSz20320l4587d4269x0e1FileLooksBad => z20320l5222d4904x0e1BEGINz20320l5857d5539x0e1ReleaseMuImage[theImage];z20320l5857d5539x0e1ERROR SuspiciousPackedMuFile;z20320l5857d5539x0e1END;z20320l5857d5539x0e1END;z20320l4587d4269x0e1END;  --ReadPackedMuFilez20320l3952d3634x0e1ReleaseMuImage: PUBLIC PROCEDURE[theImage: MuImage]  =-- Release the FileHandle for the current packed MuImage.  IF muSeg#NIL, then swap it out first and get rid of the segment.  Then release the file.z20320l3316d2998x0e6k80\b14BBEGIN OPEN sg;  --ReleaseMuImagez20320l3952d3634x0e1\11i2IIF muSeg=NIL THENz20320l3952d3634x0e1BEGINz20320l4587d4269x0e1IF theImage#NIL THEN ERROR;z20320l4587d4269x0e1ReleaseFile[muFH];z20320l4587d4269x0e1\i11IENDz20320l4587d4269x0e1ELSEz20320l3952d3634x0e1BEGINz20320l4587d4269x0e1Unlock[muSeg]; SwapOut[muSeg];z20320l4587d4269x0e1\i6I9i7IDeleteFileSegment[muSeg];z20320l4587d4269x0e1\i17ImuSeg _ NIL;z20320l4587d4269x0e1END;z20320l4587d4269x0e1muFH_NIL;z20320l3952d3634x0e1END;  --ReleaseMuImagez20320l3952d3634x0e1-- I N I T I A L I Z A T I O Nz20320l3316d2998x0e7\3bEND. -- RamLoadz20320l3316d2998x0e1Edit Logz20320l3392d2998e1c\b8Bz20320l3392d2998e1cRemark: Sturgis:  5-Jun-79 18:33:41: any comments earlier than October 1, 1978 placed in the Juniper History Log.l3776d2998e5(635)\b6BChanged by: Mitchell,  March 6, 1979  11:51 PM  Conversion to Mesa 5.0; now must IMPORT InlineDefs and NovaOpsz20320l3316d2998e4Changed by: Mitchell,  October 31, 1979  10:36 AMAdded ReadBlv procedure to get BootLocusVector from a MuImage.z20320l3316d2998e4Changed by: Mitchell,  DTAcrTypez20320l3316d2998e4