-- FILE:  <JPROG>RamLoad.mesa  Last Edited by Mitchell, September 5, 1978  5:58 PMz20320l3316d2998(0,65535)(14,10795)DIRECTORYz20320l3316d2998e24AltoDefs: FROM "AltoDefs" USING[PageNumber, BytesPerPage, BytesPerWord],z20320l3634x0e1InlineDefs: FROM "InlineDefs" USING[BITAND],z20320l3634x0e1NovaOps: FROM "NovaOps" USING[NovaJSR],z20320l3634x0e1PrivateRamDefs: FROM "PrivateRamDefs",z20320l3634x0e1RamDefs: FROM "RamDefs",z20320l3634x0e1SegmentDefs: FROM "SegmentDefs" USING[FileHandle, FileSegmentHandle, NewFile, NewFileSegment, DefaultBase, DefaultPages, GetEndOfFile, Read, OldFileOnly, SwapIn, FileSegmentAddress, ReleaseFile, Unlock, SwapOut, DeleteFileSegment];z20320l3634x0e1RamLoad: PROGRAM IMPORTS sg: SegmentDefs EXPORTS RamDefs =z20320l3316d2998x0e6BEGIN  OPEN RamDefs, PrivateRamDefs; -- module bodyz20320l3316d2998x0e1\12i23ILoadRamAndBoot: PUBLIC PROCEDURE[m: MuImage, boot: BOOLEAN] RETURNS [constDiffs: CARDINAL]  =-- loads the ram from the MuImage, checks the constants and returns number of constant mismatches.  If boot=TRUE, also does a silent boot: first, a silent boot is done to guarantee that the machine is in ground state (everything running in ROM0 - ok for Mesa?) and then, after loading the ram image, another silent boot is done as specified in the blv field of the MuImage.z20320l3316d2998x0e6k80BEGIN --LoadRamAndBootz20320l3952d3634x0e1muCode: ARRAY [0..2) OF MicroCode _	-- to be loaded at loc 0z20320l3952d3634x0e1\35t15 25t0[z20320l4587d4269x0e1[r: 0, aluF: Bus, bs: ReadR, f1: SwMode, f2: Noop, loadT: no, loadLM: no, next: 1],z20320l4587d4269x0e1[r: 0, aluF: Bus, bs: ReadR, f1: Noop, f2: Noop, loadT: no, loadLM: no, next: EmSTART]z20320l4587d4269x0e1];z20320l4587d4269x0e1\t15resetToProm: RamImage = DESCRIPTOR[muCode];z20320l3952d3634x0e1IF NOT RamExists[] THEN RETURN[177777B];z20320l3952d3634x0e1IF boot THENz20320l3952d3634x0e1BEGINz20320l4587d4269x0e1WriteRam[0, resetToProm];z20320l4587d4269x0e1\12t15 11t0SilentBoot[BootLocusVector[177776B]];	-- blv value to reset to ROM0z20320l4587d4269x0e1\37t15END;z20320l4587d4269x0e1\t15constDiffs _ CheckConstants[DESCRIPTOR[m.constVector]];z20320l3952d3634x0e1\t15WriteRam[0, DESCRIPTOR[m.ramVector]];	-- load the ramz20320l3952d3634x0e1\t15 38t0IF boot THEN SilentBoot[m.blv];	-- start it running wherever the MuImage specifiesz20320l3952d3634x0e1\31t15 51t0END; --LoadRamAndBootz20320l3952d3634x0e1NoEtherNetBoard: PUBLIC ERROR = CODE;z20320l3316d2998x0e6k80SilentBoot: PUBLIC PROCEDURE[blv: BootLocusVector] =-- check to see that a silent boot is possible (I.e., that Alto has an EtherNet board), sets boot locus vector and does the StartIO to cause a silent boot.z20320l3316d2998x0e6k80BEGIN --SilentBootz20320l3951d3633x0k80IF InlineDefs.BITAND[StartIO[0], 77777B]=77777B THEN ERROR NoEtherNetBoard;z20320l3951d3633x0k80\3i10ISetBootLocusVector[blv];z20320l3951d3633x0k80[]_StartIO[100000B];	-- boot it.z20320l3951d3633x0k80\20t15 12t0END;  --SilentBootz20320l3951d3633x0k80SetBootLocusVector: PROCEDURE[blv: BootLocusVector]  =-- Removes part of the code in the Ram (so be sure no task is running in the ram before doing this or the Alto will be zapped), writes some microcode into the same place and jumps to it to set the boot locus vector and then puts the previous ram contents back.  A subsequent StartIO can be used to do a silent boot (see, e.g., LoadRamAndBoot above).z20320l3316d2998x0e6k80BEGIN --SetBootLocusVectorz20320l3952d3634x0e1muCode: ARRAY [0..4) OF MicroCode _	-- microcode to go at loc 1000Bz20320l3952d3634x0e1\35t15 32t0[z20320l4587d4269x0e1[r: 0, aluF: Bus, bs: ReadR, f1: Task, f2: Noop, loadT: no, loadLM: no, next: 1001B],z20320l4587d4269x0e1[r: 3--AC0--, aluF: Bus, bs: ReadR, f1: RmrGets, f2: Noop, loadT: no, loadLM: no, next: 1002B],z20320l4587d4269x0e1[r: 0, aluF: Bus, bs: ReadR, f1: SwMode, f2: Noop, loadT: no, loadLM: no, next: 1003B],z20320l4587d4269x0e1\33t15 6t0[r: 0, aluF: Bus, bs: ReadR, f1: Noop, f2: Noop, loadT: no, loadLM: no, next: EmSTART]z20320l4587d4269x0e1];z20320l4587d4269x0e1\t15 2t0ldBLV: RamImage = DESCRIPTOR[muCode];z20320l3952d3634x0e1sv: ARRAY [0..4) OF MicroCode;z20320l3952d3634x0e1svDesc: RamImage = DESCRIPTOR[sv];z20320l3952d3634x0e1ReadRam[1000B, svDesc];	-- save part of the ramz20320l3952d3634x0e1\23t15 24t0WriteRam[1000B, ldBLV];z20320l4587d4269x0e1[]_JumpToRam[1000B, blv];	-- execute the code and give it the blv parameterz20320l4587d4269x0e1\25t15 50t0WriteRam[1000B, svDesc];	-- put saved ram contents backz20320l3952d3634x0e1\24t15 31t0END; --SetBootLocusVectorz20320l3952d3634x0e1CheckConstants: PROCEDURE[c: ConstantImage] RETURNS [constDiffs: CARDINAL]  =z20320l3316d2998x0e6k80BEGIN  --CheckConstantsz20320l3952d3634x0e1muCode: ARRAY [0..2) OF MicroCode _z20320l3952d3634x0e1[z20320l4587d4269x0e1[r: 0, aluF: Bus, bs: 0, f1: SwMode, f2: ReadConst, loadT: no, loadLM: yes, next: 1001B],z20320l4587d4269x0e1\41t15 9t0[r: 3--ACO--, aluF: Bus, bs: RGets, f1: Noop, f2: Noop, loadT: no, loadLM: no, next: EmSTART]z20320l4587d4269x0e1];z20320l4587d4269x0e1readConsti: RamImage _ DESCRIPTOR[muCode];z20320l3952d3634x0e1old: ARRAY [0..2) OF MicroCode;z20320l3952d3634x0e1descOld: RamImage = DESCRIPTOR[old];z20320l3952d3634x0e1i, const: CARDINAL;z20320l3952d3634x0e1ibits: MACHINE DEPENDENT RECORD[blank: [0..377B], high5: [0..37B], low3: [0..7B]];z20320l3952d3634x0e1constDiffs _ 0;z20320l3952d3634x0e1ReadRam[1000B, descOld];	-- salt what is in RAM awayz20320l3952d3634x0e1\24t15FOR i IN [1..maxConstAddr]z20320l3952d3634x0e1\t15 13t0 13t15DOz20320l4587d4269x0e1\t15ibits _ LOOPHOLE[i];	-- to look at bits of iz20320l4587d4269x0e1\t15readConsti[0].r _ ibits.high5;	-- compile high-order microcode wordz20320l4587d4269x0e1\10t15readConsti[0].bs _ ibits.low3;	-- r,bs fields used to address constant memoryz20320l4587d4269x0e1\t15WriteRam[1000B, readConsti];z20320l4587d4269x0e1\t15 16t0 10t15const _ JumpToRam[1000B, 0];z20320l4587d4269x0e1\t15IF c[i]#const AND c[i]#0 THEN constDiffs _ constDiffs+1; z20320l4587d4269x0e1\t15 57t0ENDLOOP;z20320l4587d4269x0e1WriteRam[1000B, descOld];	-- restore RAM contentsz20320l3952d3634x0e1\t15 49t0END; --CheckConstantsz20320l3952d3634x0e1RamExists: PROCEDURE RETURNS [BOOLEAN]  =-- Returns TRUE if Ram attached, FALSE if not.z20320l3316d2998x0e6k80BEGIN --RamExistsz20320l3952d3634x0e1sv, y: ARRAY [0..1) OF MicroCode;z20320l3952d3634x0e1test: ARRAY [0..1) OF MicroCode _[[r: 31, aluF: undefAlu1, bs: ReadR, f1: Noop, f2: taskSpec5, loadT: no, loadLM: no, next: 525B]];z20320l3952d3634x0e1svDesc: RamImage _ DESCRIPTOR[sv];z20320l3952d3634x0e1yDesc: RamImage _ DESCRIPTOR[y];z20320l3952d3634x0e1testDesc: RamImage _ DESCRIPTOR[test];z20320l3952d3634x0e1ReadRam[774B, svDesc];	-- save Ram wordz20320l3952d3634x0e1\22t15 17t0WriteRam[774B, testDesc]; ReadRam[774B, yDesc];z20320l3952d3634x0e1WriteRam[774B, svDesc];	-- restore Ram wordz20320l3952d3634x0e1\23t15 20t0RETURN[ y[0]=test[0] ];z20320l3952d3634x0e1END; --RamExistsz20320l3952d3634x0e1RamWord: TYPE = MACHINE DEPENDENT RECORD [high, low: CARDINAL];z20320l3316d2998x0e6k80ReadRam: PROCEDURE[a: MicroAddress, v: RamImage]  =-- Read Ram words beginning at location a; LENGTH[v] RamWords are read into v.z20320l3316d2998x0e6k80BEGIN --ReadRamz20320l3952d3634x0e1code: ARRAY [0..3) OF CARDINAL _	-- reads RAM half-word (16 bits) addressed by AC0 into AC0z20320l3952d3634x0e1\32t15 59t0[z20320l4587d4269x0e1105000B,	-- MOV 0,1z20320l4587d4269x0e1\8t15061011B,	-- RDRAMz20320l4587d4269x0e1\t15 17t0001400B	-- JMP 0,3z20320l4587d4269x0e1\t15 11t0 7t15];z20320l4587d4269x0e1\t15selectHighWord: CARDINAL = 2000B;	-- to select high-order 16 bits of a RAM wordz20320l3952d3634x0e1\33t15 46t0high, low: CARDINAL;z20320l3952d3634x0e1i: CARDINAL;z20320l3952d3634x0e1FOR i IN [0..LENGTH[v])z20320l3952d3634x0e1DOz20320l4587d4269x0e1high _ NovaOps.NovaJSR[JSR, BASE[code], a+i+selectHighWord];z20320l4587d4269x0e1\7i7Ilow _ NovaOps.NovaJSR[JSR, BASE[code], a+i];z20320l4587d4269x0e1\6i7Iv[i] _ LOOPHOLE[RamWord[high: high, low: low], MicroCode];z20320l4587d4269x0e1\34i2IENDLOOP;z20320l4587d4269x0e1END; --ReadRamz20320l3952d3634x0e1WriteRam: PROCEDURE[a: MicroAddress, v: RamImage]  =-- Beginning at Ram location a, write LENGTH[v] RamWords into the Ram.  The loop to do this is written entirely in Nova code so that it can operate even if the microcode being loaded temporarily clobbers Mesa microcode (as is the case when using XMesa on wide-bodied Altos).z20320l3316d2998x0e6k80BEGIN --WriteRamz20320l3952d3634x0e1code: ARRAY [0..14) OF CARDINAL _z20320l3952d3634x0e1[z20320l4587d4269x0e1111000B,	--	MOV	0,2	;move ptr to parameter record to indexable registerz20320l4587d4269x0e1(635)55003B,		-- 	STA		3,3,2	; save return address in parameter recordz20320l4587d4269x0e125001B,		-- 	LDA		1,1,2	;load ram addressz20320l4587d4269x0e135002B,		-- LOOP:	LDA	3,2,2	;get @v[i]z20320l4587d4269x0e121400B,		-- 	LDA		0,0,3	;load v[i].high into ac0 for wrtramz20320l4587d4269x0e135401B,		-- 	LDA		3,1,3	;load v[i].low into ac3 for wrtramz20320l4587d4269x0e1061012B,	-- 	WRTRAMz20320l4587d4269x0e1125420B,	-- 	INCZ	1,1		; increment the ram addressz20320l4587d4269x0e111002B,		-- 	ISZ		2,2		; increment the vector address twicez20320l4587d4269x0e111002B,		-- 	ISZ		2,2z20320l4587d4269x0e115000B,		-- 	DSZ	0,2		; decrement count and check if donez20320l4587d4269x0e1770B,		-- 	JMP	LOOP	; nope, go around againz20320l4587d4269x0e135003B,		-- 	LDA		3,3,2	; finished, load the return addressz20320l4587d4269x0e11400B		-- 	JMP	0,3		; returnz20320l4587d4269x0e1];z20320l4587d4269x0e1(0,65535)\t15acs: MACHINE DEPENDENT RECORD[n, ramAddr, vecAddr, svAc3: UNSPECIFIED];z20320l3952d3634x0e1acs _ [n: LENGTH[v], ramAddr: a, vecAddr:BASE[v], svAc3: NIL];   -- prepare parameters for Alto codez20320l3952d3634x0e1\62t15 38t0[] _ NovaOps.NovaJSR[JSR, BASE[code], @acs];z20320l3952d3634x0e1\t15 5i7IEND; --WriteRamz20320l3952d3634x0e1JumpToRam: PROCEDURE[ac1: MicroAddress, ac0: UNSPECIFIED] RETURNS[fromAc0: CARDINAL]  =-- Jump to the Ram location given by ac1, passing ac0 in Alto AC0.z20320l3316d2998x0e6k80BEGIN --JumpToRamz20320l3952d3634x0e1code: ARRAY [0..5) OF CARDINAL _z20320l3952d3634x0e1[z20320l4587d4269x0e1111000B,	-- MOV 0,2z20320l4587d4269x0e1\8t15021000B,	-- LDA 0,0,2z20320l4587d4269x0e1\t15025001B,	-- LDA 1,1,2z20320l4587d4269x0e1\t15 21t0061010B,	-- JMPRAMz20320l4587d4269x0e1\8t15001400B	-- JMP 0,3z20320l4587d4269x0e1\t15 11t0 7t15];z20320l4587d4269x0e1\t15acs: MACHINE DEPENDENT RECORD[ac0: UNSPECIFIED, ac1: CARDINAL --MicroAddress--]_ [ac0, ac1];z20320l3952d3634x0e1fromAc0 _ NovaOps.NovaJSR[JSR, BASE[code], @acs];z20320l3952d3634x0e1\10i7IEND; --JumpToRamz20320l3952d3634x0e1StartIO: PUBLIC PROCEDURE[ac0: UNSPECIFIED] RETURNS [fromAc0: CARDINAL]  =-- Do an SIO with ac0 passed in the Alto AC0.z20320l3316d2998x0e6k80BEGIN --StartIOz20320l3952d3634x0e1code: ARRAY [0..2) OF CARDINAL _z20320l3952d3634x0e1[z20320l4587d4269x0e1061004B,	-- SIOz20320l4587d4269x0e1\8t15001400B	-- JMP 0,3z20320l4587d4269x0e1\t15 11t0 7t15];z20320l4587d4269x0e1\t15fromAc0 _ NovaOps.NovaJSR[JSR,BASE[code], ac0];z20320l3952d3634x0e1\7t15 3i7I30t0END; --StartIOz20320l3952d3634x0e1muFH: sg.FileHandle _ NIL;z20320l3316d2998x0e6k80\6i2ImuSeg: sg.FileSegmentHandle _ NIL;z20320l3316d2998x0e6k80\7i3IcheckConstVec: ARRAY [1..13] OF CARDINAL =  -- what first constants in a Packed Mu file should be[1, 2, 177776B, 177777B, 177777B, 17B, 177777B, 3, 4, 5, 6, 7, 10B];z20320l3316d2998x0e6k80MuFileAlreadyOpen: PUBLIC ERROR = CODE;z20320l3316d2998x0e6k80SuspiciousPackedMuFile: PUBLIC ERROR = CODE;z20320l3316d2998x0k80ReadPackedMuFile: PUBLIC PROCEDURE[name: STRING] RETURNS[theImage: MuImage]  =-- Read and swap in a Packed Mu file and check it to increase our confidence that it is a valid MuImage as prepared by the program PackMu.Run.z20320l3316d2998x0e6k80BEGIN OPEN sg; --ReadPackedMuFilez20320l3952d3634x0e1\11i2IlastPage: AltoDefs.PageNumber;z20320l3952d3634x0e1\10i8IlastByteCount: [0..AltoDefs.BytesPerPage];z20320l3952d3634x0e1\19i8Ii: CARDINAL;z20320l3952d3634x0e1IF muFH # NIL THEN ERROR MuFileAlreadyOpen;z20320l3952d3634x0e1theImage_NIL;z20320l3952d3634x0e1muFH _ NewFile[name: name, access: Read, version: OldFileOnly];z20320l3952d3634x0e1\7i7I21i4I11i11IBEGINz20320l4587d4269x0e1[page: lastPage, byte: lastByteCount] _ GetEndOfFile[muFH];z20320l4587d4269x0e1\40i12IIF lastPage#12B THEN GOTO FileLooksBad;z20320l4587d4269x0e1IF lastByteCount MOD AltoDefs.BytesPerWord # 0 THEN GOTO FileLooksBad;z20320l4587d4269x0e1\21i9ImuSeg _ NewFileSegment[file: muFH, base: DefaultBase, pages: DefaultPages, access: Read];z20320l4587d4269x0e1\8i14I19i11I9i12I10i4ISwapIn[muSeg];z20320l4587d4269x0e1\i6ItheImage _ FileSegmentAddress[muSeg];z20320l4587d4269x0e1\11i18IFOR i IN [1..13] DO IF checkConstVec[i]#theImage.constVector[i] THEN GOTO FileLooksBad; ENDLOOP;z20320l4587d4269x0e1EXITSz20320l4587d4269x0e1FileLooksBad => z20320l5222d4904x0e1BEGINz20320l5857d5539x0e1ReleaseMuImage[theImage];z20320l5857d5539x0e1ERROR SuspiciousPackedMuFile;z20320l5857d5539x0e1END;z20320l5857d5539x0e1END;z20320l4587d4269x0e1END;  --ReadPackedMuFilez20320l3952d3634x0e1ReleaseMuImage: PUBLIC PROCEDURE[theImage: MuImage]  =-- Release the FileHandle for the current packed MuImage.  IF muSeg#NIL, then swap it out first and get rid of the segment.  Then release the file.z20320l3316d2998x0e6k80BEGIN OPEN sg;  --ReleaseMuImagez20320l3952d3634x0e1\11i2IIF muSeg=NIL THENz20320l3952d3634x0e1BEGINz20320l4587d4269x0e1IF theImage#NIL THEN ERROR;z20320l4587d4269x0e1ReleaseFile[muFH];z20320l4587d4269x0e1\i11IENDz20320l4587d4269x0e1ELSEz20320l3952d3634x0e1BEGINz20320l4587d4269x0e1Unlock[muSeg]; SwapOut[muSeg];z20320l4587d4269x0e1\i6I9i7IDeleteFileSegment[muSeg];z20320l4587d4269x0e1\i17ImuSeg _ NIL;z20320l4587d4269x0e1END;z20320l4587d4269x0e1muFH_NIL;z20320l3952d3634x0e1END;  --ReleaseMuImagez20320l3952d3634x0e1-- I N I T I A L I Z A T I O Nz20320l3316d2998x0e7\3bEND. -- RamLoadz20320l3316d2998x0e1MODULE HISTORYz20320l3316d2998e36ck80Initial: Mitchell, May 13, 1977  1:40 PMz20320l3316d2998e12reason: written to be part of Mesa/Juniper code for running the Trident disks.  z20320l3951d3633e2Compilation started: May 15, 1977  3:17 PMz20320l3951d3633e2Compile1, 2, and 3: numerous small syntactic errors, including incorrect usage of comment convention.  A single syntax error seems to cause large number of messages about names and variables being undeclared in later phases of the compiler.z20320l3951d3633e2Compile4,5: one too many "]"s.  forgot BEGIN following a THEN and had one too many ENDs.z20320l3951d3633e2Compile6: forgot to declare MicroAddress, maxConstAddr.  one too few values in two constructors; forgot that JumpToRam and StartIO both return values and had to put []_ in two places.z20320l3951d3633e2Compile7: Compiler bug in pass 5; signal=164353B, message = 177777Bz20320l3951d3633e2Compilation attempts suspended: May 15, 1977  5:07 PMz20320l3951d3633e2reason: Added routines to ReadPackedMuFile, ReleasePackedMuFile, and small test driver  z20320l3951d3633e2Compilation started: May 15, 1977  7:08 PMz20320l3951d3633e2Compile1: extra ; in a declarationz20320l3951d3633e2Compile2: missplaced global declaration in mainline test section; had to add something to take result from LoadRamAndBoot and print it also. Misspelled checkConstVecz20320l3951d3633e2\156i1ICompile3: forgot that StartIO returned a value; perhaps a naming scheme would help me to remember: e.g., two procedures, StartIO and StartIOVal for when a value is needed.z20320l3951d3633e2Compiled Correctly: May 18, 1977  10:55 PMz20320l3951d3633e2Changed by: Mitchell,  May 18, 1977  12:56 PMz20320l3316d2998e12reason: First attempt to run RamLoad on Alto II with 2K PROM caused a break to 1; simplified Mesa code in ReadRam in an attempt to be able to set more breakpoints and get my hands on the problem.  z20320l3951d3633e2Compilation started: May 18, 1977  12:57 PMz20320l3951d3633e2Compiled Correctly: May 18, 1977  1:00 PMz20320l3951d3633e2Changed by: Mitchell,  May 23, 1977  10:38 AMz20320l3316d2998e12reason: Was able to get program working, but with two kinds of unsettling behavior.  It sometimes would still dive off to never-never land, and it always finds a large number of mismatches in the constant rom.  To attack this, I have defined the record type MicroCode to allow me to have more confidence in the octal microcode in this program, and I have added some code to rpint the constants that don't match.  z20320l3951d3633e2Compilation started: May 23, 1977  10:41 AMz20320l3951d3633e2Compile1: forgot to delete some old RamWord constructors after replacing them with MicroCode constructors.z20320l3951d3633e2Compile2: mistake in ibits in CheckConstants; record was too long.z20320l3951d3633e2Compiled Correctly: May 23, 1977  11:17 AMz20320l3951d3633e2Changed by: Mitchell,  May 23, 1977  2:52 PMz20320l3316d2998e12reason: Had JMP 1,3 instead of JMP 0,3 in all the nova code   z20320l3951d3633e2Compilation started: May 23, 1977  2:52 PMz20320l3951d3633e2Compiled Correctly: May 23, 1977  2:56 PMz20320l3951d3633e2Changed by: Mitchell,  May 24, 1977  1:07 PMz20320l3316d2998e12reason: Repackaged RamLoad; moved type declarations and some procedure definitions to RamDefs; moved test driver to a separate file, TestRamLoad.  z20320l3951d3633e2Compilation started: May 24, 1977  1:08 PMz20320l3951d3633e2compile1: forgot a ; after OPEN RamDefs attached to module begin as part of removing the type definitions.z20320l3951d3633e2Compiled Correctly: May 24, 1977  1:20 PMz20320l3951d3633e2Changed by: Mitchell,  July 12, 1977  1:41 PMz20320l3316d2998e12reason: Changed to use DBOSS interfacing conventions and changed StartIO so that it no longer returns a value.  z20320l3951d3633e2Compilation started: July 12, 1977  1:44 PMz20320l3951d3633e2compile1: July 12, 1977  2:00 PM Change to StartIO was a mistake because an SIO does return a value if the enthernet board is present, SIO 0 will return the network address of the Alto.  Changed it here and will have to change it back in RamDefs also.  Forgot to include MesaDefs; misspelled RamDefs as Ramdefs in one place.z20320l3951d3633e2compile2: July 12, 1977  2:11 PM Used mesa. instead of MesaDefs. in two places where types were needed; forgot the StartIO component in the constructor for me.z20320l3951d3633e2Compiled Correctly: July 12, 1977  2:16 PMz20320l3951d3633e2Changed by: Mitchell,  September 9, 1977  11:40 AMz20320l3316d2998e12reason: Convert from dboss to Mesa 3.0  z20320l3951d3633e2Compilation started: September 9, 1977  2:14 PMz20320l3951d3633e2Compiled Correctly: September 9, 1977  2:16 PMz20320l3951d3633e2Changed by: Mitchell,  June 14, 1978  3:41 PM  Convert to Mesa 4.0z20320l3316d2998e4Changed by: Mitchell,  September 5, 1978  5:59 PM  Made WriteRam loop all Nova code so that ram could be loaded without invoking Mesa microcode.  This is necessary for using the XMesa system with wide-bodied Altos.z20320l3316d2998e4Changed by: Mitchell,  DateTime  Reasonz20320l3316d2998e4