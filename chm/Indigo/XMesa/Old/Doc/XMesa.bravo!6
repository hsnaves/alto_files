Heading:qjk40(635)Mesa for Extended Memory Altosy756qjk40\b30BPage Numbers: Yes  X: 527  Y: 10.5"qjk40Inter-Office Memorandumz18592l4445y762\f5bTo	File	Date	October 20, 1978z18592l4445d2998e21(0,65535)(1,4445)(5,11684)(6,14146)\f7 2f0t2 1t0 4t6 1f7t0 4f0t7 1t0From	Roy Levin, Chuck Geschke, Jim Mitchell	Location	Palo Altoz18592l4445d2998y716e25\f7 4f0t2 1t0 38t6 1f7t0 8f0t7 1t0Subject	Mesa for Extended Memory Altos	Organization	CSL(version 3)z18592l4445d2998e25\f7 7f0t2 1t0 30t6 1f7t0 12f0t7 1t0XEROX       z18592l508y644e14(2116)\f2 5f0Filed on: [Ivy]<XMesa>Doc>XMesa.bravoe30(0,16510)(1,65535)(5,65535)(6,65535)\f7 37f1x2e12(2116)A version of the Mesa system that exploits in certain ways the extended memory features of Alto IIs is now available.  This document describes the facilities provided by this system, its limitations, and its compatibility with other current Mesa systems.x2e12jk40(1799)The system described in this document is functionally compatible with Mesa 4.1, except as explicitly noted below.  However, we have no plans to maintain compatiblity with future releases of the Mesa system.x2e12jk40\i206IOverview of XMesax2e18jk80\b17BXMesa uses the extended memory of an Alto II XM as additional swapping space for code.  This means that code and data need not co-exist in the primary 64K of memory.  XMesa takes advantage of any available extra space automatically; standard Alto programs do not need to be modified to run with XMesa.  XMesa does not simplify the task of managing data structures that are too large to fit in 64K, but it does free (most of) the 64K primary address space for use by data. x2e12jk40Because XMesa uses extra memory for code segments, it includes a page-level storage allocator for the additional banks.  Client programs may request storage in the additional banks by using this allocator; the interface is public.  XMesa provides a primitive mechanism to permit blocks of data to be copied between banks of memory, but gives no other assistance in accessing information in the extended memory banks.x2e12jk40Clients should understand that, while XMesa is interface-compatible with Mesa 4.1, the implementation of certain system components (e.g., the page-level memory allocator and segment swapper) has changed substantially.  Client programs that assume undocumented properties of these components do so at their peril.  Information about incompatibilities in the implementation appears later in this document.x2e12jk40\f1Compatibility with Mesa 4.1x2e12jk80\iConsiderable efforts have been made to ensure that XMesa is compatible with Mesa 4.1.  Exceptions are minor and typically affect only those programs that depend upon the format of global frames (details appear below).  To enhance the value of compatibility and because wide-bodied Altos are relatively scarce, XMesa will execute properly (though with some performance degradation) on a normal Alto (I or II) without recompilation or rebinding.  Indeed, XMesa requires no special compiler or binder.  Both BCDs and image files are compatible across machines.  Thus a Mesa disk containing the XMesa versions of RunMesa.run, XMesa.image (or BasicXMesa.image and XImageMaker.bcd), and the debugger can be used without alteration on any Alto, XM or otherwise.  Specifically,x2e12jk40\609f8 11f0 2f8 11f0 5f8 16f0 5f8 15f01)	Mesa 4.1 BCDs will load and execute under XMesa,l3776x2e12jk40(0,4576)2)	Mesa 4.1 image files will run correctly under XMesa,l3776x2e2jk403)	Image files created with XMesa will run (under XMesa) on any Alto,l3776x2e2jk404)	Files created with Mesa 4.1 and XMesa may be debugged (under XMesa) on any Alto.l3776x2e2jk40Of course, these properties can be guaranteed only for programs that do not assume the existence of extended memory.x2e12jk40(1799)Note!  Compatibility is assured only for Mesa 4.1.  BCDs compiled or bound by previous releases of the Mesa system, including Mesa 4.0, will NOT work properly under XMesa.x2e12jk40\i171IThe Public Interface to XMesax2e18jk80\b29BTo preserve compatibility with Mesa 4.1, XMesa provides its services exclusively through a new interface, XMESADEFS.  However, the facilities supplied logically belong in other existing interfaces, notably SEGMENTDEFS and ALTODEFS.  Thus, XMESADEFS actually includes several semi-independent interfaces.  Unless otherwise stated, everything defined in this section comes from XMESADEFS.x2e12jk40\106f1 10f0 90f1 11f0 5f1 11f0 6f1 9f0 128f1 9f0Extended Memory Managementx2e24ck80\iSegments in extended memory are created with the usual primitives in SEGMENTDEFS.  However, XMesa recognizes additional "default" parameter values for those procedures that expect a VM base page number.  DefaultBase0, DefaultBase1, DefaultBase2, and DefaultBase3 request allocation in a specific memory bank.  DefaultXMBase requests allocation anywhere in the extended memory banks (banks 1-3).  DefaultBase (defined in SEGMENTDEFS) requests allocation anywhere in memory (banks 0-3) if the segment is a code segment, otherwise, it is equivalent to DefaultBase0.x2e12jk40\69f1 11f0 124f6b12f7 2f6 12f7 2f6 12f7 2f0B4f6b12f0B48f6b13f7 1f0B72f6b11f0B13f1 11f0 53i32I33f6b12f0BThe following procedures logically belong in SEGMENTDEFS.  They convert between segment handles and long pointers, and work for segments anywhere in the 18-bit address space.x2e12jk40\45f1 11f0XVMtoSegment: PROCEDURE [a: LONG POINTER] RETURNS [SegmentHandle];l5088d3872x2e12k80\f6b12f7 1f6 1f7 9f6 1f7 1f6 1f7 1f6 1f7 13f6 1f7 7f6 1f7 1f6 13f7 2f6XSegmentAddress: PROCEDURE [seg: SegmentHandle] RETURNS [LONG POINTER];l5088d3872x2e12k80\f6b15f7 1f6 1f7 9f6 1f7 1f6 3f7 1f6 14f7 1f6 1f7 7f6 1f7 15f6XVMtoDataSegment: PROCEDURE [a: LONG POINTER] RETURNS [DataSegmentHandle];l5088d3872x2e12k80\f6b16f7 1f6 1f7 9f6 1f7 1f6 1f7 1f6 1f7 13f6 1f7 7f6 1f7 1f6 17f7 2f6XDataSegmentAddress: PROCEDURE [seg: DataSegmentHandle]RETURNS [LONG POINTER];l5088d3872x2e12k80\f6b19f7 1f6 1f7 9f6 1f7 1f6 3f7 1f6 18f7 1f6 1f7 7f6 1f7 15f6XVMtoFileSegment: PROCEDURE [a: LONG POINTER] RETURNS [FileSegmentHandle];l5088d3872x2e12k80\f6b16f7 1f6 1f7 9f6 1f7 1f6 1f7 1f6 1f7 13f6 1f7 7f6 1f7 1f6 17f7 2f6XFileSegmentAddress: PROCEDURE [seg: FileSegmentHandle]RETURNS [LONG POINTER];l5088d3872x2e12k80\f6b19f7 1f6 1f7 9f6 1f7 1f6 3f7 1f6 18f7 1f6 1f7 7f6 1f7 15f6The following definitions logically belong in ALTODEFS.  They define parameters of the extended memory system.x2e12jk40\46f1 8f0BankIndex: TYPE = [0..3];PagesPerBank: PageCount = . . . ;MaxXPage: PageNumber = 1777B;		-- analogous to MaxVMPagel3872x2e12k80\f6b9f7 1f6 1f7 4f6 1f7 1f6 1f7 1f6 4f7 2f6 13f7 1f6 11f7 1f6 1f7 7f6 9f7 1f6 12f7 1f6 6f7 3f0Bi25f6bIThe following signal logically belongs in IMAGEDEFS, and is raised when MakeImage discovers a segment in banks 1-3 that cannot be swapped out.  (See the section on restrictions, below, for more information about image files).  If this signal is RESUMEd, MakeImage assumes that the segment in question has been removed from high memory by the client; failure to do so may result in an image file that cannot be restarted.x2e12jk80\42f1 9f0 173f1 1f6b2f0B18f7b6f0B169f6bImmovableSegmentInHighBank: SIGNAL [SegmentDefs.FileSegmentHandle];l5088d3872x2e12k80\f6b26f7 1f6 1f7 6f6 1f7 1f6 29f7 2f6Long Pointer Supportx2e24ck80\iThe following (machine code) procedures return the high and low halves of a long pointer.x2e12jk40HighHalfPtr: PROCEDURE [LONG POINTER] RETURNS [CARDINAL] ;l5088d3872x2e12k80\f6b11f7 47f6LowHalfPtr: PROCEDURE [LONG POINTER] RETURNS [POINTER] ;l5088d3872x2e12k80\f6b10f7 46f6XCOPY is analogous to COPY in INLINEDEFS, but accepts long pointers instead of pointers and moves data across memory bank boundaries.  However, not all possible pairs of pointers are permitted.  XCOPY raises InvalidXCOPY if the long pointers specify transmission between banks tobank and frombank such that tobank = frombank and tobank, frombank = 0.  (In other words, XCOPY can only handle one bank other than bank 0 at a time.)   XCOPY raises XMNotAvailable if the pointers are legal but the requested extended memory bank does not exist.  (Note:  XCOPY is a machine code procedure.)x2e12jk40\f6b5f0B17f6b4f0B4f1 10f0 155f6b5f0B8f6b12f0B57b6B5b8B11b6B1f3 1f0 1b8B5b6B2b8B1f3 1f0 1b1B20f6b5f0B58f6b5f0B8f6b14f0B91f6b5f0B30f6bXCOPY: PROCEDURE[from, to: LONG POINTER, nwords: CARDINAL] ;l5088d3872x2e12k80\f6b7f7 10f6 4f7 1f6 3f7 16f6 6f7 13f6InvalidXCOPY: ERROR;l5088d3872x2e12k80\f6b12f7 8f6XMNotAvailable: ERROR;l5088d3872x2e12k80\f6b14f7 8f6The implementation of XMesa prohibits client programs from manipulating the emulator bank register directly (see section on restrictions, below).  Clients wishing to perform a BitBlt across bank boundaries must therefore use the XBitBlt procedure, which verifies that the requested extended memory bank is available (raising XMNotAvailable if it isn't), then loads the emulator's alternate bank register with bank and performs a BitBlt.x2e12jk40\229f6b7f0B89f6b14f0B70f6b4f0B23f6bXBitBlt: PROCEDURE[bbt: BitBltDefs.BBptr, bank: XMesaDefs.BankIndex];l5088d3872x2e12k80\f6b7f7 12f6 3f7 1f6 17f7 1f6 5f7 1f6 20f7 2f6The following procedures convert between page numbers and long pointers, and are analogous to AddressFromPage and PageFromAddress in SEGMENTDEFS.  Illegal parameters are detected and cause the indicated signals to be raised.x2e12jk40\94f6b15f0B5f6b15f0B4f1 11f0 80f6bLongAddressFromPage: PROCEDURE[page: AltoDefs.PageNumber]RETURNS[lp: LONG POINTER];l5088d3872x2e12k80\f6b19f7 12f6 25f7 10f6 2f7 16f6InvalidXMPage: ERROR [page: AltoDefs.PageNumber];l5088d3872x2e12k80\f6b13f7 9f6 4f7 1f6 20f7 2f6PageFromLongAddress: PROCEDURE[lp: LONG POINTER]RETURNS[page: AltoDefs.PageNumber];l5088d3872x2e12k80\f6b19f7 12f6 2f7 24f6 4f7 1f6 20f7 2f6InvalidLongPointer: ERROR [lp: LONG POINTER];l5088d3872x2e12k80\f6b18f7 9f6 2f7 16f6Configuration Informationx2e24ck80\iXMesa has an internal data structure containing information about the hardware configuration of the Alto on which it is running.  Clients may obtain a copy of this data structure by writingx2e12jk40memoryConfig: MemoryConfig _ GetMemoryConfig[];l5088d3872x2e12k80\f6b12f7 2f6 13f7 1f6 16f7 3f6and should normally test for the existence of extended memory by examining memoryConfig.useXM.  The extant banks of memory are indicated by memoryConfig.banks, which is a bit mask (e.g. memoryConfig.banks =14B => banks 0 and 1 exist).x2e12jk40\75f6b12f0 1f6 5f0B47f6b12f0 1f6 5f0B23i4I1f6b12f0 1f6 6f7 1f6 3f0BMachineType: TYPE = {unknown, AltoI, AltoII, AltoIIXM, D0, Dorado};l5088d3872x2e12k80\f6b11f7 10f6 7f7 1f6 6f7 1f6 7f7 1f6 9f7 1f6 3f7 1f6 7f7 2f6MemoryConfig: TYPE = MACHINE DEPENDENT RECORD[reserved: [0..37B],AltoType: MachineType,useXM: BOOLEAN,unused: [0..3],secondROM: BOOLEAN,banks: [0..17B],mesaMicrocodeVersion: [0..377B],XMMicrocodeVersion: [0..377B]];l5088d3872x2e12k80\f6b12f7 34f6 9f7 3f6 6f7 2f6 9f7 2f6 11f7 1f6 6f7 10f6 7f7 3f6 4f7 2f6 10f7 10f6 6f7 3f6 6f7 3f6 20f7 3f6 7f7 3f6 18f7 3f6 7f7 3f6GetMemoryConfig: PROCEDURE RETURNS[MemoryConfig];l5088d3872x2e12k80\f6b15f7 20f6 12f7 2f6useXM is true if and only if the following conditions hold:x2e12jk40\f6b5f0B1)	the machine is an Alto II with XM modifications (AltoType = AltoIIXM),2)	the Alto has more than one memory bank installed (banks ~= 10B),3)	the Alto has a second ROM (secondROM is true), and4)	the second ROM contains the current version of the XMesa microcode.l3872x2e12jk40(0,4576)\52f6b8f0B1f7b1f0B1f6b8f0B56f6b5f0B1f7b2f0B1f6b3f0B33f6b9f0BThe microcode version fields tell only the microcode version, not the Mesa release number.  (For example, for Mesa 4.1, mesaMicrocodeVersion is 34.)  XMMicrocodeVersion will be non-zero if and only if XMesa microcode is installed in the second ROM.x2e12jk40(1799)\43i9I10i3I55f6b20f0B10f6b18f0BIf AltoType is unknown, all other fields of the record are unreliable.  This can happen only if XMesa is initialized by an obsolete version of RunMesa.x2e12jk40\3f6b8f0B4f6b7f0B48f1 81f0How to Obtain and Use XMesax2e18jk792\b27BThe files for XMesa reside on [Ivy]<XMesa>.  The subdirectory structure parallels that used on [Iris]<Mesa>, but only those files that supersede Mesa 4.1 are stored on <XMesa>.  The files on <XMesa> are organized as follows:x2e12jk40<XMesa>RunMesa.runXMesa.image, .symbols, and .signalsBasicXMesa.image,. symbols, and .signalsXMesa.cm, BasicXMesa.cm, and MakeXMDebug.cmmiscellaneous command filesl4512d3552x2e12jk40\8f8 11f0 1f8 11f0 3f8 7f0 6f8 8f0 1f8 16f0 3f8 7f0 6f8 8f0 1f8 8f0 1f8 14f0 5f8 15f0<XMesa>System>XImageMaker.bcd and .symbolssystem definitions and program modules (.mesa and .bcd)source and object code for RunMesa and microcode (mostly in .dm files)miscellaneous command filesl4512d3552x2e12jk40\15f8 16f0 3f8 9f0 41f8 5f0 5f8 4f0 62f8 3f0<XMesa>Doc>documentation for XMesal4512d3552x2e12jk40<XMesa>XDebug>modules to be installed in the Mesa 4.1 debugger (.mesa and .bcd)l4512d3552x2e12jk40\65f8 5f0 5f8 4f0RunMesa.run is required by all XMesa programs and will also run Mesa 4.1 programs without alteration.  Failure to use the XMesa version of RunMesa will cause XMesa programs to behave in unpredictable ways.x2e12jk40\f8 11f0 92i102IThe microcode that must be installed in the second control ROM is stored in <XMesa>System>XMesaROM.mb.  This file is in suitable form for use by the PROM blaster.x2e12jk40\76f8 25f0 1f1 60f0XMesa.cm and BasicXMesa.cm retrieve the corresponding image files, the debugger, and related supporting files.  MakeXMDebug.cm installs the debugger, including the modules required for debugging the XMesa environment.  (XMesa.cm and BasicXMesa.cm implicitly execute MakeXMDebug.cm as well.)x2e12jk40\f8 8f0 5f8 13f0 86f8 14f0 94f8 8f0 5f8 13f0 20f8 14f0Restrictions, Limitations, and "Features"x2e18jk80\b41BImages and Checkpoints.  MakeImage cannot preserve the contents of extended memory in the image file it constructs.  If MakeImage is invoked on an Alto II XM, it will swap out all unlocked file segements in extended memory.  (It will also move any locked code segments to primary memory.)  If any segments then remain in extended memory, MakeImage will refuse to build the image file.  Analogous comments apply to CheckPoint.x2e12jk40\i25IBank Registers.  XMesa assumes it has exclusive control of the emulator bank register.  Client programs must not attempt to alter the bank register, but rather must use the public interfaces for moving data to and from extended memory (see XCOPY and XBitBlt, above).x2e12jk40\i15I225f6b5f0B5f6b7f0BGlobal Frame Format.  The format of global frames and segment objects has changed slightly, although (for compatibility) CONTROLDEFS and SEGMENTDEFS have not been recompiled.  The formats assumed by XMesa appear in GLOBALFRAMEDEFS and XMESAPRIVATEDEFS, respectively.  The only change likely to affect client programs is the removal of the code segment handle from the third word of a global frame.  Programs that previously assumed this pointer's presence in the frame should now import CODEDEFS and replacex2e12jk40\i20I101f1 12f0 3f1 12f0 67f1 15f0 5f1 16f0 236f1 8f0frame.codesegmentl7200x2e4jk40\f6b17f0Bbyx2e4jk40CodeDefs.CodeHandle[frame]    .l7200x2e4jk40\f6b19f7 1f6 5f7 1f0BSegment Alignment.  Segments may not cross bank boundaries.x2e12jk40\i18IResident Code.  The amount of resident code in XMesa is 6 pages greater than in Mesa 4.1.  Accordingly, XMesa may exhibit poorer swapping performance on non-XM Altos than Mesa 4.1 does.x2e12jk40\i14IOld Mesa System Modules.  Any Mesa BCD for which an XMesa version exists must not be used under XMesa.  No check for inappropriate BCDs is made and unpredictable results may occur.  BasicXMesa users:  if you make image files, be certain to obtain XImageMaker.bcd.x2e12jk40\i24I223f8 15f0Debugger Incompatibilities.  The Mesa 4.1 version of XDebug cannot be used with XMesa unless the module XMDebug.bcd is loaded when the debugger is installed.  In addition, the debugger's CoreMap command does not work at all under XMesa.  The UserProc XCoreMap should be installed in the debugger and used instead.  The command file MakeXMDebug.cm will install the debugger properly for use with XMesa.x2e12jk40\i27I77f8 11f0 136f8 8f0 73f8 14f0Microcode ROMs.  RunMesa determines whether the microcode contained in the Alto's second control ROM (if any) is suitable to run XMesa, and will set memoryConfig.useXM accordingly.  (See the section entitled Configuration Information, above.)  However, old versions of RunMesa (before 29.16.3) do not contain the necessary safety checks, and will cause XMesa to execute incorrectly on a machine that contains improper microcode (useXM will erroneously be TRUE).  This will cause unpredictable results.  XMesa clients should ensure that they have an up-to-date version of RunMesa.run.  In particular, if XMesa is loaded by RunMesa 29.16.3, it can execute successfully on an Alto II XM with standard Mesa 4.1 microcode in the second ROM, but it cannot take advantage of the additional memory banks.  If XMesa is loaded by an older version of RunMesa on such a machine, it will behave unpredictably.x2e12jk40\i15I134f6b18f0B41i25I196f6b5f0B21f7b4f0B112f8 11f0 3f1 311f0Microcode in the RAM.  The microcode to support XMesa occupies slightly more than 1K of control memory space.  Most of it resides in the second 1K of control ROM (ROM1), with the excess overflowing into the RAM.  The remaining RAM space is available to users who wish to write their own microcode, but certain conventions must be observed.  Those who need to execute special microcode from Mesa programs should consult [Ivy]<XMesa>Doc>Microcode.press (and .bravo).x2e12jk40\i21I442f1 1f0Swapper Algorithms.  The XMesa swapper loads a segment into extended memory by first swapping it into primary memory, then copying it to extended memory and releasing the primary memory space.  Thus, if primary memory is so full that the requested segment cannot be swapped in, InsufficientVM will be raised, even though sufficient space for the segment may exist in other banks.  (Analogous comments apply when swapping out segments that must be written to disk.)x2e12jk40\i19I259f6b14f0Bx2e12jk40(2116)Distribution:CSLMesa Groupl3528d2998x2e12k80