// IfsTelnetInit2.bcpl -- instance initialization and cleanup// Copyright Xerox Corporation 1979, 1980, 1981, 1982// Last modified September 18, 1983  1:29 PM by Taftget "Pup.decl"get "IfsRs.decl"get "IfsTelnet.decl"get "IfsFiles.decl"external[// outgoing proceduresInitTelnetJob; CleanupTelnetJob// incoming proceduresTelnetErrors; TelnetOtherPup; PluralCreateUserInfo; DestroyUserInfo; DestroyJobCloseBSPSocketActiveJobs; PrintIFSVersionInitRingBuffer; FreePointer; PutTemplate; BlockPuts; Allocate; Free; SetBlock; Zero; SysErr// incoming staticssysZone; dsp; telnetEvents; noLoginKT; maxJobs; offsetBSPStr]//---------------------------------------------------------------------------let InitTelnetJob(ctx) be//---------------------------------------------------------------------------// Initializes an instance of a Telnet job[ctx>>TCtx.bspStream = ctx>>TCtx.bspSoc + offsetBSPStrctx>>TCtx.bspStream>>ST.error = TelnetErrorsctx>>TCtx.bspSoc>>BSPSoc.bspOtherPupProc = TelnetOtherPupctx>>TCtx.bspSoc>>BSPSoc.par1 = ctxctx>>TCtx.userInfo = CreateUserInfo()let buf = Allocate(sysZone, lenTypeinBuf)InitRingBuffer(lv ctx>>TCtx.iRBD, buf, lenTypeinBuf)ctx>>TCtx.topKT = noLoginKTctx>>TCtx.initialized = true  // Let TelnetProcess work on itlet activeJobs = ActiveJobs()Puts(dsp, $*n)PrintIFSVersion(dsp, "Executive")PutTemplate(dsp, "; $D user$S out of $D.", activeJobs, Plural(activeJobs), maxJobs)]//---------------------------------------------------------------------------and CleanupTelnetJob(ctx) be//---------------------------------------------------------------------------// Cleans up and kills a Telnet job[ctx>>TCtx.initialized = false  // disable telnet processinglet oldEvents = telnetEvents  // wait for telnet process to finishBlock() repeatwhile oldEvents eq telnetEventsFreePointer(lv ctx>>TCtx.iRBD.buffer)DestroyUserInfo(ctx>>TCtx.userInfo)CloseBSPSocket(ctx>>TCtx.bspSoc, (ctx>>TCtx.timeout? 0, telnetPutsTimeout))DestroyJob()  // self-destruct]