Heading:qjk40(635)Alto-1822 Interface, Software Interfacey756qjk40Page Numbers: Yes  X: 527  Y: 10.5"qjk40Inter-Office Memorandumz18592l4445y762\f5bTo	Taft, Boggs, Hunt	Date	March 30, 1978Strollo, Stewartz18592l4445d2998e21(0,65535)(1,4445)(5,11684)(6,14146)\f1 2f0t2 1t0 17t6 1f1t0 4f0t7 1t0From	Larry Stewart	Location	Palo Altoz18592l4445d2998y716e25\f1 4f0t2 1t0 13t6 1f1t0 8f0t7 1t0Subject	Alto-1822 Interface	Organization	SSLz18592l4445d2998e25\f1 7f0t2 1t0 19t6 1f1t0 12f0t7 1t0Microcode & Emulator Interfacez18592l4445XEROX       z18592l508y644e14(2116)\f2 5f0Filed on: [Maxc1]<LStewart>AISwSpec.presse30Abstracte22\b8BThe Alto-1822 interface is now substantially working.  This memo describes what is hoped to be the final interface specification.  The bit patterns used to control it are unlikely to change again.  Naturally, the emulator interface depends on the 1822 microcode.  Included here is the microcode written for the 1822 test program, which may provide a plausible base for other situations.e10j\171i8IGeneral Notese22\b13BHardware:l4000d2999e16jk40\iThe Alto-1822 interface is a processor bus device requiring a single Task.  It is designed to conform to the requirements of BBN Report 1822.  As such it is suitable for Arpanet or Packet Radio Net use. The interface is a full duplex device with no buffering beyond 16 bit input and output shift registers.  1822 specifies a bit-by-bit handshaking protocol intended to allow interconnection of machines with different word lengths - data transfer may pause for essentially arbitrary intervals (i.e. seconds) between any two bits.e10jk40Performance:l4000d2999e16jk40\iThe input and output data transfer sections of the interface are controlled by PROM based finite state machines clocked by the Alto at 170 ns intervals.  With zero delays at the IMP end the input and output sections can each transfer a bit every six cycles - just under 1 Megabit per second.  Actual transfer rates will be somewhat less.  In loopback mode the throughput is about 680 Kb/s.e10jk40Hardware - Microcode Interfacee22k70\b30BControl of the hardware is accomplished through the emulator SIO instruction and various Task Specific F1's and F2's.  The SIO/wakeup/branch logic is controlled by a PROM based finite state machine.  Included here is a rather low level description of what the various functions and SIO's do.  It is recommended that the reader look at the next section, describing the emulator interface of the test microcode before starting off to write his own!e10jk40SIO functions:l3008e16jk40\iThe interface task wakeup logic responds to bits 5 and 6 of the Bus during execution of an SIO (Task 0 STARTF):l3008e10jk40SIO #3000 sets wakeup and arranges for the IBRNCH function to put '01' on NEXT[6-7].  In the attached microcode, this operation is used to start the 'Control' microcode.  This wakeup is cleared by ISWAKCl5270d4269e10jk40SIO #2000 sets wakeup and arranges for the IBRNCH function to put '00' on NEXT[6-7].  In the attached microcode, this operation is used to start the 'Start Input' microcode.  This wakeup is cleared by ISWAKCl5270d4269e10jk40SIO #1000 enables the output hardware in such a way that wakeup is set and the IBRNCH function will put '10' on NEXT[6-7].  In the attached microcode, this operation is used to start an output data transfer.  This wakeup is cleared by IOCLR.l5270d4269e10jk40Task Specific Functions:l3008e16jk40\iIBRNCH (F2-13):l3008e10jk40Gates two bits from the Control PROM to NEXT[6-7].l5568d4278e4jk40'00' - caused by SIO #2000 'Input Start'l5568d4269jk40(635)'01' - caused by SIO #3000 'Control'l5568d4269jk40'10' - caused by output hardware data request and (indirectly) by SIO #1000 'Output Start'l5568d4269jk40'11' - caused by input hardware data availablel5568d4269jk40(2116)ISWAKC (F2-14):l3008e10jk40Clears wakeups generated by SIO #2000 and SIO #3000 onlyl5568d4269e6jk40(635)\52i4IIPOSTF (F1-14):l3008e10jk40(2116)Gates hardware status to the Bus.l5568d4269e6jk40(635)Bit 15: IMP Relay WAS off, it may still be off.l5568d4269jk40Bit 16: IMP Ready Relay is OPEN (off)l5568d4269jk40Bit 17: Host Ready flipflop is OFF (and so is the relay)l5568d4269jk40Other bits are left as 1's.l5568d4269jk40ISETCS (F2-11):l3008e10jk40(2116)Decodes the Bus to set and clear various controls in the interface.l5568d4269e6jk40(635)#000000 - Does nothingl5568d4269jk40#000001 - Master Reset. Clears all wakeups, turns off all data transfers, but does not affect the relay.l5568d4269jk40#000002 - Set Last Word.  Used after an IWRITE, this will set the 'LastWord' flipflop, causing 'LastHostBit' to be transmitted at the end of the current data word.l5568d4269jk40#000003 - Try Clearing ImpWasDown.  If the Imp is now READY, this will clear the 'Imp Was Down' status bit.  Otherwise it won't.l5568d4269jk40#000004 - Turn on Hardware LoopBackl5568d4269jk40#000005 - Turn off Hardware LoopBackl5568d4269jk40#000006 - Turn on Host Ready Relayl5568d4269jk40#000007 - Turn off Host Ready Relayl5568d4269jk40#002000 - Turn on Discard Flipflop (see IPTMOD)l5568d4269jk40#001000 - Turn off Discard Flipflopl5568d4269jk40Other bit patterns are undefined.l4000d2999e10jk40(2116)IPTMOD (F2-10):l3008e10jk40Gates the 'Discard' flipflop to NEXT[7].  In the attached microcode this operation is used during Packet Discard Mode to dispatch to a different section of input data transfer microcode.l4256e6jk40(635)IOCLR (F1-15):l3008e10jk40(2116)Resets the output finite state machine to StateIdle.  Commonly used to clear output data wakeup.l4256e6jk40(635)IWRITE (F1-16):l3008e10jk40(2116)Loads the output data shift register from the Bus and starts an output data transfer.l4256e6jk40(635)IIENBL (F2-12):l3008e10jk40(2116)Turns on the input hardware; requesting a single 16 bit word be read.  After 16 bits have been read, or LastImpBit received, an input data wakeup will occur.l4256e6jk40(635)IREAD (F1-17):l3008e10jk40(2116)Gates the input shift register to the Bus.  If LastImpBit did not arrive, the data wakeup is cleared.  If LastImpBit did arrive, a '1' is gated to NEXT[7] and the wakeup is not cleared.  In this case, a second IREAD will clear the wakeup.  The second IREAD will never disturb NEXT.l4256e6jk40(635)\62i3I52i3I39i3I1i21IEmulator - Task interfacee10k70(2116)\b25BThis section describes the emulator interface implemented by 'AIuCode.mu', attached to this memo.e10k40An emulator program can wake up the IMP task by executing an SIO instruction with either or both of AC0 bits 5 and 6 set.  Possible functions are start receiver, start transmitter, and read status/set control register.  AC1 is must point to a command block during the execution of the Read Status / Set Control Register SIO.  The task saves the control block pointer in an S register for later use.  This means that a read status call must be made before trying to do a data transfer!e10jk40\285i34I129i6IIn order to hold the use of S registers to a minimum, both input and output buffer pointers are kept in main memory.  This means that input/output operations require three main memory cycles per word.  The single S register contains a pointer to the 12 word control block.  The single control block contains entries for input, output, and control functions.e10jk40	Control Block Structuree10k40(635)\iThe command block must be on an even word (for Alto I compatibility).e10jk40(2116)	CmdBlock:	struct		[			controlWord	//command			blank			InputPointer	//next word to be used			InputBufferEnd	//first word not in buffer			OutputPointer	//next word to be used			OutputBufferEnd	//first word not in buffer			ControlPost	//control post location			ControlIntBits	//control interrupt channels			InputPost	//input post location			InputIntBits	//input interrupt channels			OutputPost	//output post location			OutputIntBits	//output interrupt channels		]e22k40(0,3648)(1,5568)(2,6464)(3,11264)(5,65535)(6,65535)Start receivere10k40(635)\i14IThe receiver will collect a packet from the IMP.  The final buffer location used ( +1 ) is returned in inputPointer.  Returns error if the buffer size is zero on entry, or if the buffer overflowed.e10jk40	LDA	AC0,#002000	SIOe10k40(0,3648)Start transmittere10k40(635)\i17IThe transmitter will send a packet (buffer) to the IMP.  If the buffer length is zero, no bits will be sent, and the returned status will indicate sucessful completion.e10jk40	LDA	AC0,#001000	SIOe10k40(0,3648)Read Status / Set Control Registere10k40(635)\i34IThis command allows an emulator program to observe the interface without disturbing it.  It is also used to tell the microcode where the command block is.  The command word is used to set and clear some control flip-flops in the hardware.e10jk40	LDA	AC0,#003000	LDA	AC1,CmdBlock  //(pointer to)	SIOe10k40(0,3648)Post Datae10k40(635)\i9IOn completion of a command, the microcode status occupies the left byte of the Post location and the hardware status occupies the right byte.e10k40Possible microcode status bytes:e10k40	00000001	-	all ok	00000010	-	buffer overflow (input only)	00000011	-	input buffer length was zero on entrye10k40Hardware status bits:e10k40	struct		[		unused			bit	5;   //These bits come back as 1's		IMPWasDown	bit	1;		IMPnotReady	bit	1;		HostnotReady	bit	1;		]e10k40Command Worde10k40\i12IThe command word is used to set and clear some control flipflops in the hardware.  Except for SetLastWord, these functions are never used by the microcode.e10k40Possible command words:e10k40	0		does nothing	1		hardware master reset	2		set last word - causes Last Host Bit to appear eventually				(intended for use by microcode only)	3		try clearing IMP Was Down flop				(will not work if the IMP is still down)	4		turn on test mode - hardware loop back				(beware: this mode holds the Host ready line off)	5		turn off test mode	6		turn on Host Ready relay	7		turn off Host Ready relay	2000	turn on packet throwaway mode	1000	turn off packet throwaway modee10k40\70i13I80i12I183i10I20i10IPacket Throwaway Mode:e16k40\iBy executing an SIO-set control function, the user may set the receiver hardware into "Packet Throwaway Mode".  On each SIO-start receiver call (until the throwaway mode is cleared), the microcode will read in a packet (i.e. until the next Last Imp Bit) and throw it away.  Although it is not used, the input buffer must have some space in it.e10jk40(2116)\240i12IZero buffer length:e16k40(635)\iOn output, there is no longer any initialization microcode - the SIO reaches down into the output finite state machine and makes it think it was running already.  The FSM then requests a normal output data wakeup to get the first word.  Thus if the buffer size is zero, on that first wakeup the microcode will conclude that transmission is done and return normal end status - without having done anything.  On input, while a zero length buffer probably represents a programming error, the microcode will return a bad status.  If the receiver were actually started with a zero size buffer, the condition would not be noticed until the first input data wakeup.  At that time, the microcode would have no choice but to throw away the input word and return a buffer overflow error - the entire packet would be messed up.  With the current microcode, you can request input into a zero length buffer, get an error status back, and restart the operation with a non-zero buffer without losing data.e10jk40(2116)\970i7IMicrocode timinge18(635)\f5bA copy of the newest microcode is attached.  The code uses one S register.  I include here a table of timing information.  A '+' indicates a TASK.e18jOperation		Microcyclese16(0,7104)(1,12800)(2,15072)(3,12800)(4,7136)\uEmulator control/status call		15Emulator input request		(Buffer length zero)	17Emulator input request		(Buffer length non-zero)	12Emulator output request		 0Input wakeup		(Buffer Overflow)	20Input wakeup		(Normal)	18Input wakeup		(Last word)	18+10		(wierd kludge)Input wakeup		(Normal throwaway)	13Input wakeup		(Last throwaway)	13+10Output wakeup		(Normal)	18Output wakeup		(Last word)	18Output wakeup		(Normal end)	19e16(0,8288)\57f7 20f0 28f7 24f0 46f7 17f0 17f7 9f0 18f7 11f0 8f7 14f0 15f7 18f0 17f7 17f0 22f7 8f0 19f7 11f0 19f7 12f0Microcodee12jk280(2116)\f5b9f0B; Larry Stewart March 25, 1978  11:37 PM#AltoConsts23.mu;; Address definition for Emulator main loop in ROM$START $L004020,000000,000000 ; Start of emulator main loop; Task Specific Function Definitions$IREAD $L000000,070017,000100 ; F1-17	Input data$IWRITE$L020016,000000,124000 ; F1-16	Output data$IOCLR $L016015,000000,000000 ; F1-15	Clear hardware output wakeup$IPOSTF$L016014,066014,000100 ; F1-14	Post (gate status to bus)$ISWAKC$L024014,000000,000000 ; F2-14	Clear SIO generated wakeup$IBRNCH$L024013,000000,000000 ; F2-13	4-way branch on wakeup$IIENBL$L024012,000000,000000 ; F2-12	Start read (turn on RFNIB)$ISETCS$L024011,000000,000000 ; F2-11	Set control functions from bus$IPTMOD$L024010,000000,000000 ; F2-10	2-way branch on throwaway mode;R (S) registers$ICBPTR$R76;	Control Block Pointer$MTEMP $R25;	Temporary storage$AC1   $R2;	Emulator register$NWW   $R4;	Interrupt system reg; Task constants$ISDON $777;	done$ISOVF $1377;	buffer overflow (input only)$ISIBLZ$1777;	block length zero (input only); Initialization for putting this code in the RAM, including    ; 'silent boot' code!17,20,LOC0,IMLOOP,,,,,,,,,,,,,,;;Silent Boot code, branches to ROM immediatelyLOC0:	SWMODE;	:START;;Main loop.  Task waits here when not processing anything.;IBRNCH gates two bits onto NEXT6 and NEXT7    ;    00 - Start input  01 - Set Control    ;    10 - Output data wakup  10 - Input data wakeup; 4-way branch using NEXT6,NEXT7 (Caused by IBRNCH)%14,14,0,IISTRT,ICTST,IODATA,IIDATA;IMLOOP:	T_ ICBPTR,IBRNCH;	test wakeup conditions	L_ ISDON,:IISTRT;	[IISTRT,ICTST,IODATA,IIDATA];Common Post routine    ; Expects offset of post location in T    ;	and task status in M;IPOSTF gates hardware status bits to the bus; 2-way branch using NEXT9 (Caused by SH=0)!1,2,IIBLOK,IPOST;IPOST:	MAR_ ICBPTR+T;	Start double reference	T_ NWW;	MD_ M,IPOSTF;	Bus AND hardware status	L_ MD OR T,TASK;	NWW OR interrupt bitsINXT:	NWW_ L,:IMLOOP;;Read status and set control register;ISWAKC clears a wakeup caused by an SIO instruction;ISETCS loads hardware control flops from the busICTST:	MAR_ L_ AC1;	Start fetch of args	ICBPTR_ L;	Save ctl block pointer	T_ 6,ISWAKC;	post location offset	SINK_ MD,ISETCS;	Control functionINEND:	L_ ISDON,:IPOST;	Set control flops;Input initialization;IIENBL enables the hardware to receive a 16 bit word (turns it on)IISTRT:	MAR_ 2+T;	ISWAKC;	clear wakeup	T_ MD;	read data pointer	L_ MD-T;	L_ ISIBLZ,SH=0;	T_10,:IIBLOK;	[IIBLOK,IPOST]IIBLOK:	L_ NWW,IIENBL,TASK,:INXT;	length ok,start reader;Input Main loop;IPTMOD gates the state of the Throwaway mode flop to NEXT7    ;   The branch is taken if the flop was set (by an ISETCS);IREAD gates the receiver shift register to the bus    ;  and the PAD flop to NEXT7    ;  If the branch is taken (which happens when the last word of    ;  a packet is read), the wakeup will not be cleared, otherwise    ;  the wakeup will be cleared; 2-way branch using NEXT9 (Caused by SH=0)!1,2,IIDMOR,IIDFUL;; 2-way branch using NEXT7 (Caused by IPTMOD)%4,4,0,IIACPT,IIDISC;; 2-way branch using NEXT7 (Caused by IREAD)%4,4,0,IIDCON,IIDLST;; another 2-way branch using NEXT7 (Caused by IREAD)%4,4,0,IIFINS,IIDPST;IIDATA:	MAR_ L_ 2+T;	Start fetch	MTEMP_ L,IPTMOD;	save cb ptr,test mode	T_ MD;	get pointer [IIACPT,IIDISC]IIACPT:	L_ MD-T;	past end of buffer?	MAR_ T,SH=0;	start data fetch	L_ ONE+T,:IIDMOR;	[IIDMOR,IIDFUL]IIDMOR:	MD_ IREAD;	Read and branch on last word.    ;	Except on the last word, this    ;	clears the wakeupIICLNU:	MAR_ MTEMP,:IIDCON;	[IIDCON,IIDLST]IIDCON:	IIENBL,TASK;	enable receiverIDCON:	MD_ M,:IMLOOP;	update ptr,restartIIDLST:	TASK;	this TASK only works    ;	because the hardware doesn't really clear the    ;	wakeup until the next IREAD in this case	MD_ M;	update pointer	L_ ISDON;IIDPST:	SINK_ IREAD;	clear wakeup (again)IIFINS:	T_ 10,:IPOST;IIDISC:	L_ T, T_ IREAD,:IICLNU;	throwaway word,branch if lastIIDFUL:	SINK_ IREAD;	overflow status	L_ ISOVF,:IIFINS;	[IIFINS,IIDPST];Main output loop;IWRITE loads the output shift register from the bus,    ;  clears the (hardware generated) wakeup if there was one,    ;  and starts the output hardware;IOCLR resets the output hardware.  This is how you clear the    ;   wakeups without restarting the output hardware; 2-way branches using NEXT9 (both caused by SH=0)!1,2,IODMOR,IODEND;!1,2,IONLST,IOLST;IODATA:	MAR_ L_ 4+T;	start pointer fetch	MTEMP_ L;	save cb ptr	T_ MD,IOCLR;	get pointer, clear wakeup	L_ MD-T;	past end of buffer?	MAR_ T,SH=0;	start data fetch	L_ M-1,:IODMOR;	[IODMOR,IODEND]IODMOR:	IWRITE_ MD,SH=0;	send data,last?	MAR_ MTEMP,:IONLST;	start update [IONLST,IOLST]IOLST:	SINK_ 2,ISETCS;	set last word functionIONLST:	L_ ONE+T,TASK,:IDCON;	finishIODEND:	T_ 11+1,:INEND;	offset of post loc(0,4798)(1,11959)(2,65535)(3,65535)(4,65535)\f8 1132b1B105b59B198b1B36b7B92b21B162b1B19b5B151b38B105b5B183b22B70b6B175b17B424b1B66b1B67b1B75b1B22b6B550i4I256b18B327b1B19b1B19b6B