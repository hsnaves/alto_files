; Mesa1822.mu; Alto 1822 Interface microcode;   Version for scatter/gather;   Version for Mesa;   Last modified September 1, 1978  5:10 PM for gateway mc package; Mesa emulator conventions	duplicate definitions$stkp	$R16;	Stack pointer (0 = empty, 10 = full)$stk0	$R60;	Stack (bottom);R (S) registers used by 1822$ICBPTR$R76;	Control Block Pointer$MTEMP $R25;	Temporary storage$NWW   $R4;	Interrupt system reg; Task Specific Function Definitions$IREAD $L000000,070017,000100 ; F1-17	Input data$IWRITE$L020016,000000,124000 ; F1-16	Output data$IOCLR $L016015,000000,000000 ; F1-15	Clear hardware output wakeup$IPOSTF$L016014,066014,000100 ; F1-14	Post (gate status to bus)$ISWAKC$L024014,000000,000000 ; F2-14	Clear SIO generated wakeup$IBRNCH$L024013,000000,000000 ; F2-13	4-way branch on wakeup$IIENBL$L024012,000000,000000 ; F2-12	Start read (turn on RFNIB)$ISETCS$L024011,000000,000000 ; F2-11	Set control functions from bus$IPTMOD$L024010,000000,000000 ; F2-10	2-way branch on throwaway mode; Task constants$ISDON $777;	done$ISFUL $1377;	buffer full (input only)$ISIBLZ$1777;	block length zero (input only)$ISFDON$2377;	input full and end of packet; SetControlPointer: PROCEDURE[controlBlockPointer: WORD]; Sets the 1822 Task control block pointer.; notes: "Emulator" is defined in MesaGateXXX.mu;        Entry point is defined in MesaGateXXX.muSetConPtr:	L_ stk0;	Set BLV from arg on stack	ICBPTR_ L;	Set BLV from arg on stack	L_ stkp-1,TASK;	stkp_ stkp-1	stkp_ L,:Emulator;	finish; note: "Emulator" is defined in MesaGateEia.mu; **** 1822 Task ****;Main loop.  Task waits here when not processing anything.;IBRNCH gates two bits onto NEXT6 and NEXT7    ;    00 - Start input  01 - Set Control    ;    10 - Output data wakup  10 - Input data wakeup; 4-way branch using NEXT6,NEXT7 (Caused by IBRNCH)%14,14,0,IISTRT,ICTST,IODATA,IIDATA;IMLOOP:	T_ ICBPTR,IBRNCH;	test wakeup conditions	L_ ISDON,:IISTRT;	[IISTRT,ICTST,IODATA,IIDATA];Common Post routine    ; Expects offset of post location in T    ;	and task status in M;IPOSTF gates hardware status bits to the bus; 2-way branch using NEXT9 (Caused by SH=0)!1,2,IIBLOK,IPOST;IPOST:	MAR_ ICBPTR+T;	Start double reference	T_ NWW;;;	MD_ M,IPOSTF;	Bus AND hardware status	L_ MD OR T,TASK;	NWW OR interrupt bitsINXT:	NWW_ L,:IMLOOP;;Read status and set control register;ISWAKC clears a wakeup caused by an SIO instruction;ISETCS loads hardware control flops from the busICTST:	MAR_ T;	Start fetch of args	T_ 6,ISWAKC;	post location offset	SINK_ MD,ISETCS;	Control functionINEND:	L_ ISDON,:IPOST;	Set control flops;Input initialization;IIENBL enables the hardware to receive a 16 bit word (turns it on)IISTRT:	MAR_ 2+T;	ISWAKC;	clear wakeup;;	T_ MD;	read data pointer	L_ MD-T;	L_ ISIBLZ,SH=0;	T_10,:IIBLOK;	[IIBLOK,IPOST]IIBLOK:	L_ NWW,IIENBL,TASK,:INXT;	length ok,start reader;Input Main loop;IREAD gates the receiver shift register to the bus    ;  and the PAD flop to NEXT7    ;  If the branch is taken (which happens when the last word of    ;  a packet is read), the wakeup will not be cleared, otherwise    ;  the wakeup will be cleared; 2-way branch using NEXT9 (Caused by SH=0)!1,2,IIDMOR,IIDFUL;; 2-way branch using NEXT7 (Caused by IREAD)%4,4,0,IIDCON,IIDLST;; another 2-way branch using NEXT7 (Caused by IREAD)%4,4,0,IIFINS,IIBFDN;IIDATA:	MAR_ L_ 2+T;	Start fetch	MTEMP_ L;	save cb ptr	T_ MD;	get pointer	L_ MD-T-1;	at end of buffer?	MAR_ T;	start data store	L_ ONE+T,SH=0;	MD_ IREAD,:IIDMOR;	[IIDMOR,IIDFUL]    ;	Read and branch on last word.    ;	Except on the last word, this    ;	clears the wakeupIIDMOR:	MAR_ MTEMP,:IIDCON;	[IIDCON,IIDLST]IIDCON:	IIENBL,TASK;	enable receiverIDCON:	MD_ M,:IMLOOP;	update ptr,restartIIDLST:	TASK;	this TASK only works    ;	because the hardware doesn't really clear the    ;	wakeup until the next IREAD in this case	MD_ M;	update pointerIIDPST:	L_ ISDON;IIWCLR:	SINK_ IREAD;	clear wakeup (again)IIFINS:	T_ 10,:IPOST;IIDFUL:	L_ ISFUL,:IIFINS;	[IIFINS,IIBFDN]IIBFDN: TASK;	NOP;	L_ ISFDON,:IIWCLR;;Main output loop;IWRITE loads the output shift register from the bus,    ;  clears the (hardware generated) wakeup if there was one,    ;  and starts the output hardware;IOCLR resets the output hardware.  This is how you clear the    ;   wakeups without restarting the output hardware;IPTMOD gates the state of the Throwaway mode flop to NEXT7    ;   The branch is taken if the flop was set (by an ISETCS); 2-way branches using NEXT9 (both caused by SH=0)!1,2,IODMOR,IODEND;!1,2,IONLST,IOLST;; 2-way branch using NEXT7 (Caused by IPTMOD)%4,4,0,IOBFUL,IOBEND;IODATA:	MAR_ L_ 4+T;	start pointer fetch	MTEMP_ L;	save cb ptr	T_ MD,IOCLR;	get pointer,clear wakeup	L_ MD-T;	past end of buffer?	MAR_ T,SH=0;	start data fetch	L_ M-1,:IODMOR;	[IODMOR,IODEND]IODMOR:	SH=0;	Last word?	IWRITE_ MD,:IONLST;	send data [IONLST,IOLST]IONLST:	MAR_ MTEMP;	clear wakeupIOBFUL:	L_ ONE+T,TASK,:IDCON;	go aroundIOLST:	MAR_ MTEMP,IPTMOD;	start update	L_ ONE+T,:IOBFUL;	[IOBFUL,IOBEND]IOBEND:	SINK_ 2,ISETCS;	do last bit function,(if IPT)	MD_ M,TASK;	update pointer	NOP,:IMLOOP;	restartIODEND:	T_ 11+1,:INEND;	offset of post loc(0,4798)(1,11959)\b14B1377b9B182b33B47b1B198b1B36b7B92b21B162b1B19b5B155b38B105b5B143b22B70b6B179b17B300b1B65b1B75b1B22b6B509i4I210b18B451b1B19b1B65b1B22b6B