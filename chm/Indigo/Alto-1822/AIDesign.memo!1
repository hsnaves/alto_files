Heading:qjk40(635)Proposed Alto-1822 Interfacey756qjk40Page Numbers: Yes  X: 527  Y: 10.5"qjk40Inter-Office Memorandumz18592l4445y762\f5bTo	Distribution	Date	January 2, 1978z18592l4445d2998e21(0,65535)(1,4445)(5,11684)(6,14146)\f1 2f0t2 1t0 12t6 1f1t0 4f0t7 1t0From	Larry Stewart	Location	Palo Altoz18592l4445d2998y716e25\f1 4f0t2 1t0 13t6 1f1t0 8f0t7 1t0Subject	Alto-1822 Interface	Organization	SSLz18592l4445d2998e25\f1 7f0t2 1t0 19t6 1f1t0 12f0t7 1t0Request for Commentsz18592l4445XEROX       z18592l508y644e14(2116)\f2 5f0Filed on: [Maxc1]<LStewart>AIdesign.presse30Abstracte10\b8BThis memo describes my proposed design for the Alto-1822 interface.  A previous memo (November 17, 1977, filed on [IFS]<LStewart>PR>AltoIMP.bravo, AltoIMP.press) gave some preliminary thoughts on implementation and laid down some rough specs.  The potential uses for the interface are for a Packet Radio Net gateway, and for a direct MAXC2 Arpanet connection.e10Stylee10\b5BThe interface is an Alto processor bus device, task driven and should be capable of speeds up to about 1 Megabit.  The interface is full duplex.e10Emulator - Task interfacee10\b25BAn emulator program can wake up the IMP task by executing an SIO instruction with either or both of AC0 bits 5 and 6 set.  AC1 is must point to a command block during the execution of the SIO.  Possible functions are start receiver, start transmitter, and read status/set control register.  The IMP task must run before AC1 can be changed (i.e. the IMP task must be higher priority - which is assured).e10Start receivere10(635)\i14IThe receiver will go off and collect a packet from the IMP.  The final buffer location used is returned in lvBuffer.  Returns error if the buffer size is zero, if the buffer overflowed, or if the receiver seems to be running already.e10	LDA	AC0,#001000	LDA	AC1,readCmdBlock	SIO	readCmdBlock:	struct		[			BufferSize	/buffer size in words			lvBuffer	/buffer pointer			Post	/place to leave status			interruptBits	/channels to interrupt				/on completion		]e10(0,3648)(1,5568)(2,6464)(3,11264)(5,65535)(6,65535)Start transmittere10(635)\i17IThe transmitter will send a packet (buffer) to the IMP without further attention.  Returns error if the buffer size is zero or if the transmitter seems to be running already.e10	LDA	AC0,#002000	LDA	AC1,writeCmdBlock	SIO	writeCmdBlock:	struct		[			BufferSize	/buffer size in words			lvBuffer	/buffer pointer			Post	/place to leave status			interruptBits	/channels to interrupt				/on completion		]e10(0,3648)Read Status / Set Control Registere10(635)\i34IThis command allows an emulator program to observe the interface without disturbing it.  The command word can do things like reset the interface to ground zero, turn on the Host Ready relay, etc.e10	LDA	AC0,#003000	LDA	AC1,CmdBlock	SIO	CmdBlock:	struct		[			controlWord	/command			Post	/place to leave status			interruptBits	/channels to interrupt				/on completion		]e10(0,3648)Post Datae10(635)\i9IAfter the style of the ethernet, on completion of a command, the microcode status occupies the left byte of the Post location and the hardware status occupies the right byte.e10Possible microcode status bytes:	00000000	-	all ok	00000001	-	hardware seemed to be busy already	00000010	-	buffer overflow (input only)	00000011	-	buffer length was zero on entrye10Hardware status bits:	struct	[		unused			bit	5;		IMPWasDown	bit	1;		IMPnotReady	bit	1;		HostnotReady	bit	1;	]e10Command Worde10\i12IThe command word is used to set and clear some control flipflops in the hardware.  Some of these, like TestMode and HostReadyRelay, will never be touched by the microcode - they are to be used by an emulator program.  Others, like SetLastWord, are intended to be used only by the microcode and should never appear in a command.e10\268i4ICommand Bits:	struct	[		unused	byte;		turnOnReadyRelay	bit;		turnOffReadyRelay	bit;		turnOnTestMode	bit;		turnOffTestMode	bit;		unused	bit;		resetWorld	bit;		setLastWord	bit;		tryClearingIMPdownFlop	bit;	]e10(0,3648)(1,4256)(2,10208)(3,65535)Microcodee18(635)\f5bA copy of my preliminary microcode is attached.  The code uses 7 S registers, the longest path between TASKs is about 11 microinstructions.  In order to handle the full duplex hardware, the task mostly waits just before a 16-way branch. Two SIO bits and two hardware wakeup bits are OR'ed into NEXT by the branch.  The microcode is largely self-explanatory (to those in the know).e18Hardwaree12jk40(2116)\f5b8f0BAttached are the Sil drawings of the proposed design (no pin numbers as yet).  The hardware consists of two PROM driven finite state machines, one each for input and output.  In addition, there are the parts necessary to interface with the Alto processor bus, a software controlled loop-back feature, and line drivers and receivers appropriate for the 1822 distant-host interface.  (They may be used with the Local Host signaling with minimal changes).e18(635)I have also included two pages describing the PROM contents.  In addition, ensuing following paragraphs offer another explanation of how the finite state machines are supposed to work.e18Remarkse12jk40(2116)\f5b7f0BI do not claim that the hardware or microcode are bug free, but I think enough of the essentials are there for a preliminary design review.e18(635)Presumably, such a review should be set up for sometime.e18c: At PARC: Larry Stewart, Dave Boggs, Ed Taft, John Shoch, Ted Strollo, Severo Ornstein, Will Crowther, Butler Lampson, Bert Sutherland.At SDD: Bob Metcalfe, Ron Crane, Yogen Dalal, Hal Murray, Victor Schwartz.e24j(2116)\12i125I9iAppendicese12jk792\f5b10f0BInput PROMe18(635)\f5 10bState						Event						New State		Outputse18\u5U6u5U6u9U2u7U000	IDLE	IIEFct (input enable)	001	None001	Wait for bit	TYInBS (bit available)	100	RFNInB100	Clock		010	Shift,Count010	Handshaking	TYInBS' & Count15'	001	wait	   & Pad'		Count15	011		Pad	100011	Input Wakeup	IRFct	000	IWake		IRFct & Pad	011	(special case)(0,4352)(1,7456)(2,12512)(3,15712)\4f7 4f0 1f7 6f0 1f7 14f0 5f7 4f0 6f7 12f0 1f7 6f0 1f7 15f0 5f7 6f0 6f7 5f0 6f7 11f0 6f7 35f0 1f7 4f0 1f7 9f0 3f7 7f0 7f7 3f0 10f7 12f0 1f7 5f0 5f7 5f0 3f7 11f0 5f7 14f0Output PROMe18(635)\f5 11bState						Event						New State		Outputse18\u5U6u5U6u9U2u7U000	IDLE	IWFct (write function)	001	None001	Wait for imp	RFNOS (Imp ready)	100010	Send a bit	RFNOS' & Count15'	111	TYOB		RFNOS' & Count15	110110	Clock bit		001	Shift,Count111	Clock last bit		011	Shift,Count011	Wakeup	IWFct	001	OWake(0,4352)\4f7 4f0 1f7 5f0 1f7 16f0 5f7 4f0 6f7 12f0 1f7 5f0 1f7 11f0 10f7 10f0 1f7 17f0 5f7 4f0 3f7 16f0 10f7 10f0 5f7 11f0 6f7 14f0 6f7 11f0 6f7 12f0 5f7 5f0Microcodee12jk792(2116)\f5b9f0B; Alto 1822 Interface microcode; Larry Stewart 1/2/78; 2-way branches using NEXT9!1,2,IODMOR,IODEND!1,2,INXT,IODLST!1,2,IIDMOR,IIDFUL!1,2,IIDCON,IIDLST!1,2,IIBLOK,IIBLZ!1,2,IOBLOK,IOBLZ; 16-way dispatch using NEXT6,NEXT7,NEXT8,NEXT9!17,20,INOCMD,IODATA,IIDATA,IIDATB,IOSTRT,IOBAD,IOSTA,IOBADA,IISTRT,IISTA,IIBAD,IIBADA,ICTST,ICTSTA,ICTSTB,ICTSTC;; Task Specific Function Definitions$IRFCT $ ; F2-8		Input data$IWFCT $ ; F1-8		Output data$IOCFCT$ ; F1-9		Clear hardware output wakeup$ISWFCT$ ; F1-10		Clear SIO generated wakeup$IIEFCT$ ; F2-10		Start read (turn on RFNIB)$IBRFCT$ ; F1-11		16-way branch on wakeup conditions$IPFCT $ ; F2-11		Post function (gate status to bus)$ISCFCT$ ; F2-9		Set control functions from bus;R (S) registers$IIPTR $R1;		Input buffer pointer$IICTR $R2;		Input word count$IICPTR$R3;		Input post location pointer$IOPTR $R4;		Output buffer pointer$IOCTR $R5;		Output word count$IOCPTR$R6;		Output post location pointer$IWORK $R7;		Spot for saving things; Task constants$ISDON $377;		done$ISBSY $777;		busy$ISOVF $1377;		buffer overflow (input only)$ISBLZ $1777;		block length zero$ICTWO $2;		address computation$ICSLST$2;		set last word; Other definitions$AC1   $R2	;Emulator register;Main loop.  Task waits here when not processing something.IMLOOP:	T_ ICTWO,IBRFCT;		handy constant	L_ AC1+T,:INOCMD;		16-way branch;[INOCMD,IODATA,IIDATA,IIDATB,IOSTRT,IOBSY,IOSTA,IOBSYA,;     IISTRT,IISTA,IIBSY,IIBSYA,ICTST,ICTSTA,ICTSTB,ICTSTC]INOCMD:	TASK,:INXT;				;Can't get here!;Read status and set control registerICTST:	MAR_ AC1,:ICTSTM;		Start fetch of argsICTSTA:	MAR_ AC1,:ICTSTM;ICTSTB:	MAR_ AC1,:ICTSTM;ICTSTC:	MAR_ AC1,:ICTSTM;ICTSTM:	L_ AC1+1;	ISCFCT_ MD,TASK;			Set control flops	IWORK_ L;			Save post pointer	L_ ISDON,ISWFCT,:IPOST;		Control done;Common Post routine; Expects address of post location in IWORK;	and task status in LIPOST:	MAR_ IWORK;			Start double reference	IWORK_ L;			Save ucode status	T_ NWW;	MD_ IWORK,IPFCT;			Bus AND hardware status	L_ MD OR T,TASK;			NWW OR interrupt bits	NWW_ L,:IMLOOP;;If a hardware input/output wakeup turns up along with a;SIO start input/output request, something is awry...IIBSYA:	IWORK_ L,:IBPST;IIBSY:	IWORK_ L,:IBPST;IOBSYA:	IWORK_ L,:IBPST;IOBSY:	IWORK_ L,:IBPST;IBPST:	L_ ISBAD,ISWFCT,:IPOST;		Clear wakeup;Input initialization;	Buffer pointer, buffer count, and pointer to;	remaining arguments stored in s regs.IISTRT:	T_ MAR_ AC1,:IISTM;		Start fetchIISTA:	T_ MAR_ AC1,:IISTM;IISTM:	IICPTR_ L;			Save post pointer	T_ MD,BUS=0;			test for zero length	L_ MD-1:IIBLOK;			[IIBLOK,IIBLZ]IOBLOK:	IIPTR_ L,L_ T,ISWFCT;		Save arguments	IICTR_ L,IIEFCT,TASK,:INXT;	length ok,start readerINXT:	:IMLOOP;				continueIIBLZ:	L_ IICPTR,TASK,;IBLZP:	IWORK_ L;IBLZPA:	L_ ISBLZ,ISWFCT,:IPOST;;Input Main loopIIDATA:	L_ MAR_ IIPTR+1,:IIDATM;		Start fetchIIDATB:	L_ MAR_ IIPTR+1,:IIDATM;IIDATM:	T_ IICTR-1,BUS=0;		Buffer full?	IIPTR_ L,L_ T,:IIDMOR;		[IIDMOR,IIDFUL]IIDMOR:	MD_ IRFCT;			Read and branch on last word.;					Except on the last word, this;					clears the wakeup	IICTR_ L,:IIDCON;		[IIDCON,IIDLST]IIDCON:	IIEFCT,TASK,:INXT;		clear wakeup, restartIIDLST:	MAR_ IICPTR-1;			recall count location	L_ IICPTR;	IWORK_ L,TASK;			this TASK only works;			because the hardware doesn't really clear the;			wakeup until the next IRFCT in this case	MD_ IIPTR;			store final address	L_ ISIDON;			input done statusIIDPST:	SINK_ IRFCT,:IPOST;		clear wakeupIIDFUL:	L_ IICPTR,TASK;			set up for post	IWORK_ L;	L_ ISIOVF,:IIDPST;		overflow status;Output initialization;	Buffer pointer, buffer count, and pointer to;	remaining arguments stored in s regs.IOSTRT:	T_ MAR_ AC1,:IOSTM;		Start fetchIOSTB:	T_ MAR_ AC1,:IOSTM;IOSTM:	IOCPTR_ L;			Save post pointer	T_ MD,BUS=0;			test for zero length	L_ MD-1,:IOBLOK;			[IOBLOK,IOBLZ]IOBLOK:	IOPTR_ L,L_T,TASK;		Save arguments	IOCTR_ L;			length ok	ISWFCT,:IODATA;			send first wordIOBLZ:	L_ IOCPTR,TASK,:IBLZP;;Main output loopIODATA:	L_ MAR_ IOPTR+1,:IODATM;		start fetchIODATB:	L_ MAR_ IOPTR+1,:IODATM;IODATM:	T_ IOCTR-1,BUS=0;		buffer empty?	IOPTR_ L,L_ T,:IODMOR;		[IODMOR,IODEND]IODMOR:	IWFCT_ MD,SH=0;			write, last word?	IOCTR_ L,TASK,:INXT;		[INXT,IODLST];Set last word flop in order to set Last Host BitIODLST:	SINK_ ICSLST,ISCFCT,:IMLOOP;IODEND:	L_ IOCPTR,TASK;			chance to run	IWORK_ L;			normal end for write	L_ ISDON,IOCFCT,:IPOSTe12(0,4800)(1,6592)(2,8384)(3,10176)(4,11968)(5,13760)(6,15552)(7,17344)\f8