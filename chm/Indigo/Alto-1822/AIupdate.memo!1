Heading:qjk40(635)Proposed Alto-1822 Interface, Updatey756qjk40Page Numbers: Yes  X: 527  Y: 10.5"qjk40Inter-Office Memorandumz18592l4445y762\f5bTo	Taft, Boggs, Shoch,	Date	January 26, 1978Strollo, Stewartz18592l4445d2998e21(0,65535)(1,4445)(5,11684)(6,14146)\f1 2f0t2 1t0 19t6 1f1t0 4f0t7 1t0From	Larry Stewart	Location	Palo Altoz18592l4445d2998y716e25\f1 4f0t2 1t0 13t6 1f1t0 8f0t7 1t0Subject	Alto-1822 Interface	Organization	SSLz18592l4445d2998e25\f1 7f0t2 1t0 19t6 1f1t0 12f0t7 1t0New microcode, other changesz18592l4445XEROX       z18592l508y644e14(2116)\f2 5f0Filed on: [Maxc1]<LStewart>AIupdate.presse30Abstracte10\b8BJohn Shoch, Ed Taft, Dave Boggs, and I got together on January 10 to look over the proposed Alto-1822 design.  This memo presents an updated view of the interface software and microcode with some of the bugs fixed.  Not included here is a better description of the PROM contents. e10Emulator - Task interfacee10\b25BAn emulator program can wake up the IMP task by executing an SIO instruction with either or both of AC0 bits 5 and 6 set.  Possible functions are start receiver, start transmitter, and read status/set control register.  AC1 is must point to a command block during the execution of the Read Status / Set Control Register SIO.  The task saves the control block pointer in an S register for later use.  This means that a read status call must be made before trying to do a data transfer.e10\285i34IDue to the shortage of S registers, we decided to keep all the 1822 interface buffer pointers in main memory.  This reduces the number of required S registers to one, but in exchange, requires three main memory cycles per word.  The single S register contains a pointer to the 12 word control block.  The single control block contains entries for input, output, and control functions.e10	Control Block Structuree10(635)\i	CmdBlock:	struct		[			inputPointer	/next word to be used			inputBufferEnd	/first word not in buffer			outputPointer	/next word to be used			outputBufferEnd	/first word not in buffer			controlWord	/command			blank			lvInputPost	/input post location			inputIntBits	/input interrupt channels			lvOutputPost	/output post location			outputIntBits	/output interrupt channels			lvControlPost	/control post location			controlIntBits	/control interrupt channels		]e22(0,3648)(1,5568)(2,6464)(3,11264)(5,65535)(6,65535)Start receivere10(635)\i14IThe receiver will go off and collect a packet from the IMP.  The final buffer location used is returned in lvBuffer.  Returns error if the buffer size is zero, if the buffer overflowed, or if the receiver seems to be running already.e10	LDA	AC0,#001000	SIOe10(0,3648)Start transmittere10(635)\i17IThe transmitter will send a packet (buffer) to the IMP without further attention.  Returns error if the buffer size is zero or if the transmitter seems to be running already.e10	LDA	AC0,#002000	SIOe10(0,3648)Read Status / Set Control Registere10(635)\i34IThis command allows an emulator program to observe the interface without disturbing it.  The command word can do things like reset the interface to ground zero, turn on the Host Ready relay, etc.e10	LDA	AC0,#003000	LDA	AC1,CmdBlock	SIOe10(0,3648)Post Datae10(635)\i9IAfter the style of the ethernet, on completion of a command, the microcode status occupies the left byte of the Post location and the hardware status occupies the right byte.e10Possible microcode status bytes:	00000001	-	all ok	00000010	-	input hardware seemed to be busy already	00000011	-	output hardware seemed to be busy already	00000100	-	buffer overflow (input only)	00000101	-	input buffer length was zero on entry	00000110	-	input buffer length was zero on entrye10Hardware status bits:	struct	[		unused			bit	5;		IMPWasDown	bit	1;		IMPnotReady	bit	1;		HostnotReady	bit	1;	]e10Command Worde10\i12IThe command word is used to set and clear some control flipflops in the hardware.  Some of these, like TestMode and HostReadyRelay, will never be touched by the microcode - they are to be used by an emulator program.  Others, like SetLastWord, are intended to be used only by the microcode and should never appear in a command.e10\268i4ICommand Bits:	struct	[		unused	byte;		turnOnReadyRelay	bit;		turnOffReadyRelay	bit;		turnOnTestMode	bit;		turnOffTestMode	bit;		unused	bit;		resetWorld	bit;		setLastWord	bit;		tryClearingIMPdownFlop	bit;	]e10(0,3648)(1,4256)(2,10208)(3,65535)Microcodee18(635)\f5bA copy of the updated microcode is attached.  The code uses one S register.  I include here a table of timing information.  A '+' indicates a TASK.e18Operation		Microcyclese16(0,7104)(1,12800)(2,15072)(3,12800)(4,7136)\uEmulator control/status call	15Emulator input request	17	(Buffer length zero)Emulator input request	12	(Buffer length non-zero)Emulator output request	9+8	(Buffer length zero)Emulator output request	9+20	(Buffer length non-zero)Input wakeup	(Buffer Overflow)	20Input wakeup	(Normal)	19Input wakeup	(Last word)	18+8		(wierd kludge)Output wakeup	(Normal)	20Output wakeup	(Last word)	20Output wakeup	(Normal end)	19e16\59f7 21f0 27f7 25f0 29f7 21f0 30f7 25f0 13f7 17f0 16f7 9f0 17f7 11f0 7f7 14f0 15f7 8f0 18f7 11f0 18f7 12f0Microcodee12jk792(2116)\f5b9f0B; Alto 1822 Interface microcode; Larry Stewart 12/26/77;  Updated 1/26/77; 2-way branches using NEXT9!1,2,IODMOR,IODEND!1,2,INXT,IODLST!1,2,IIDMOR,IIDFUL!1,2,IIBLOK,IIBLZ!1,2,IOBLOK,IOBLZ; 2-way branch using NEXT7 (Caused by IREAD)%4,4,0,IIDCON,IIDLST; 16-way dispatch using NEXT4,NEXT5,NEXT6,NEXT7%74,74,0,INOCMD,IODATA,IIDATA,IIDATB,IOSTRT,IOBAD,IOSTA,IOBADA,IISTRT,IISTA,IIBAD,IIBADA,ICTST,ICTSTA,ICTSTB,ICTSTC;; Task Specific Function Definitions$IREAD $ ; F2-8		Input data$IWRITE$ ; F2-12	Output data$IOCLR $ ; F1-9		Clear hardware output wakeup$ISWAKC$ ; F1-10	Clear SIO generated wakeup$IIENBL$ ; F2-10	Start read (turn on RFNIB)$IBRNCH$ ; F1-11	16-way branch on wakeup conditions$IPOSTF$ ; F2-11	Post function (gate status to bus)$ISETCS$ ; F2-9		Set control functions from bus;R (S) registers NOTE: WHAT REGISTER?$ICBPTR$R1;		Control Block Pointer;$MTEMP $R25		Temporary storage; Task constants$ISDON $777;		done$ISIBAD$1377;		input busy$ISOBAD$1777;		output busy$ISOVF $2377;		buffer overflow (input only)$ISIBLZ$2777;		input block length zero$ISOBLZ$3377;		output block length zero; Other definitions$AC1   $R2	;Emulator register;Main loop.  Task waits here when not processing something.IMLOOP:	T_ ICBPTR,IBRNCH;		start a data ptr cycle	L_ 2+T,:INOCMD;			16-way branch;[INOCMD,IODATA,IIDATA,IIDATB,IOSTRT,IOBAD,IOSTA,IOBADA,;     IISTRT,IISTA,IIBAD,IIBADA,ICTST,ICTSTA,ICTSTB,ICTSTC]INOCMD:	TASK,:INXT;				;Can't get here!;			NOTE:  HOW SHOULD THIS WORK?;Read status and set control registerICTST:	L_ T_ AC1,:ICTSTM;ICTSTA:	L_ T_ AC1,:ICTSTM;ICTSTB:	L_ T_ AC1,:ICTSTM;ICTSTC:	L_ T_ AC1,:ICTSTM;ICTSTM:	MAR_ 4+T;			Start fetch of args	ICBPTR_ L;			Save ctl block pointer	T_ 12,ISWAKC;			post location offset	L_ ISDON;			Set control flops	ISETCS_ MD,:IPOST;		Control done;Common Post routine; Expects offset of post location in T;	and task status in LIPOST:	MAR_ ICBPTR+T;			Start double reference	MTEMP_ L;			Save ucode status	T_ NWW;	MD_ MTEMP,IPOSTF;		Bus AND hardware status	L_ MD OR T,TASK;		NWW OR interrupt bits	NWW_ L,:IMLOOP;;If a hardware input/output wakeup turns up along with a;SIO start input/output request, something is awry...IIBADA:	T_ 6,:IIBADM;IIBAD:	T_ 6,:IIBADM;IIBADM:	L_ISIBAD,ISWAKC,:IPOST;IOBADA:	T_ 10,:IOBADM;IOBAD:	T_ 10,:IOBADM;IOBADM:	L_ ISOBAD,ISWAKC,:IPOST;		Clear wakeup;Input initializationIISTRT:	MAR_ T,:IISTM;			compute final addr addrIISTA:	MAR_ T,:IISTM;IISTM:	T_ MD;				read data pointer	L_ MD-T;	SH=0,ISWAKC;			clear wakeup	T_6,:IIBLOK;			[IIBLOK,IIBLZ]IIBLOK:	IIENBL,TASK,:INXT;		length ok,start readerINXT:	:IMLOOP;			continueIIBLZ:	L_ ISIBLZ,:IPOST;;Input Main loopIIDATA:	MAR_ T,:IIDATM;			Start fetchIIDATB:	MAR_ T,:IIDATM;IIDATM:	T_ MD;				get pointer	L_ MD-T;			past end of buffer?	MAR_ T;				start data fetch	L_ 1+T,SH=0;	MTEMP_ L,:IIDMOR;		[IIDMOR,IIDFUL]IIDMOR:	MD_ IREAD;			Read and branch on last word.;					Except on the last word, this;					clears the wakeup	MAR_ ICBPTR,:IIDCON;		[IIDCON,IIDLST]IIDCON:	IIENBL;				enable receiver	MD_ MTEMP,TASK,:INXT;		update ptr,restartIIDLST:	L_ ISIDON,TASK;			this TASK only works;			because the hardware doesn't really clear the;			wakeup until the next IREAD in this case	MD_ MTEMP;			update pointerIIDPST:	T_ 6;				post offset	SINK_ IREAD,:IPOST;		clear wakeup (again)IIDFUL:	L_ ISIOVF,:IIDPST;		overflow status;Output initializationIOSTRT:	MAR_ 2+T,:IOSTM;		Start fetchIOSTB:	MAR_ 2+T,:IOSTM;IOSTM:	T_ MD;				test for zero length	L_ MD-T,TASK;	SH=0;				clear wakeup	T_ 10,:IOBLOK;			[IOBLOK,IOBLZ]IOBLOK:	T_ ICBPTR,ISWAKC,:IODATA;	clr wakeup, send dataIOBLZ:	L_ ISOBLZ,ISWAKC,:IPOST;;Main output loopIODATA:	MAR_ L_ 2+T,:IODATM;		start fetchIODATB:	MAR_ L_ 2+T,:IODATM;IODATM:	MTEMP_ L;			save cb ptr	T_ MD;				get pointer	L_ MD-T;			past end of buffer?	MAR_ MTEMP,SH=0;		save data pointer	MTEMP_ L,:IODMOR;		update ptr [IODMOR,IODEND]IODMOR:	L_ MTEMP-1;	MD_ 1+T;	MAR_ T;				start data fetch	IWRITE_ MD,SH=0;		clear wakeup, last?	TASK,:INXT;			[INXT,IODLST];Set last word flop in order to set Last Host BitIODLST:	SINK_ 2,ISETCS,:IMLOOP;IODEND:	T_ 10;	L_ ISDON,IOCLR,:IPOSTe24(0,4800)(1,6592)(2,8384)(3,10176)(4,11968)(5,13760)(6,15552)(7,17344)\f8 470f0 5f8 23f0 6f8 23f0 5f8 41f0 6f8 38f0 6f8 38f0 6f8 46f0 6f8 46f0 6f8 41f0 1f8 452f0 6f8 298f0 9f8 18f0 9f8 18f0 9f8 18f0 9f8 94f0 6f8 27f0 1f8 29f0 7f8 121f0 1f8 42f0 1f8 26f0 1f8 9f0 1f8 7f0 6f8 29f0 1f8 42f0 1f8 134f0 1f8 20f0 1f8 53f0 1f8 21f0 1f8 31f0 6f8 126f0 1f8 28f0 1f8 75f0 6f8 119f0 1f8 37f0 1f8 164f0 1f8 1f0 5f8 331i4I1f0 5f8 79f0 5f8 112f0 1f8 36f0 1f8 21f0 1f8 31f0 1f8 480f0 6f8 129f0 6f8 36f0 5f8 10v