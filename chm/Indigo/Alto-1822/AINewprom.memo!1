Heading:qjk40(635)Proposed Alto-1822 Interface, PROM Updatey756qjk40Page Numbers: Yes  X: 527  Y: 10.5"qjk40Inter-Office Memorandumz18592l4445y762\f5bTo	Taft, Boggs, Shoch,	Date	January 28, 1978Strollo, Stewart, Huntz18592l4445d2998e21(0,65535)(1,4445)(5,11684)(6,14146)\f1 2f0t2 1t0 19t6 1f1t0 4f0t7 1t0From	Larry Stewart	Location	Palo Altoz18592l4445d2998y716e25\f1 4f0t2 1t0 13t6 1f1t0 8f0t7 1t0Subject	Alto-1822 Interface	Organization	SSLz18592l4445d2998e25\f1 7f0t2 1t0 19t6 1f1t0 12f0t7 1t0New PROM contentsz18592l4445XEROX       z18592l508y644e14(2116)\f2 5f0Filed on: [Maxc1]<LStewart>AInewprom.press	[IFS]<LStewart>AInewprom.presse30Abstracte10(635)\b8BThe Alto-1822 interface contains two PROM driven finite state machines.  This memo presents an updated view of how the (input and output) machines are supposed to work.  Included are state tables for each PROM, DRAW generated state diagrams, and the bcpl program which creates the .MB file for the PROM blower. e10Commentse10\b8BThe finite state machines handle the bit by bit handshaking protocol specifies by BBN-1822 for local host and distant host IMP interfaces.  The choice of 2-way or 4-way handshaking on the input side is made by a wiring change in the "There's Your Input Bit" synchronizer.  For output, the choice is made by the IMP.e10	Inpute10\b1Bi5IUpon receipt of the task function IIEnbl, the input FSM begins assembly of a 16 bit word from the IMP.  Usually, the machine will accept the 16th bit, set the hardware input wakeup signal, and stop.  If the "Last Input Bit" signal arrives during the middle of a word, the FSM will fill out the word with zeros before setting the wakeup.  In either case, a task function (IRead) must eventually read the input data register.  If the hardware or software dies, the Alto reset lines will clear the wakeup.e10	Outpute10\b1Bi6IUpon receipt of the task function IWrite (which loads the output shift register from the bus), the output FSM will transmit a 16 bit word to the IMP.  Usually, the machine will transmit the 16th bit, set the hardware output wakeup signal, and stop.  If the "Last Word" signal is set during the middle of the word (by a task function), the 1822 "Last Output Bit" signal will be set during transmission of the 16th bit.  There is no provision for transmitting partial words.  In either case, a task function (IWrite or IOClr) or hardware reset must eventually clear the output wakeup.e10Input PROMe18k792\f5bState		Event	New State	Actionse18(0,4352)(1,7456)(2,12512)(3,15712)(5,65535)(6,65535)\u5U2u5U1u9U1u7U(635)000	IDLE	IIEnbl (enable input)	001	ctr_15				RFNInB_1001	Wait for bit	TYInBS (bit available)	101	RFNInB_0					Shift				Pad_LInB101	Clock data	(next clock)	010	ctr_ctr+1010	Handshaking	TYInBS' & ctr#15	001	RFNInB_1	wait	   & Pad'		ctr=15	011	IWake_1		Pad & ctr#15	101	Shift011	Input Wakeup	IRFct & Pad'	000	IWake_0		IRFct & Pad	011	Pad_0				bus_sr(0,4352)\4f7 4f0 1f7 6f0 1f7 14f0 5f7 6f0 5f7 8f0 6f7 12f0 1f7 6f0 1f7 15f0 5f7 8f0 1f7 10f0 5f7 8f0 6f7 5f0 6f7 12f0 12f7 3f0 5f7 29f0 3f7 10f0 1f7 4f0 1f7 9f0 3f7 6f0 5f7 7f0 3f7 12f0 5f7 5f0 6f7 12f0 1f7 12f0 5f7 7f0 3f7 11f0 5f7 16f0Output PROMe18(635)\f5bState		Event	New State	Actionse18(0,4352)\u5U2u5U1u9U1u7U000	IDLE	IWrite (write function)	001	ctr_0				sr_bus001	Wait for imp	RFNOS (Imp ready)	010	TYOB_1010	Send a bit	RFNOS' & ctr#15	101	TYOB_0				Shift		RFNOS' & ctr=15	011	TYOB_0				OWake_1101	Clock bit	ctr#14	001	ctr_ctr+1		ctr=14	001	ctr_ctr+1				LOutB_LastWd011	Wakeup	IWFct	001	OWake_0				sr_bus		IOClr	000	OWake_0e12\4f7 4f0 1f7 6f0 1f7 16f0 5f7 16f0 6f7 12f0 1f7 5f0 1f7 11f0 4f7 7f0 6f7 10f0 1f7 15f0 5f7 6f0 5f7 5f0 3f7 15f0 5f7 6f0 5f7 7f0 6f7 10f0 11f7 9f0 14f7 26f0 6f7 12f0 5f7 27f0 4f7 7f0ROM Generating Programe10k792(635)\b22B//AltoImpRoms.bcpl//last modified January 28, 1978  7:49 PMget "Streams.d"external[//incoming proceduresOpenFile; Ws; Puts; Closes//incoming staticsdsp]static [ mbFile; memoryNumber ]structure String [ length byte; char^1,1 byte ]//-------------------------------------------------------------------let AltoImpRoms() be//-------------------------------------------------------------------[mbFile = OpenFile("D1EthRoms.mb",ksTypeWriteOnly,charItem)DoMemory(256,4,"Input",GenInput)DoMemory(256,4,"Output",GenOutput)PutWord(mbFile,0)  //end of fileCloses(mbFile)]//-------------------------------------------------------------------and DoMemory(length,width,name,Generator) be//-------------------------------------------------------------------//length is 2^(number of address bits)//width is the number of output bits//name is a BCPL string//generator is a procedure[Puts(dsp,$*N); Ws(name)PutWord(mbFile,4)  //declare memory parametersmemoryNumber = memoryNumber +1PutWord(mbFile,memoryNumber)PutWord(mbFile,width)for i = 1 to name>>String.length do Puts(mbFile,name>>String.char^i)Puts(mbFile,0)  //asciz end of stringif (name>>String.length & 1) eq 0 then Puts(mbFile,0)  //pad to word boundryPutWord(mbFile,2)  //set current memory and locationPutWord(mbFile,memoryNumber)PutWord(mbFile,0)  //location = 0for addr = 0 to length-1 do   [   PutWord(mbFile,1)  //memory data word   PutWord(mbFile,0)  //source line number (not used)   PutWord(mbFile,Generator(addr))   ]]//-------------------------------------------------------------------and PutWord(stream,w) be//-------------------------------------------------------------------[Puts(stream,w rshift 8)Puts(stream,w)]//-------------------------------------------------------------------and GenInput(address) = valof//-------------------------------------------------------------------//an I3601[manifest   [   //the correspondence between voltage levels and bits in the .MB file:   high = 0; low = 1   //the correspondence between states and bits in the .MB file:   stateIdle = 17   stateWaitforBit = 6   stateClock = 12   stateHandshake = 15   stateWakeup = 14   ]structure Address:   [   blank bit 8   NotIRead bit  //A0 pin 5   NotIIEnbl bit   Pad bit   IC15 bit   TYInBS bit   OldState bit 3   ]structure Data:   [   NewState bit 4  //Q0 pin 12   blank bit 12   ]IRead = not address<<Address.NotIReadIIEnbl = not address<<Address.NotIIEnblPad = address<<Address.PadIC15 = address<<Address.IC15TYInBS = address<<Address.TYInBSOldState = address<<Address.OldStateswitchon OldState into   [   case stateIdle:      [      data<<Data.NewState = IEnbl ? stateWaitforBit, stateIdle      ]   case stateWaitforBit:      [      data<<Data.NewState = TYInBS ? stateClock, stateWaitforBit      if IRead data<<Data.NewState = stateIdle      ]   case stateClock:      [      data<<Data.NewState = stateHandshake      if IRead data<<Data.NewState = stateIdle      ]   case stateHandshake:      [      test IC15         ifso data<<Data.NewState = stateWakeup         ifnot test Pad            ifso data<<Data.NewState = stateClock            ifnot data<<Data.NewState = TYInBS ? stateHandshake, stateWaitforBit      if IRead data<<Data.NewState = stateIdle      ]   case stateWakeup:      [      test IRead         ifnot data<<Data.NewState = stateWakeup         ifso data<<Data.NewState = Pad ? stateWakeup, stateIdle      ]   default:      [      data<<Data.NewState = stateIdle      ]   ]resultis data]//-------------------------------------------------------------------and GenOutput(address) = valof//-------------------------------------------------------------------//an I3601[manifest   [   //the correspondence between voltage levels and bits in the .MB file:   high = 0; low = 1   //the correspondence between states and bits in the .MB file:   stateIdle = 17   stateWaitforRdy = 16   stateClock = 12   stateSendBit = 5   stateWakeup = 14   ]structure Address:   [   blank bit 8   NotIOClr bit  //A0 pin 5   NotIWrite bit   blank bit   OC15 bit   NotRFNOBS bit   OldState bit 3   ]structure Data:   [   NewState bit 4  //Q0 pin 12   blank bit 12   ]IOClr = not address<<Address.NotIOClrIWrite = not address<<Address.NotIWriteOC15 = address<<Address.OC15RFNOBS = notaddress<<Address.NotRFNOBSOldState = address<<Address.OldStateswitchon OldState into   [   case stateIdle:      [      data<<Data.NewState = IWrite ? stateWaitforRdy, stateIdle      ]   case stateWaitforRdy:      [      data<<Data.NewState = RFNOBS ? stateSendBit, stateWaitforRdy      ]   case stateSendBit:      [      test RFNOBS         ifso data<<Data.NewState = stateSendBit         ifnot data<<Data.NewState = OC15 ? stateWakeup, stateClock      ]   case stateClock:      [      data<<Data.NewState = stateWaitforRdy      ]   case stateWakeup:      [      data<<Data.NewState = IWrite ? stateWaitforRdy, stateWakeup      ]   default:      [      data<<Data.NewState = stateIdle      ]   ]if IOClr data<<Data.NewState = stateIdleresultis data]e22