Heading:qjk40(635)Alto-1822 Interface, Updated Designy756qjk40Page Numbers: Yes  X: 527  Y: 10.5"qjk40Inter-Office Memorandumz18592l4445y762\f5bTo	Taft, Boggs, Shoch,	Date	February 7, 1978Strollo, Stewart,Huntz18592l4445d2998e21(0,65535)(1,4445)(5,11684)(6,14146)\f1 2f0t2 1t0 19t6 1f1t0 4f0t7 1t0From	Larry Stewart	Location	Palo Altoz18592l4445d2998y716e25\f1 4f0t2 1t0 13t6 1f1t0 8f0t7 1t0Subject	Alto-1822 Interface	Organization	SSLz18592l4445d2998e25\f1 7f0t2 1t0 19t6 1f1t0 12f0t7 1t0New, Up-to-date stuffz18592l4445XEROX       z18592l508y644e14(2116)\f2 5f0Filed on: [Maxc1]<LStewart>AInewDesign.presse30Abstracte10\b8BAs a result of various conversations and considerable soul searching, I have made substantial changes (again) to the Alto-1822 interface hardware and microcode.  This memo includes the newest iteration of the emulator level interface, the microcode, and the hardware.  It does not include a description of the PROM contents.  In terms of complexity, the microcode uses one S register and is 47 words long.  The hardware is around 45 or 46 packages. e10Major differences (and homespun philosophy)e10\b18BN-way branch:Rather than use a 16-way branch to set up the priority of the various wakeups, the priority encoding is now done in hardware.  On a wakeup, the microcode executes a 4-way branch to routines for SIO-set control, SIO-start receiver, Input data wakeup, and Output data wakeup.  Oddly enough, this change simplified both hardware and microcode. l4000d2999e10Packet Throwaway Mode:By executing an SIO-set control function, the user may set the receiver hardware into "Packet Throwaway Mode".  On each SIO-start receiver call (until the throwaway mode is cleared), the microcode will read in a packet (i.e. until the next Last Imp Bit) and throw it away.  Although it is not used, the input buffer must have some space in it.  This capability cost one microinstruction and one IC package.l4000d2999e10\263i12IRead Status - Set Control function:In order to take advantage of available MSI, the style of the command word was changed.  The key difference is that only one thing at a time may be set or cleared (i.e. the commands are encoded now).l4000d2999e10Zero buffer length:It was suggested to me that the initial tests for zero buffer length were a waste of microinstructions.  Here's what happened:  On output, there is no longer any initialization microcode - the SIO reaches down into the output finite state machine and makes it think it was running already.  The FSM then requests a normal output data wakeup to get the first word.  Thus if the buffer size is zero, on that first wakeup the microcode will conclude that transmission is done and return normal end status - without having done anything.  On input, while it is true that a zero length buffer probably represents a programming error, I included the test anyway.  If the receiver were actually started with a zero size buffer, the condition would not be noticed until the first input data wakeup.  At that time, the microcode would have no choice but to throw away the input word and return a buffer overflow error - the entire packet would be messed up.  As things stand, you can request input into a zero length buffer, get an error status back, and restart the operation with a non-zero buffer without losing data.l4000d2999e10\1111i7IIn addition, there are a variety of minor changes designed to simplify the hardware and microcode.  From a user's point of view there have been subtle changes to the layout of the emulator interface.  Elsewhere, things are more incomprehensible than before, but smaller.e10Emulator - Task interfacee10\b25BAn emulator program can wake up the IMP task by executing an SIO instruction with either or both of AC0 bits 5 and 6 set.  Possible functions are start receiver, start transmitter, and read status/set control register.  AC1 is must point to a command block during the execution of the Read Status / Set Control Register SIO.  The task saves the control block pointer in an S register for later use.  This means that a read status call must be made before trying to do a data transfer.e10\285i34IIn order to hold the use of S registers to a minimum, both input and output buffer pointers are kept in main memory.  This means that input/output operations require three main memory cycles per word.  The single S register contains a pointer to the 12 word control block.  The single control block contains entries for input, output, and control functions.e10	Control Block Structuree10(635)\iThe command block must be on an even word (for AI compatibility).e10(2116)	CmdBlock:	struct		[			controlWord	/command			blank			inputPointer	/next word to be used			inputBufferEnd	/first word not in buffer			outputPointer	/next word to be used			outputBufferEnd	/first word not in buffer			ControlPost	/control post location			controlIntBits	/control interrupt channels			InputPost	/input post location			inputIntBits	/input interrupt channels			OutputPost	/output post location			outputIntBits	/output interrupt channels		]e22(0,3648)(1,5568)(2,6464)(3,11264)(5,65535)(6,65535)Start receivere10(635)\i14IThe receiver will collect a packet from the IMP.  The final buffer location used ( +1 ) is returned in inputPointer.  Returns error if the buffer size is zero on entry, or if the buffer overflowed.e10	LDA	AC0,#001000	SIOe10(0,3648)Start transmittere10(635)\i17IThe transmitter will send a packet (buffer) to the IMP.  If the buffer length is zero, no bits will be sent, and the returned status will indicate sucessful completion.e10	LDA	AC0,#002000	SIOe10(0,3648)Read Status / Set Control Registere10(635)\i34IThis command allows an emulator program to observe the interface without disturbing it.  It is also used to tell the microcode where the command block is.  The command word is used to set and clear some control flip-flops in the hardware.e10	LDA	AC0,#003000	LDA	AC1,CmdBlock  //(pointer to)	SIOe10(0,3648)Post Datae10(635)\i9IOn completion of a command, the microcode status occupies the left byte of the Post location and the hardware status occupies the right byte.e10Possible microcode status bytes:	00000001	-	all ok	00000010	-	buffer overflow (input only)	00000011	-	input buffer length was zero on entryHardware status bits:	struct	[		unused			bit	5;   //These bits come back as 1's		IMPWasDown	bit	1;		IMPnotReady	bit	1;		HostnotReady	bit	1;	]e10Command Worde10\i12IThe command word is used to set and clear some control flipflops in the hardware.  Except for SetLastWord, these functions are never used by the microcode.e10Possible command words:	0		does nothing	1		hardware master reset	2		set last word - causes Last Host Bit to appear eventually				(intended for use by microcode only)	3		try clearing IMP Was Down flop				(will not work if the IMP is still down)	4		turn on test mode - hardware loop back				(beware: this mode holds the Host ready line off)	5		turn off test mode	6		turn on Host Ready relay	7		turn off Host Ready relay	10		turn on packet throwaway mode	20		turn off packet throwaway modee10\94i13I80i12I183i10I20i10IHardwaree18\f5bA copy of the newest SIL drawings is appended to this memo.  I include no detailed explanation of how it is supposed to work.  See the companion memo which describes the PROM contents and look at BBN 1822.e18Microcode timinge18\f5bA copy of the newest microcode is attached.  The code uses one S register.  I include here a table of timing information.  A '+' indicates a TASK.e18Operation		Microcyclese16(0,7104)(1,12800)(2,15072)(3,12800)(4,7136)\uEmulator control/status call	15Emulator input request	17	(Buffer length zero)Emulator input request	12	(Buffer length non-zero)Emulator output request	0Input wakeup	(Buffer Overflow)	20Input wakeup	(Normal)	18Input wakeup	(Last word)	18+10		(wierd kludge)Input wakeup	(Normal throwaway)	13Input wakeup	(Last throwaway)	13+10Output wakeup	(Normal)	18Output wakeup	(Last word)	18Output wakeup	(Normal end)	19e16\59f7 21f0 27f7 25f0 39f7 17f0 16f7 9f0 17f7 11f0 8f7 14f0 14f7 18f0 16f7 17f0 21f7 8f0 18f7 11f0 18f7 12f0Microcodee12jk792(2116)\f5b9f0B; Alto 1822 Interface microcode; Larry Stewart 2/6/78; 2-way branches using NEXT9!1,2,IODMOR,IODEND!1,2,INXT,IODLST!1,2,IIDMOR,IIDFUL!1,2,IIBLOK,IPOST; 2-way branch using NEXT7 (Caused by IREAD)%4,4,0,IIDCON,IIDLST; 2-way branch using NEXT7 (Caused by IPTMOD)%4,4,0,IIACPT,IIDISC; 4-way branch using NEXT6,NEXT7 (Caused by IBRNCH)%14,14,0,ICTST,IISTRT,IIDATA,IODATA;; Task Specific Function Definitions$IREAD $ ; F1-12	Input data$IWRITE$ ; F1-11	Output data$IOCLR $ ; F1-9	Clear hardware output wakeup$ISWAKC$ ; F1-10	Clear SIO generated wakeup$IIENBL$ ; F2-10	Start read (turn on RFNIB)$IBRNCH$ ; F2-11	4-way branch on wakeup$IPOSTF$ ; F1-8	Post (gate status to bus)$ISETCS$ ; F2-9	Set control functions from bus$IPTMOD$ ; F2-8	2-way branch on throwaway mode;R (S) registers NOTE: WHAT REGISTER?$ICBPTR$R1;	Control Block Pointer;$MTEMP $R25	Temporary storage;$AC1   $R2	Emulator register;$NWW   $R4	Interrupt system reg; Task constants$ISDON $777;	done$ISOVF $1377;	buffer overflow (input only)$ISIBLZ$1777;	block length zero (input only);Main loop.  Task waits here when not processing something.;IBRNCH gates two bits onto NEXT6 and NEXT7;    00 - Set Control  01 - Start input;    10 - Input data wakup  10 - Output data wakeupIMLOOP:	T_ ICBPTR,IBRNCH;	test wakeup conditions	L_ ISDON,:ICTST;	[ICTST,IISTRT,IIDATA,IODATA];Read status and set control register;ISWAKC clears a wakeup caused by an SIO instruction;ISETCS loads hardware control flops from the busICTST:	MAR_ L_ AC1;	Start fetch of args	ICBPTR_ L;	Save ctl block pointer	T_ 6,ISWAKC;	post location offset	ISETCS_ MD;	Control doneINEND:	L_ ISDON,:IPOST;	Set control flops;Common Post routine; Expects offset of post location in T;	and task status in L,M;IPOSTF gates hardware status bits to the busIPOST:	MAR_ ICBPTR+T;	Start double reference	T_ NWW;	MD_ M,IPOSTF;	Bus AND hardware status	L_ MD OR T,TASK;	NWW OR interrupt bitsINXT:	NWW_ L,:IMLOOP;;Input initialization;IIENBL enables the hardware to receive a 16 bit word (turns it on)IISTRT:	MAR_ 2+T;	ISWAKC;	clear wakeup	T_ MD;	read data pointer	L_ MD-T;	L_ ISIBLZ,SH=0;	T_10,:IIBLOK;	[IIBLOK,IPOST]IIBLOK:	L_ NWW,IIENBL,TASK,:INXT;	length ok,start reader;Input Main loop;IPTMOD gates the state of the Throwaway mode flop to NEXT7;   The branch is taken if the flop was set (by an ISETCS)IIDATA:	MAR_ L_ 2+T;	Start fetch	MTEMP_ L,IPTMOD;	save cb ptr,test mode	T_ MD;	get pointer [IIACPT,IIDISC]IIACPT:	L_ MD-T;	past end of buffer?	MAR_ T,SH=0;	start data fetch	L_ 1+T,:IIDMOR;	[IIDMOR,IIDFUL];IREAD gates the receiver shift register to the bus;  and the PAD flop to NEXT7;  If the branch is taken (which happens when the last word of;  a packet is read), the wakeup will not be cleared, otherwise;  the wakeup will be clearedIIDMOR:	MD_ IREAD;	Read and branch on last word.;	Except on the last word, this;	clears the wakeupIICLNU:	MAR_ MTEMP,:IIDCON;	[IIDCON,IIDLST]IIDCON:	IIENBL,TASK;	enable receiverIDCON:	MD_ M,:IMLOOP;	update ptr,restartIIDLST:	TASK;	this TASK only works;	because the hardware doesn't really clear the;	wakeup until the next IREAD in this case	MD_ M;	update pointer	L_ ISDON;IIDPST:	SINK_ IREAD;	clear wakeup (again)	T_ 10,:IPOST;IIDISC:	L_ T_ IREAD,:IICLNU;	throwaway word,branch if lastIIDFUL:	L_ ISIOVF,:IIDPST;	overflow status;Main output loopIODATA:	MAR_ L_ 4+T;	start pointer fetch	MTEMP_ L;	save cb ptr	T_ MD;	get pointer	L_ MD-T;	past end of buffer?	MAR_ T,SH=0;	start data fetch	L_ M-1,:IODMOR;	[IODMOR,IODEND];IWRITE loads the output shift register from the bus,;  clears the (hardware generated) wakeup if there was one,;  and starts the output hardwareIODMOR:	IWRITE_ MD,SH=0;	send data,last?	MAR_ MTEMP,:IONLST;	start update [IONLST,IOLST]IOLST:	SINK_ 1,ISETCS;	set last wordIONLST:	L_ 1+T,TASK,:IDCON;	finish;IOCLR resets the output hardware.  This is how you clear the;   last wakeup without restarting the output hardwareIODEND:	T_ 12,IOCLR,:INEND;	offset of post loce18(0,4798)(1,11959)(2,65535)(3,65535)(4,65535)\f8 3176i4I