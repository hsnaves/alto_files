// C U R S O R   // errors --//// Stuff to keep a display going in the cursor so you can tell something is// happening.////CursorChar(c) -- puts character in upper left-hand corner//CursorDigit(d) -- puts digit in upper right-hand corner// or CursorDigit() -- increments it.//CursorToggle(i) i=0,1,2,3 -- toggles one of 4 remaining areas//// outgoing proceduresexternal	[	CursorClear	CursorChar	CursorDigit	CursorToggle	]// outgoing statics//external//	[//	]//static//	[//	]// incoming proceduresexternal	[//OS	Zero	]// incoming statics//external//	[//	]// internal staticsstatic	[	cursorLastDigit	]// File-wide structure and manifest declarations.manifest [	mouseX = #424	mouseY = #425	cursorX=#426	cursorY=#427	cursorBits=#431	]// Procedureslet CursorChar(c) be[   Zero(cursorBits, 16)   @mouseX, @cursorX =303-8, @mouseX   @mouseY, @cursorY =404-8, @mouseY   cursorLastDigit=0   CursorPutUp(c, false)]and CursorDigit(d; numargs n) be[   if n eq 0 then d=cursorLastDigit+1   d=d rem 10   cursorLastDigit=d   CursorPutUp(d, true)]and CursorToggle(i,newx;numargs n) be[   let mask=(i&1) ne 0? #377, #177400   let base=((i gr 1)? 12, 8)+cursorBits   for i=0 to 3 do base!i=base!i xor mask   if n ge 2 then @cursorX=newx]and CursorClear() be Zero(cursorBits+8, 8)and CursorPutUp(c, right) be[   let ix=selecton c into	[	case $A to $U: (c-$A)*4+40 // letters	default: c*4 // digits	]   let BM=table [	#174; #42104; #42104; #42174;	//0	#20; #30020; #10020; #10174;	//1	#174; #42004; #4020; #20174;	//2	#174; #2004; #36004; #2174;	//3	#104; #42104; #76004; #2004;	//4	#174; #40100; #76004; #2174;	//5	#174; #40100; #76104; #42174;	//6	#174; #2004; #4020; #20100;	//7	#174; #42104; #76104; #42174;	//8	#174; #42104; #76004; #2174;	//9	#70; #42104; #76104; #42104;	// A	#170; #42104; #74104; #42170;	// B	#74; #40100; #40100; #40074;	// C	#174; #41102; #41102; #41174;	//D	#174; #40100; #74100; #40174;	// E	#174; #40100; #74100; #40100;	//F	#174; #40100; #76104; #42174;	//G	#104; #42104; #76104; #42104;	// H	#70; #10020; #10020; #10070;	// I	#4; #02004; #02004; #22074;	// J	#104; #44120; #60120; #44104;	//K	#100; #40100; #40100; #40174;	// L	#104; #66124; #42104; #42104;	// M	#104; #62124; #52114; #46104;	// N	#174; #42104; #42104; #42174;	//O	#174; #42104; #76100; #40100;	//P	#174; #42104; #42124; #46174;	// Q	#174; #42104; #76120; #44104;	// R	#174; #40100; #76004; #2174;	//S	#174; #10020; #10020; #10020;	// T	#104; #42104; #42104; #42174	// U	]   let map=BM+ix   let m1=(right ne 0)? #377, #177400   let m2=m1 xor -1   for i=1 to 7 do	[	let w=map!(i/2)	if (i&1) ne 0 then w=w lshift 8	if right then w=w rshift 8	(cursorBits-1)!i=((cursorBits-1)!i & m2)%(w&m1)	]]// DCS, January 6, 1978  5:14 PM, extend character set, center cursor on CursorChar()// z20598(1792)\f3