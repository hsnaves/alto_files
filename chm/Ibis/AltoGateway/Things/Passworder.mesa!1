-- File: Passworder.mesa,  Last Edit: HGM  December 7, 1980  12:23 PMDIRECTORY  Inline USING [BITAND, BITNOT, BITSHIFT, COPY, LowHalf, HighHalf],  System USING [GetGreenwichMeanTime],  Password USING [];Passworder: PROGRAM IMPORTS Inline, System EXPORTS Password =  BEGIN  Encrypted: PUBLIC TYPE = RECORD [    a: ARRAY [0..2) OF WORD, b: ARRAY [0..2) OF WORD, c: ARRAY [0..4) OF WORD];  Encrypt: PUBLIC PROCEDURE [name, password: STRING] RETURNS [e: Encrypted] =    BEGIN    e.a _ [0, 0];    FOR i: CARDINAL IN [0..name.length) DO      c: WORD _ LOOPHOLE[name[i]];      RightShift6[LOOPHOLE[@e.a], 2];      e.a[0] _ e.a[0] + LeftShift9[c];      ENDLOOP;    e.b _ LOOPHOLE[System.GetGreenwichMeanTime[]];    e.c _ ComputePassword[e.a, e.b, password];    END;  Check: PUBLIC PROCEDURE [password: STRING, old: Encrypted] RETURNS [BOOLEAN] =    BEGIN RETURN[old.c = ComputePassword[old.a, old.b, password]]; END;  -- Computation is:  --  x _ 16-bit number extracted from password  --  x _ 16-bit number extracted from password  --  c _ -a*x*x + b*y  ComputePassword: PROCEDURE [a, b: ARRAY [0..2) OF WORD, password: STRING]    RETURNS [c: ARRAY [0..4) OF WORD] =    BEGIN    x, y: ARRAY [0..2) OF WORD _ ALL[0];    p: POINTER TO ARRAY [0..2) OF WORD;    t, s: ARRAY [0..4) OF WORD;    one: ARRAY [0..4) OF WORD _ [0, 0, 0, 1];    FOR i: CARDINAL IN [0..password.length) DO      c: WORD _ LOOPHOLE[UpperCase[password[i]]];      p _ IF ((c MOD 3) = 1) THEN @x ELSE @y;      RightShift6[LOOPHOLE[p], 2];      p[0] _ p[0] + (c*512); -- Left Shift 9      ENDLOOP;    -- Now we have a,b,x,y    Mult[LOOPHOLE[@t], LOOPHOLE[@x], LOOPHOLE[@x], 1]; -- t _ x*x    Mult[LOOPHOLE[@t], LOOPHOLE[@t], LOOPHOLE[@a], 2]; -- t _ a*x*x    -- negate t    FOR i: CARDINAL IN [0..4) DO t[i] _ Inline.BITNOT[t[i]]; ENDLOOP;    Add[LOOPHOLE[@t], LOOPHOLE[@t], LOOPHOLE[@one], 4];    Mult[LOOPHOLE[@s], LOOPHOLE[@b], LOOPHOLE[@y], 2]; -- s _ b*y    Add[LOOPHOLE[@c], LOOPHOLE[@t], LOOPHOLE[@s], 4];    END;  UpperCase: PROCEDURE [c: CHARACTER] RETURNS [CHARACTER] =    -- Copy over from StringsB to avoid not-in-memory problems from interrupt routine on the Alto    BEGIN IF c IN ['a..'z] THEN c _ c + ('A - 'a); RETURN[c]; END;  RightShift6: PROCEDURE [a: POINTER TO ARRAY OF WORD, n: CARDINAL] =    BEGIN THROUGH [0..6) DO RightShift[a, n]; ENDLOOP; END;  LeftShift9: PROCEDURE [w: WORD] RETURNS [WORD] = INLINE {RETURN[w*512]; };  RightShift: PROCEDURE [a: POINTER TO ARRAY OF WORD, n: CARDINAL] =    BEGIN    ci: WORD _ 0;    FOR i: CARDINAL IN [0..n) DO      new: WORD _ Inline.BITSHIFT[a[i], -1] + ci;      ci _ IF (Inline.BITAND[a[i], 1]) = 0 THEN 0 ELSE 100000B;      a[i] _ new;      ENDLOOP;    END;  Add: PROCEDURE [a, b, c: POINTER TO ARRAY OF WORD, n: CARDINAL] =    BEGIN    carry: BOOLEAN _ FALSE;    FOR i: CARDINAL DECREASING IN [0..n) DO      temp: LONG CARDINAL _ LONG[b[i]] + LONG[c[i]];      IF carry THEN temp _ temp + 1;      carry _ Inline.HighHalf[temp] # 0;      a[i] _ Inline.LowHalf[temp];      ENDLOOP;    END;  Mult: PROCEDURE [a, b, c: POINTER TO ARRAY OF WORD, n: CARDINAL] =    BEGIN    n2: CARDINAL _ 2*n;    bb: ARRAY [0..10B) OF WORD _ ALL[0];    Inline.COPY[to: @bb, nwords: n, from: b];    RightShift[LOOPHOLE[@bb], n2];    FOR i: CARDINAL IN [0..n2) DO a[i] _ 0; ENDLOOP;    FOR i: CARDINAL IN [0..n*16 - 1) DO      w: WORD _ c[i/16];      IF INTEGER[Inline.BITSHIFT[w, i MOD 16]] < 0 THEN	Add[a, a, LOOPHOLE[@bb], n2];      RightShift[LOOPHOLE[@bb], n2];      ENDLOOP;    END;  END.