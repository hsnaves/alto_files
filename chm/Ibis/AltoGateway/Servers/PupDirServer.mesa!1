-- File: PupDirServer.mesa,  Last Edit: HGM  March 8, 1981  1:25 AMDIRECTORY  Ascii USING [CR],  Process USING [Detach, SetTimeout, MsecToTicks, Pause, Yield],  String USING [EquivalentString, AppendChar, AppendString, AppendDecimal],  Time USING [AppendCurrent],  Event USING [Item, Reason, AddNotifier],  Put USING [Line],  Window USING [Handle],  File USING [Capability],  MiscServerDefs USING [    PupMiscServerOn, PupMiscServerOff, IgnoreThisPacket, SetDirectoryServer],  Slosh USING [    AddProcs, RecvStatus, RecvFile, RejectThisTrash, RetransmissionInterval,    SendFile, Why],  NameServerDefs USING [    lockDirRequest, lockDirReply, unlockDirRequest, unlockDirReply,    CloseDirectoryFile, CheckDirectoryFile, FlushWholeCache,    GetDirectoryFile, GetDirectoryVersion, OpenDirectoryFile, ResetDirectoryFile],  StatsDefs USING [StatCounterIndex, StatIncr],  PupDefs USING [    GetFreePupBuffer, AppendHostName, PupAddress, PupBuffer,    PupRouterBroadcastThis, PupSocket, PupSocketDestroy, PupSocketID,    PupSocketMake, ReturnFreePupBuffer, SecondsToTocks, SetPupContentsWords,    ReturnPup, SendPup, UniqueLocalPupAddress, UniqueLocalPupSocketID],  PupTypes USING [fillInPupAddress, miscSrvSoc];PupDirServer: MONITOR  IMPORTS    Process, String, Time, Event, Put, Slosh, MiscServerDefs, NameServerDefs,    StatsDefs, PupDefs  EXPORTS NameServerDefs =  BEGIN OPEN StatsDefs, NameServerDefs, PupDefs;  msg: PUBLIC Window.Handle _ NIL;  eventItem: Event.Item _ [eventMask: 177777B, eventProc: Broom];  dirRunning, probing, announcing, sending: PUBLIC BOOLEAN _ FALSE;  useCount: CARDINAL _ 0;  pleaseStop: BOOLEAN _ FALSE;  probePeriod: CARDINAL _ 60; -- in minutes  tries: CARDINAL _ 0;  delay: CONDITION;  lock: BOOLEAN _ FALSE;  verbose: BOOLEAN = TRUE;  currentVersion: CARDINAL _ 0;  directoryName: STRING = "Pup-Network.Directory";  statVers, statSend: PUBLIC StatCounterIndex;  PupDirServerOn: PUBLIC PROCEDURE =    BEGIN    IF (useCount _ useCount + 1) = 1 THEN BEGIN dirRunning _ TRUE; Starter[]; END;    --UpdatePicture[];    END;  Starter: PROCEDURE =    BEGIN    pleaseStop _ FALSE;    MiscServerDefs.PupMiscServerOn[];    OpenDirectoryFile[];    currentVersion _ GetDirectoryVersion[];    MiscServerDefs.SetDirectoryServer[PupDirServer];    Process.Detach[FORK ProbeGovenor[]];    END;  PupDirServerOff: PUBLIC PROCEDURE =    BEGIN    IF useCount # 0 AND (useCount _ useCount - 1) = 0 THEN      BEGIN dirRunning _ FALSE; Stopper[]; END;    --UpdatePicture[];    END;  Stopper: PROCEDURE =    BEGIN    StopperLocked: ENTRY PROCEDURE = BEGIN NOTIFY delay; END;    MiscServerDefs.SetDirectoryServer[MiscServerDefs.IgnoreThisPacket];    pleaseStop _ TRUE;    StopperLocked[];    WHILE probing OR announcing OR sending DO Process.Yield[]; ENDLOOP;    CloseDirectoryFile[];    MiscServerDefs.PupMiscServerOff[];    END;  CountTries: ENTRY PROCEDURE = BEGIN tries _ tries + 1; END;  KickProber: ENTRY PROCEDURE =    BEGIN IF tries > 3 THEN RETURN; StartProbing[]; END;  StartProbingForDirectory: PUBLIC ENTRY PROCEDURE = BEGIN StartProbing[]; END;  StartProbing: INTERNAL PROCEDURE =    BEGIN    IF pleaseStop OR probing THEN RETURN;    probing _ TRUE;    Process.Detach[FORK Probe[]];    END;  ProbeGovenor: ENTRY PROCEDURE =    BEGIN    n: CARDINAL _ 1; -- probe 1 min after startup    Process.SetTimeout[@delay, Process.MsecToTicks[60000]];    UNTIL pleaseStop DO      WAIT delay; -- one minute      IF (n _ n - 1) = 0 THEN	BEGIN	tries _ 0;	StartProbing[];	WHILE probing DO WAIT delay; ENDLOOP;	n _ probePeriod;	END;      ENDLOOP;    END;  Probe: PROCEDURE =    BEGIN    b: PupBuffer;    from: PupSocketID _ UniqueLocalPupSocketID[];    socket: PupSocket;    bestSoFar: CARDINAL _ currentVersion;    where: PupAddress;    socket _ PupSocketMake[from, PupTypes.fillInPupAddress, SecondsToTocks[1]];    THROUGH [0..5) UNTIL bestSoFar > currentVersion DO      b _ GetFreePupBuffer[];      b.source.socket _ from;      b.dest.socket _ PupTypes.miscSrvSoc;      b.pupType _ netDirVersion;      b.pupWords[0] _ currentVersion;      SetPupContentsWords[b, 1];      PupRouterBroadcastThis[b];      UNTIL b = NIL DO	b _ socket.get[];	IF b # NIL THEN	  BEGIN	  IF b.pupType = netDirVersion AND b.pupWords[0] > bestSoFar THEN	    BEGIN bestSoFar _ b.pupWords[0]; where _ b.source; END;	  ReturnFreePupBuffer[b];	  END;	ENDLOOP;      ENDLOOP;    PupSocketDestroy[socket];    IF bestSoFar > currentVersion THEN      BEGIN      IF verbose THEN	BEGIN OPEN String;	text: STRING = [100];	Time.AppendCurrent[text];	AppendString[text, "  Found Pup-Network.Directory!"L];	AppendDecimal[text, bestSoFar];	AppendString[text, " on "L];	AppendHostName[text, where];	AppendChar[text, '.];	LogString[text];	END;      Process.Detach[FORK GetNewDirectory[where]];      RETURN;      END;    probing _ FALSE;    END;  Announce: PROCEDURE =    BEGIN    b: PupBuffer;    THROUGH [0..5) UNTIL pleaseStop DO      Process.Pause[1000];      b _ GetFreePupBuffer[];      b.source.socket _ b.dest.socket _ PupTypes.miscSrvSoc;      b.pupType _ netDirVersion;      b.pupWords[0] _ currentVersion;      SetPupContentsWords[b, 1];      PupRouterBroadcastThis[b];      ENDLOOP;    announcing _ FALSE;    END;  GetNewDirectory: PROCEDURE [where: PupAddress] =    BEGIN    from: PupAddress _ UniqueLocalPupAddress[@where];    status: Slosh.RecvStatus;    Ask: PROCEDURE =      BEGIN      b: PupBuffer _ GetFreePupBuffer[];      b.source _ from;      b.dest _ where;      b.address _ from;      SendPup[b, sendNetDir, 2*SIZE[PupAddress]];      END;    CountTries[];    status _ Slosh.RecvFile[      msg, directoryName, "Pup-Network.scratch$"L, GetDirectoryFile[], from, Ask];    IF status # statusStoreOk THEN      BEGIN      n: CARDINAL _ Slosh.RetransmissionInterval[];      IF status = statusDiskFull THEN {	CountTries[]; CountTries[]; CountTries[]; };      THROUGH [0..n) UNTIL pleaseStop DO	Process.Pause[Process.MsecToTicks[1000]]; ENDLOOP;      END;    probing _ FALSE;    IF status # statusStoreOk THEN KickProber[];    END;  Checker: PROCEDURE [why: Slosh.Why, fileName: STRING, temp: File.Capability] =    BEGIN    IF ~String.EquivalentString[fileName, directoryName] THEN RETURN;    SELECT why FROM      check => IF ~CheckDirectoryFile[temp] THEN ERROR Slosh.RejectThisTrash[NIL];      release => CloseDirectoryFile[];      arrived, failed =>	BEGIN	currentVersion _ ResetDirectoryFile[];	FlushWholeCache[];	announcing _ TRUE;	Process.Detach[FORK Announce[]];	END;      ENDCASE => ERROR    END;  SendDirectory: ENTRY PROCEDURE [where: PupAddress] =    BEGIN    IF verbose THEN      BEGIN      text: STRING = [100];      Time.AppendCurrent[text];      String.AppendString[text, "  Pup-Network.Directory wanted by "L];      AppendHostName[text, where];      String.AppendChar[text, '.];      LogString[text];      END;    IF Slosh.SendFile[msg, directoryName, GetDirectoryFile[], where] = ok THEN      StatIncr[statSend];    sending _ FALSE;    END;  PupDirServer: PUBLIC PROCEDURE [b: PupBuffer] =    BEGIN    IF ~(lock OR pleaseStop) OR b.pupType = unlockDirRequest THEN      SELECT b.pupType FROM	netDirVersion =>	  BEGIN	  StatIncr[statVers];	  SELECT b.pupWords[0] FROM	    = currentVersion => NULL; -- we have the same ones	    > currentVersion => KickProber[]; -- he has a newer one	    < currentVersion => -- tell him about our newer one	      BEGIN	      b.pupWords[0] _ currentVersion;	      ReturnPup[b, netDirVersion, 2];	      RETURN;	      END;	    ENDCASE => ERROR;	  END;	sendNetDir =>	  BEGIN	  IF ~sending THEN	    BEGIN	    sending _ TRUE;	    Process.Detach[FORK SendDirectory[b.address]];	    END;	  END;	lockDirRequest =>	  BEGIN	  lock _ TRUE;	  ReturnPup[b, lockDirReply, 0];	  CloseDirectoryFile[];	  FlushWholeCache[];	  currentVersion _ 0;	  RETURN;	  END;	unlockDirRequest =>	  BEGIN	  lock _ FALSE;	  ReturnPup[b, unlockDirReply, 0];	  IF currentVersion = 0 THEN currentVersion _ ResetDirectoryFile[];	  tries _ 0;	  KickProber[];	  RETURN;	  END;	ENDCASE;    ReturnFreePupBuffer[b];    END;  LogString: PROCEDURE [text: STRING] =    BEGIN IF msg # NIL THEN Put.Line[msg, text]; Put.Line[NIL, text]; END;  Broom: PROCEDURE [why: Event.Reason] =    BEGIN    IF useCount = 0 THEN RETURN;    SELECT why FROM      makeImage, makeCheck, stopMesa => IF dirRunning THEN Stopper[];      startImage, restartCheck, continueCheck => IF dirRunning THEN Starter[];      ENDCASE => NULL;    END;  -- initialization  Event.AddNotifier[@eventItem];  Slosh.AddProcs[Checker];  END.