-- File: PupMicrocodeBooterAlto.mesa,  Last Edit: HGM  November 2, 1980  12:10 PMDIRECTORY  Environment USING [bytesPerPage],  System USING [Pulses, GetClockPulses, PulsesToMicroseconds],  Lock USING [LockDisk, UnlockDisk],  BootServerDefs USING [    BootFile, WhatHappened, microcodeReply, microcodeVersionNumber],  ReadDefs USING [    CBZptr, CBptr, GetNextPage, ReleasePage, StartReading, StopReading],  CommUtilDefs USING [CopyLong],  PupDefs USING [PupBuffer, GetLocalPupAddress, GetFreePupBuffer, SendPup],  PupTypes USING [PupAddress, miscSrvSoc];PupMicrocodeBooterAlto: PROGRAM  IMPORTS System, Lock, CommUtilDefs, ReadDefs, PupDefs EXPORTS BootServerDefs =  BEGIN OPEN BootServerDefs;  blankDisplay: BOOLEAN _ TRUE;  bufferSize: CARDINAL _ 5; -- patch by hand to adjust  MicrocodeBooter: PUBLIC PROCEDURE [bf: BootFile, him: PupTypes.PupAddress]    RETURNS [what: WhatHappened] =    BEGIN    zone: ReadDefs.CBZptr;    cb: ReadDefs.CBptr;    pulses: System.Pulses _ System.GetClockPulses[];    packetNumber: CARDINAL _ 0;    n: CARDINAL;    chunk: POINTER TO ARRAY [0..0) OF WORD;    me: PupTypes.PupAddress _ PupDefs.GetLocalPupAddress[      PupTypes.miscSrvSoc, @him];    IF ~Lock.LockDisk[bf.fileName, read, blankDisplay] THEN RETURN[diskBusy];    BEGIN    one, two: WORD;    b: PupDefs.PupBuffer;    zone _ ReadDefs.StartReading[@bf.file.fID, bufferSize];    cb _ ReadDefs.GetNextPage[zone]; -- skip file system leader page    ReadDefs.ReleasePage[cb];    cb _ ReadDefs.GetNextPage[zone]; -- skip boot file header page    chunk _ cb.dataAddress;    IF chunk[0] # microcodeVersionNumber THEN GOTO MisMatch;    ReadDefs.ReleasePage[cb];    -- It takes 3 Alto words to specify a complete D0 ControlStore word.  In order to simplify the EProm logic, the Boot Server sends packets that have an integral number of ControlStore words.  Unfortunately that doesn't mesh with the Alto wordsPerPage.  That is the story behind the following verbose clump of code.    DO      length: CARDINAL;      -- first of three      cb _ ReadDefs.GetNextPage[zone];      chunk _ cb.dataAddress;      n _ cb.labelAddress.bytes;      IF n = 0 THEN EXIT;      length _ IF n = Environment.bytesPerPage THEN n - 2 ELSE n;      b _ PupDefs.GetFreePupBuffer[];      b.dest _ him;      b.source _ me;      b.pupID _ [microcodeVersionNumber, packetNumber];      CommUtilDefs.CopyLong[from: @chunk[0], nwords: 255, to: @b.pupWords[0]];      one _ chunk[255];      PupDefs.SendPup[b, BootServerDefs.microcodeReply, length];      packetNumber _ packetNumber + 1;      ReadDefs.ReleasePage[cb];      IF n # Environment.bytesPerPage THEN EXIT;      -- second of three      cb _ ReadDefs.GetNextPage[zone];      chunk _ cb.dataAddress;      n _ cb.labelAddress.bytes;      length _ IF n = Environment.bytesPerPage THEN n - 2 ELSE n + 2;      b _ PupDefs.GetFreePupBuffer[];      b.dest _ him;      b.source _ me;      b.pupID _ [microcodeVersionNumber, packetNumber];      b.pupWords[0] _ one;      -- copy extra word in case this is the last page      CommUtilDefs.CopyLong[from: @chunk[0], nwords: 255, to: @b.pupWords[1]];      one _ chunk[254];      two _ chunk[255];      PupDefs.SendPup[b, BootServerDefs.microcodeReply, length];      packetNumber _ packetNumber + 1;      ReadDefs.ReleasePage[cb];      IF n # Environment.bytesPerPage THEN EXIT;      -- third of three      cb _ ReadDefs.GetNextPage[zone];      chunk _ cb.dataAddress;      n _ cb.labelAddress.bytes;      b _ PupDefs.GetFreePupBuffer[];      b.dest _ him;      b.source _ me;      b.pupID _ [microcodeVersionNumber, packetNumber];      b.pupWords[0] _ one;      b.pupWords[1] _ two;      CommUtilDefs.CopyLong[from: @chunk[0], nwords: 256, to: @b.pupWords[2]];      PupDefs.SendPup[b, BootServerDefs.microcodeReply, n + 4];      packetNumber _ packetNumber + 1;      ReadDefs.ReleasePage[cb];      IF n # Environment.bytesPerPage THEN EXIT;      ENDLOOP;    b _ PupDefs.GetFreePupBuffer[];    b.dest _ him;    b.source _ me;    b.pupID _ [microcodeVersionNumber, packetNumber];    PupDefs.SendPup[b, BootServerDefs.microcodeReply, 0];    -- End Marker for Initial    ReadDefs.StopReading[zone];    pulses _ System.Pulses[System.GetClockPulses[] - pulses];    bf.count _ bf.count + 1;    bf.ms _ bf.ms + System.PulsesToMicroseconds[pulses]/1000;    what _ micro;    EXITS MisMatch => BEGIN ReadDefs.StopReading[zone]; what _ troubles; END;    END;    Lock.UnlockDisk[bf.fileName, blankDisplay];    END;  END.