-- File: EchoUserTool.mesa,  Last Edit: HGM  January 30, 1981  2:58 PM-- Please don't forget to update the herald....DIRECTORY  Inline USING [BITNOT, BITAND],  Process USING [SetPriority],  Storage USING [Node, String, FreeNodeNil, FreeString],  String USING [AppendString, AppendChar, AppendNumber],  Time USING [AppendCurrent, Current],  Event USING [Item, Reason, AddNotifier],  FormSW USING [    ClientItemsProcType, ProcType, AllocateItemDescriptor, newLine, Display,    FindItem, CommandItem, BooleanItem, StringItem, NumberItem],  MsgSW USING [Post],  Put USING [Char, CR, Text, Line, LongDecimal, LongNumber],  Tool USING [    Create, MakeSWsProc, UnusedLogName, MakeMsgSW, MakeFormSW, MakeFileSW,    AddThisSW],  ToolWindow USING [TransitionProcType, DisplayProcType, CreateSubwindow],  Window USING [Handle, Box, DisplayData, DisplayInvert, DisplayWhite],  StatsDefs USING [StatPrintCurrent, StatReady, StatSince],  PupDefs USING [    PupPackageMake, PupPackageDestroy, GetFreePupBuffer, ReturnFreePupBuffer,    PupBuffer, PupSocket, PupSocketDestroy, PupSocketMake, SecondsToTocks,    SetPupContentsWords, GetPupContentsBytes, DataWordsPerPupBuffer,    AppendPupAddress, GetPupAddress, PupNameTrouble],  PupTypes USING [PupAddress, fillInSocketID, echoSoc, maxDataWordsPerGatewayPup];EchoUserTool: PROGRAM  IMPORTS    Inline, Process, Storage, String, Time, Event, FormSW, MsgSW, Put, Tool,    ToolWindow, Window, StatsDefs, PupDefs =  BEGIN OPEN PupDefs, PupTypes;  msg, form, boxes, log: Window.Handle;  eventItem: Event.Item _ [eventMask: 177777B, eventProc: Broom];  -- Be sure to initialize it when it is allocated!!!!  data: POINTER TO Data _ NIL; -- NIL when we are inactive  Data: TYPE = RECORD [    length: CARDINAL _ 100,    fixedLength: BOOLEAN _ FALSE,    where: PupAddress _ [[0], [0], PupTypes.echoSoc],    picks: ARRAY [0..16] OF CARDINAL _ ALL[0],    drops: ARRAY [0..16] OF CARDINAL _ ALL[0],    sent, good, missed, late, bad, horrible, error, words: LONG CARDINAL _ 0,    pleaseStop: BOOLEAN _ FALSE,    alignTheFink: WORD _ NULL,    lowPriority: BOOLEAN _ FALSE,    alignTheFinkAgain: WORD _ NULL,    verbose: BOOLEAN _ FALSE,    alignTheFinkYetAgain: WORD _ NULL,    doStats: BOOLEAN _ FALSE,    alignTheFinkStillAgain: WORD _ NULL,    checkit: BOOLEAN _ TRUE,    echoer: PROCESS _ NULL,    indicator: {left, right, off} _ off,    running: BOOLEAN _ FALSE,    target: STRING _ NULL];  Initialize: PROCEDURE =    BEGIN    [] _ Tool.Create[      name: "Pup Echo User of January 30, 1981"L, makeSWsProc: MakeSWs,      clientTransition: ClientTransition];    Event.AddNotifier[@eventItem];    END;  EchoUserOn: PROCEDURE =    BEGIN    IF data.length > PupDefs.DataWordsPerPupBuffer[] THEN      BEGIN MsgSW.Post[msg, "Length is too long."L]; RETURN; END;    WriteCR[];    WriteCurrentDateAndTime[];    WriteString["  Echoing to "L];    IF ~FindPath[] THEN RETURN;    data.running _ TRUE;    UpdatePicture[];    data.echoer _ FORK DoIt[];    END;  EchoUserOff: PROCEDURE =    BEGIN    IF data = NIL THEN RETURN;    data.pleaseStop _ TRUE;    JOIN data.echoer[];    data.running _ data.pleaseStop _ FALSE;    UpdatePicture[];    END;  UpdatePicture: PROCEDURE =    BEGIN    FormSW.FindItem[form, startIX].flags.invisible _ data.running;    FormSW.FindItem[form, stopIX].flags.invisible _ ~data.running;    FormSW.Display[form];    END;  FindPath: PROCEDURE RETURNS [BOOLEAN] =    BEGIN OPEN data;    WriteString[target];    WriteChar['=];    GetPupAddress[      @where, target !      PupNameTrouble =>	BEGIN MsgSW.Post[msg, e]; WriteLine[e]; GOTO Trouble; END];    PrintPupAddress[where];    WriteLine["."L];    RETURN[TRUE];    EXITS Trouble => RETURN[FALSE];    END;  ClearCounters: PROCEDURE =    BEGIN OPEN data;    sent _ good _ missed _ late _ bad _ horrible _ error _ words _ 0;    picks _ ALL[0];    drops _ ALL[0];    END;  AddToHist: PROCEDURE [hist: POINTER TO ARRAY [0..16] OF CARDINAL, bits: WORD] =    BEGIN OPEN data;    i: CARDINAL;    IF bits = 0 THEN RETURN;    SELECT bits FROM      1 => i _ 15;      2 => i _ 14;      4 => i _ 13;      10B => i _ 12;      20B => i _ 11;      40B => i _ 10;      100B => i _ 9;      200B => i _ 8;      400B => i _ 7;      1000B => i _ 6;      2000B => i _ 5;      4000B => i _ 4;      10000B => i _ 3;      20000B => i _ 2;      40000B => i _ 1;      100000B => i _ 0;      ENDCASE => i _ 16;    hist[i] _ hist[i] + 1;    END;  PrintSummary: PROCEDURE [howLong: LONG CARDINAL] =    BEGIN OPEN data;    WriteCR[];    WriteLongDecimal[sent];    WriteLine[" packets sent."L];    IF howLong # 0 THEN      BEGIN      WriteLongDecimal[sent/howLong];      WriteLine[" packets per second."L];      WriteLongDecimal[16*words/howLong];      WriteLine[" data bits per second."L];      END;    IF sent # 0 THEN      BEGIN      ShowPercent[good, "good packets received."L];      ShowPercent[missed, "packets missed."L];      ShowPercent[late, "late (or??) packets received."L];      ShowPercent[bad, "bad packets received."L];      ShowPercent[horrible, "packets received with more than 10 words wrong."L];      ShowPercent[error, "error packets received."L];      END;    IF bad # 0 THEN      BEGIN      i: CARDINAL;      x: WORD _ 100000B;      WriteCR[];      WriteLine["   Bit  Picked Dropped"L];      FOR i IN [0..16] DO	IF picks[i] # 0 OR drops[i] # 0 THEN	  BEGIN	  IF i = 16 THEN WriteString[" Other"L] ELSE O6[x];	  D8[picks[i]];	  D8[drops[i]];	  WriteCR[];	  END;	x _ x/2;	ENDLOOP;      END;    END;  ShowPercent: PROCEDURE [n: LONG CARDINAL, s: STRING] =    BEGIN OPEN data;    IF n = 0 THEN RETURN;    WriteLongDecimal[n];    WriteString[" ("L];    WriteLongDecimal[n*100/sent];    WriteString["%) "L];    WriteLine[s];    END;  DoIt: PROCEDURE =    BEGIN OPEN data;    k: CARDINAL;    b: PupBuffer;    cycle, maxLength, myLength: CARDINAL;    packetNumber: CARDINAL _ LAST[CARDINAL];    mySoc: PupSocket _ PupSocketMake[fillInSocketID, where, SecondsToTocks[2]];    start, stop: LONG CARDINAL;    maxLength _ MIN[      PupDefs.DataWordsPerPupBuffer[], PupTypes.maxDataWordsPerGatewayPup];    IF lowPriority THEN Process.SetPriority[0];    ClearCounters[];    myLength _ MIN[length, maxLength];    IF fixedLength THEN      BEGIN      WriteString["Packet length is "L];      WriteDecimal[myLength];      WriteLine[" words."L];      END;    SetupBoxes[];    IF doStats THEN StatsDefs.StatReady[];    start _ Time.Current[];    UNTIL pleaseStop DO      -- NB: No check for short buffers      FOR cycle IN [0..256) UNTIL pleaseStop DO	b _ GetFreePupBuffer[];	myLength _ IF fixedLength THEN maxLength ELSE cycle;	FOR k IN [0..myLength) DO b.pupWords[k] _ k + cycle*400B; ENDLOOP;	b.pupID.a _ b.pupID.b _ (packetNumber _ packetNumber + 1);	b.pupType _ echoMe;	SetPupContentsWords[b, myLength];	mySoc.put[b];	sent _ sent + 1;	words _ words + myLength;	UNTIL (b _ mySoc.get[]) = NIL DO	  -- Until timeout, or we find the expected one	  SELECT TRUE FROM	    (b.pupType = error) =>	      BEGIN error _ error + 1; WriteCR[]; PrintErrorPup[b]; END;	    ((b.pupType # iAmEcho) OR (b.pupID.a # packetNumber) OR	      (b.pupID.b # packetNumber) OR (GetPupContentsBytes[b] # 2*myLength))	      => BEGIN late _ late + 1; WriteChar['#]; END;	    ENDCASE =>	      BEGIN	      hits: CARDINAL _ 0;	      FlipBoxes[];	      IF data.checkit THEN		FOR k IN [0..myLength) DO		  IF b.pupWords[k] # k + cycle*400B THEN		    BEGIN OPEN Inline;		    expected, found, picked, dropped: WORD;		    IF hits = 0 THEN		      BEGIN		      WriteCR[];		      WriteCurrentDateAndTime[];		      WriteString["  Data compare error(s) on packet number "L];		      WriteDecimal[packetNumber];		      WriteLine["."L];		      WriteLine["Idx Expected    Found   Picked  Dropped"L];		      END;		    expected _ k + cycle*400B;		    found _ b.pupWords[k];		    picked _ BITAND[found, BITNOT[expected]];		    dropped _ BITAND[expected, BITNOT[found]];		    AddToHist[@picks, picked];		    AddToHist[@drops, dropped];		    IF hits < 10 THEN		      BEGIN		      O3[k];		      O9[expected];		      O9[found];		      O9[picked];		      O9[dropped];		      WriteCR[];		      END;		    hits _ hits + 1;		    END;		  ENDLOOP;	      IF hits = 0 THEN good _ good + 1 ELSE bad _ bad + 1;	      IF hits = 0 AND verbose THEN WriteChar['!];	      IF hits > 10 THEN		BEGIN horrible _ horrible + 1; WriteLine["...."L]; END;	      EXIT; -- found the expected one	      END;	  ReturnFreePupBuffer[b];	  ENDLOOP;	IF b # NIL THEN ReturnFreePupBuffer[b]	ELSE BEGIN missed _ missed + 1; WriteChar['?]; END;	ENDLOOP;      IF verbose THEN WriteCR[] ELSE WriteChar['.];      ENDLOOP;    stop _ Time.Current[];    WriteCR[];    PupSocketDestroy[mySoc];    SetDownBoxes[];    IF doStats THEN StatsDefs.StatSince[log];    PrintSummary[stop - start];    END;  -- IO things  WriteChar: PROCEDURE [c: CHARACTER] = BEGIN Put.Char[log, c]; END;  WriteCR: PROCEDURE = BEGIN Put.CR[log]; END;  WriteString: PROCEDURE [s: STRING] = BEGIN Put.Text[log, s]; END;  WriteLine: PROCEDURE [s: STRING] = BEGIN Put.Line[log, s]; END;  WriteLongDecimal: PROCEDURE [n: LONG CARDINAL] =    BEGIN Put.LongDecimal[log, n]; END;  WriteDecimal: PROCEDURE [n: CARDINAL] = INLINE BEGIN WriteNumber[n, 10, 0]; END;  WriteOctal: PROCEDURE [n: CARDINAL] = INLINE BEGIN WriteNumber[n, 8, 0]; END;  WriteNumber: PROCEDURE [n, radix, width: CARDINAL] = INLINE    BEGIN    temp: STRING = [25];    String.AppendNumber[temp, n, radix];    THROUGH [temp.length..width) DO WriteChar[' ]; ENDLOOP;    WriteString[temp];    END;  D8: PROCEDURE [n: CARDINAL] = BEGIN WriteNumber[n, 10, 8]; END;  O3: PROCEDURE [n: CARDINAL] = BEGIN WriteNumber[n, 8, 3]; END;  O6: PROCEDURE [n: CARDINAL] = BEGIN WriteNumber[n, 8, 3]; END;  O9: PROCEDURE [n: CARDINAL] = BEGIN WriteNumber[n, 8, 9]; END;  WriteCurrentDateAndTime: PROCEDURE =    BEGIN time: STRING = [20]; Time.AppendCurrent[time]; WriteString[time]; END;  PrintPupAddress: PROCEDURE [a: PupAddress] =    BEGIN temp: STRING = [40]; AppendPupAddress[temp, a]; WriteString[temp]; END;  PrintErrorPup: PUBLIC PROCEDURE [b: PupDefs.PupBuffer] =    BEGIN    i, len: CARDINAL;    temp: STRING = [100];    String.AppendString[temp, "Error Pup, code="L];    String.AppendNumber[temp, LOOPHOLE[b.errorCode], 8];    String.AppendString[temp, ", from: "L];    AppendPupAddress[temp, b.source];    String.AppendString[temp, ": "L];    len _ PupDefs.GetPupContentsBytes[b];    FOR i IN [0..len - 2*(10 + 1 + 1)) UNTIL temp.length = temp.maxlength DO      String.AppendChar[temp, b.errorText[i]]; ENDLOOP;    WriteLine[temp];    MsgSW.Post[msg, temp];    END;  indicatorBox: Window.Box = [[25, 10], [16, 16]];  DisplayBoxes: ToolWindow.DisplayProcType =    BEGIN    pattern: ARRAY [0..1] OF ARRAY [0..8) OF WORD;    left: WORD = 177400B;    right: WORD = 000377B;    SELECT data.indicator FROM      left => pattern _ [ALL[left], ALL[right]];      right => pattern _ [ALL[right], ALL[left]];      off => pattern _ [ALL[0], ALL[0]];      ENDCASE;    Window.DisplayData[window, indicatorBox, @pattern, 1]    END;  SetupBoxes: PROCEDURE = BEGIN data.indicator _ left; DisplayBoxes[boxes]; END;  FlipBoxes: PROCEDURE =    BEGIN    SELECT data.indicator FROM      left => data.indicator _ right;      off, right => data.indicator _ left;      ENDCASE;    Window.DisplayInvert[boxes, indicatorBox];    END;  SetDownBoxes: PROCEDURE =    BEGIN data.indicator _ off; Window.DisplayWhite[boxes, indicatorBox]; END;  MakeBoxesSW: PROCEDURE [window: Window.Handle] =    BEGIN    boxes _ ToolWindow.CreateSubwindow[parent: window, display: DisplayBoxes];    boxes.box.dims.h _ 36;    Tool.AddThisSW[window: window, sw: boxes, swType: vanilla];    END;  Start: FormSW.ProcType = BEGIN EchoUserOn[]; END;  Stop: FormSW.ProcType = BEGIN EchoUserOff[]; END;  Ready: FormSW.ProcType = BEGIN StatsDefs.StatReady[]; END;  Since: FormSW.ProcType = BEGIN StatsDefs.StatSince[log]; END;  Totals: FormSW.ProcType = BEGIN StatsDefs.StatPrintCurrent[log]; END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    msg _ Tool.MakeMsgSW[window: window, lines: 5];    form _ Tool.MakeFormSW[window: window, formProc: MakeForm];    MakeBoxesSW[window];    Tool.UnusedLogName[logFileName, "EchoUser.log$"L];    log _ Tool.MakeFileSW[window: window, name: logFileName];    END;  startIX: CARDINAL = 0;  stopIX: CARDINAL = 1;  runningIX: CARDINAL = 2;  MakeForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 12;    items _ FormSW.AllocateItemDescriptor[nParams];    items[0] _ FormSW.CommandItem[      tag: "Start"L, proc: Start, place: FormSW.newLine];    items[1] _ FormSW.CommandItem[      tag: "Stop"L, proc: Stop, place: FormSW.newLine, invisible: TRUE];    items[2] _ FormSW.BooleanItem[tag: "LowPriority"L, switch: @data.lowPriority];    items[3] _ FormSW.BooleanItem[      tag: "DoStats"L, switch: @data.doStats, place: FormSW.newLine];    items[4] _ FormSW.CommandItem[tag: "Ready"L, proc: Ready];    items[6] _ FormSW.CommandItem[tag: "Recent"L, proc: Since];    items[5] _ FormSW.CommandItem[tag: "Totals"L, proc: Totals];    items[7] _ FormSW.BooleanItem[      tag: "Verbose"L, switch: @data.verbose, place: FormSW.newLine];    items[8] _ FormSW.BooleanItem[tag: "Checkit"L, switch: @data.checkit];    items[9] _ FormSW.BooleanItem[      tag: "FixedLength"L, switch: @data.fixedLength, place: FormSW.newLine];    items[10] _ FormSW.NumberItem[tag: "(Max)Length"L, value: @data.length];    items[11] _ FormSW.StringItem[      tag: "Target"L, string: @data.target, place: FormSW.newLine];    RETURN[items, TRUE];    END;  AlreadyActive: ERROR = CODE;  NotActive: ERROR = CODE;  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>	BEGIN	IF data # NIL THEN ERROR AlreadyActive;	data _ Storage.Node[SIZE[Data]];	data^ _ [];	data.target _ Storage.String[20];	String.AppendString[data.target, "ME"L];	PupDefs.PupPackageMake[];	END;      new = inactive =>	BEGIN	IF data = NIL THEN ERROR NotActive;	IF data.running THEN EchoUserOff[];	PupDefs.PupPackageDestroy[];	Storage.FreeString[data.target];	data _ Storage.FreeNodeNil[data];	END;      ENDCASE;    END;  Broom: PROCEDURE [why: Event.Reason] =    BEGIN    SELECT why FROM      makeImage, makeCheck =>	BEGIN	IF data = NIL THEN RETURN;	IF data.running THEN EchoUserOff[];	PupDefs.PupPackageDestroy[];	END;      startImage, restartCheck, continueCheck =>	BEGIN IF data = NIL THEN RETURN; PupDefs.PupPackageMake[]; END;      ENDCASE => NULL;    END;  -- Main Body  Initialize[];  END.