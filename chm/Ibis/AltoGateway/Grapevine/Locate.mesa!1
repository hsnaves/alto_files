-- Transport Mechanism - Location of server by client ---- [Juniper]<DMS>MS>Locate.mesa-- Andrew Birrell  18-Mar-81 17:55:30 --DIRECTORYBodyDefs	USING [Connect, maxRNameLength, RName],LocateDefs	USING [FoundServerInfo, FoundState],NameInfoDefs	USING [Close, Enumerate, GetConnect, GetMembers,		       MemberInfo, NameType, RListHandle],ProtocolDefs	USING [Connect, Init, IsLocal, maxConnectLength,		       RegServerEnquirySocket, RegServerPollingSocket],PupDefs		USING [EnumeratePupAddresses, GetFreePupBuffer,		       GetPupAddress, PupAddress, PupBuffer,		       PupNameTrouble, PupRouterSendThis, PupSocket,		       PupSocketDestroy, PupSocketID, PupSocketMake,		       ReturnFreePupBuffer, SecondsToTocks,		       SetPupContentsWords],PupTypes	USING [fillInSocketID, PupSocketID],Storage		USING[ Node, Free ],String		USING [AppendString, EquivalentString];Locate: MONITOR   IMPORTS NameInfoDefs, ProtocolDefs, PupDefs, Storage, String   EXPORTS LocateDefs =BEGINReplyInfo: TYPE = RECORD[ found: BOOLEAN, where: PupDefs.PupAddress ];AcceptReplies: PROCEDURE[ socket: PupDefs.PupSocket, sent: CARDINAL,                    accept: PROCEDURE[PupDefs.PupAddress]RETURNS[BOOLEAN] ]                 RETURNS[ info: ReplyInfo ] =   BEGIN   bestHops: CARDINAL _ LAST[CARDINAL];   info.found _ FALSE;   UNTIL info.found   OR sent = 0 -- we may finish early or late, but it will be near enough--   DO BEGIN      b: PupDefs.PupBuffer = socket.get[];      IF b = NIL      THEN EXIT      ELSE BEGIN           sent _ sent-1;           SELECT b.pupType FROM             iAmEcho =>               BEGIN               info.where _ b.source;               IF accept[info.where] THEN info.found _ TRUE               END;           ENDCASE;           PupDefs.ReturnFreePupBuffer[b];           END;      END;   ENDLOOP;   END;   SendEnquiry: PROCEDURE[addr: PupDefs.PupAddress, from: PupDefs.PupAddress] =   BEGIN   b: PupDefs.PupBuffer;   b _ PupDefs.GetFreePupBuffer[];   b.source _ from;   b.pupType _ echoMe;   b.dest _ addr;   -- force socket number, because database may not have GV test-mode socket numbers --   b.dest.socket _ ProtocolDefs.RegServerPollingSocket;   PupDefs.SetPupContentsWords[b, 0];   PupDefs.PupRouterSendThis[b];   END;EnquiryInfo: TYPE = RECORD[ outcome:{ done, down, badName },                            local: BOOLEAN, sent: CARDINAL];gvName: STRING = "gv.gv"; -- NA for registration servers--NoGVRS: SIGNAL = CODE; -- debugging; may be resumed --GetGVRegServer: PROCEDURE[ from: PupDefs.PupAddress ]                  RETURNS[ info: EnquiryInfo ] =   BEGIN   Work: PROCEDURE[addr: PupDefs.PupAddress] RETURNS[ BOOLEAN ] =      BEGIN      -- don't trust socket number given by NLS (?) --      addr.socket _ ProtocolDefs.RegServerEnquirySocket;      SendEnquiry[addr, from]; info.sent _ info.sent+1;      RETURN[FALSE]      END;   GVRS: STRING = "GrapevineRServer"L;   info _ [done, FALSE, 0];   -- hack to allow test servers anywhere on my net --   [] _ Work[ [net:[0], host:[0],               socket: ProtocolDefs.RegServerEnquirySocket ] ];   -- end hack --   BEGIN      ENABLE PupDefs.PupNameTrouble =>         IF code = errorFromServer         THEN BEGIN SIGNAL NoGVRS[]; GOTO bad END         ELSE GOTO down;      [] _ PupDefs.EnumeratePupAddresses[GVRS, Work ];      EXITS         down => info.outcome _ down;         bad => info.outcome _ badName;   END;   END;GetGroupInfo: PROC[ who, local: BodyDefs.RName,                          from: PupDefs.PupAddress]                 RETURNS[ info: EnquiryInfo ] =   BEGIN   mInfo: NameInfoDefs.MemberInfo =  NameInfoDefs.GetMembers[who];   WITH m: mInfo SELECT FROM     notFound => info _ [badName,FALSE,0];     allDown => info _ [down,FALSE,0];     individual => info _ [badName,FALSE,0];     group =>       BEGIN       apparent: CARDINAL _ 0;       actual: CARDINAL _ 0;       Count: PROC[member:BodyDefs.RName]RETURNS[done:BOOLEAN] =          { apparent _ apparent + 1; done _ FALSE };       addresses: DESCRIPTOR FOR ARRAY OF PupDefs.PupAddress;       Access: PROC[member:BodyDefs.RName]RETURNS[done:BOOLEAN] =          BEGIN          cInfo: NameInfoDefs.NameType;          connect: ProtocolDefs.Connect = [ProtocolDefs.maxConnectLength];          done _ FALSE;          cInfo _ NameInfoDefs.GetConnect[member, connect];          SELECT cInfo FROM            individual =>              BEGIN              PupDefs.GetPupAddress[@(addresses[actual]), connect !                             PupDefs.PupNameTrouble => GOTO cant];              actual _ actual + 1;              EXITS cant => NULL;              END;          ENDCASE => NULL -- ignore others --;          END;       NameInfoDefs.Enumerate[m.members, Count];       addresses _ DESCRIPTOR[Storage.Node[apparent*                                           SIZE[PupDefs.PupAddress]],                              apparent];       NameInfoDefs.Enumerate[m.members, Access];       NameInfoDefs.Close[m.members];       info _ [done,FALSE,0];       FOR i: CARDINAL IN [0..actual)       DO IF local = NIL          THEN { SendEnquiry[addresses[i], from]; info.sent _ info.sent+1 }          ELSE BEGIN               IF ProtocolDefs.IsLocal[addresses[i]]               THEN BEGIN                    info.local _ TRUE;                    local.length _ 0; String.AppendString[local, who];                    END;               END;       ENDLOOP;       Storage.Free[BASE[addresses]];       END;   ENDCASE => ERROR;   END;FindRegServer: PUBLIC PROCEDURE[ who: BodyDefs.RName,                  accept: PROCEDURE[PupDefs.PupAddress]RETURNS[BOOLEAN] ]               RETURNS[ foundInfo: LocateDefs.FoundServerInfo ] =   BEGIN   -- find a registration server for given R-Name --   sep: CHARACTER = '.; -- SN sep NA --   rPtr: CARDINAL;   NA: BodyDefs.RName = [BodyDefs.maxRNameLength];   -- parse to find registry name --   rPtr _ who.length;   DO IF rPtr = 0 THEN RETURN[ [notFound[]] ];      rPtr_rPtr-1;      IF who[rPtr] = sep THEN EXIT;   ENDLOOP;   NA.length _ 0;   FOR rPtr_rPtr+1, rPtr+1 WHILE rPtr # who.length   DO NA[NA.length] _ who[rPtr]; NA.length_NA.length+1 ENDLOOP;   String.AppendString[NA, ".GV"L];   foundInfo _ FindNearestServer[NA, accept];   END; --FindRegServer--FindNearestServer: PUBLIC PROCEDURE[list: BodyDefs.RName,                     accept: PROCEDURE[PupDefs.PupAddress]RETURNS[BOOLEAN] ]                   RETURNS[info: LocateDefs.FoundServerInfo] =   BEGIN   socket: PupDefs.PupSocket = PupDefs.PupSocketMake[              local: PupTypes.fillInSocketID,              remote:, ticks: PupDefs.SecondsToTocks[1] ];   from: PupDefs.PupAddress = socket.getLocalAddress[];   THROUGH [1..3] -- re-tries for lost packets --   DO BEGIN      sendInfo: EnquiryInfo = IF String.EquivalentString[list, gvName]             THEN GetGVRegServer[from]             ELSE GetGroupInfo[list,NIL,from];      SELECT sendInfo.outcome FROM        badName => { info _ [notFound[]]; EXIT };        down => { info _ [allDown[]]; EXIT };        done =>          BEGIN          reply: ReplyInfo = AcceptReplies[socket, sendInfo.sent, accept];          IF reply.found          THEN { info _  [found[reply.where]]; EXIT }          ELSE NULL --continue round loop--          END;      ENDCASE => ERROR;      END;      REPEAT   FINISHED => info _ [allDown[]]   ENDLOOP;   PupDefs.PupSocketDestroy[socket];   END --FindNearestServer--;FindLocalServer: PUBLIC PROCEDURE[list, local: BodyDefs.RName]                 RETURNS[ LocateDefs.FoundState ] =   BEGIN   sendInfo: EnquiryInfo = GetGroupInfo[list, local, ];   SELECT sendInfo.outcome FROM     badName => RETURN[ notFound ];     down => RETURN[ allDown ];     done => RETURN[ IF sendInfo.local THEN found ELSE notFound ];   ENDCASE => ERROR;   END;AcceptFirst: PUBLIC PROCEDURE[PupDefs.PupAddress]RETURNS[BOOLEAN] =   BEGIN   RETURN[TRUE]   END;ProtocolDefs.Init[];END.