-- File: PupJuniper.mesa,  Last Edit: HGM  January 6, 1981  11:42 PMDIRECTORY  Process USING [Yield],  CommUtilDefs USING [GetEthernetHostNumber],  DriverDefs USING [GetUseCount, GetDeviceChain, Glitch, Network],  PupJuniperDefs USING [],  PupTypes USING [PupAddress, PupSocketID],  MachineIDDefs USING [ProcessorID, ethernetSeries];PupJuniper: MONITOR  IMPORTS Process, CommUtilDefs, DriverDefs  EXPORTS PupJuniperDefs, MachineIDDefs  SHARES MachineIDDefs =  BEGIN OPEN PupTypes;  MachineID: TYPE = MachineIDDefs.ProcessorID;  CommPackageNotActive: PUBLIC ERROR = CODE;  FirstDriverNeitherLocalNorEthernet: PUBLIC ERROR = CODE;  FreeQueueNotInitialized: PUBLIC ERROR = CODE;  MachineIDFromPupAddress: PUBLIC PROCEDURE [a: PupAddress] RETURNS [MachineID] =    BEGIN    RETURN[[[ethernet[net: a.net, host: a.host]], MachineIDDefs.ethernetSeries]];    END;  PupAddressFromMachineID: PUBLIC PROCEDURE [m: MachineID, soc: PupSocketID]    RETURNS [PupAddress] =    BEGIN    WITH em: m.element SELECT ethernet FROM      ethernet => RETURN[[net: [em.net], host: [em.host], socket: soc]];      ENDCASE;    ERROR; -- can't happen    END;  -- For now, we do not have a hard-wired ProcessorID, so we use one derived from our Ethernet Address.  That brings up the problem of which Ethernet Address should be used, since in general we may be connected to multiple networks.  The answer, for now, is to use the address from the first device on the chain, which will normally be the standard Ethernet board.  GetMyMachineID: PUBLIC PROCEDURE RETURNS [MachineIDDefs.ProcessorID] =    BEGIN OPEN DriverDefs;    network: DriverDefs.Network _ DriverDefs.GetDeviceChain[];    IF GetUseCount[] = 0 THEN Glitch[CommPackageNotActive];    IF network = NIL THEN Glitch[CommPackageNotActive];    SELECT network.device FROM      local =>	RETURN[	  [[ethernet[net: 0, host: CommUtilDefs.GetEthernetHostNumber[]]],	    MachineIDDefs.ethernetSeries]];      ethernet =>	BEGIN	UNTIL network.netNumber # [0, 0] DO Process.Yield[]; ENDLOOP;	RETURN[	  [[ethernet[net: network.netNumber.b, host: network.hostNumber]],	    MachineIDDefs.ethernetSeries]];	END;      ENDCASE => Glitch[FirstDriverNeitherLocalNorEthernet];    ERROR;    END;  END.