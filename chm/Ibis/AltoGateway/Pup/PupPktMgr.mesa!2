-- File: PupPktMgr.mesa,  Last Edit: HGM  March 14, 1981  11:43 AMDIRECTORY  Process USING [    InitializeCondition, InitializeMonitor, DisableTimeout, SetTimeout,    MsecToTicks],  Storage USING [FreeString],  System USING [Pulses, MicrosecondsToPulses],  CommUtilDefs USING [LockCode, EnableAborts, UnlockCode],  PupPktOps,  PupStream USING [CloseReason, PupOpenMode],  PupPktDefs USING [PupPktStream],  PupDefs USING [    Pair, defaultPupsToAllocate, DataWordsPerPupBuffer, PupAddress, PupBuffer,    PupSocketDestroy, PupSocketKick, PupSocketID,    Tocks, veryLongWait, veryShortWait],  BufferDefs USING [QueueInitialize, QueueCleanup],  PupTypes USING [fillInSocketID];PupPktMgr: MONITOR  IMPORTS Process, Storage, System, CommUtilDefs, PupPktOps, PupDefs, BufferDefs  EXPORTS PupPktOps, PupStream, PupPktDefs =  BEGIN OPEN PupPktOps, PupPktDefs, PupDefs;  -- Manager data  free: Instance _ START PupPktOps.PupPktHot;  GetInstance: ENTRY PROCEDURE RETURNS [him: Instance] =    BEGIN    IF free = NIL THEN him _ START (NEW PupPktOps.PupPktHot)    ELSE      BEGIN      him _ free;      free _ free.next;      END;    InitializeEverything[him];    IF lockRequeueProcedure THEN CommUtilDefs.LockCode[him.me.get];  -- PupPktHot    END;  FreeInstance: ENTRY PROCEDURE [him: Instance] =    BEGIN    IF lockRequeueProcedure THEN CommUtilDefs.UnlockCode[him.me.get];  -- PupPktHot    him.next _ free;    free _ him;    END;  lockRequeueProcedure: BOOLEAN _ FALSE;  myPing: BOOLEAN _ TRUE;  myMaxAllocate, myPathMaxAllocate: CARDINAL _ defaultPupsToAllocate;  myMaxBufferSize: CARDINAL _ 0;  NoBufferToSend: PUBLIC ERROR = CODE;  StreamAlreadyOpen: PUBLIC ERROR = CODE;  maxRetransmitPulses: PUBLIC System.Pulses _ System.MicrosecondsToPulses[    5000000];  minRetransmitPulses: PUBLIC System.Pulses _ System.MicrosecondsToPulses[100000];  initialRetransmitPulses: PUBLIC System.Pulses _ System.MicrosecondsToPulses[    5000000];  ctlRetransmitPulses: PUBLIC System.Pulses _ System.MicrosecondsToPulses[    2000000];  pingPulses: PUBLIC System.Pulses _ System.MicrosecondsToPulses[60000000];  SetLockRequeueProcedureFlag: PUBLIC PROCEDURE [lockit: BOOLEAN] =    BEGIN    lockRequeueProcedure _ lockit;    END;  PupPktStreamCreate: PUBLIC PROCEDURE [remote: PupAddress, ticks: Tocks]    RETURNS [PupPktStream] =    BEGIN    RETURN[      PupPktStreamMake[PupTypes.fillInSocketID, remote, ticks, sendRfc, [0, 0]]];    END;  PupPktStreamMake: PUBLIC PROCEDURE [    local: PupSocketID, remote: PupAddress, ticks: Tocks,    mode: PupStream.PupOpenMode, id: Pair] RETURNS [PupPktStream] =    BEGIN    him: Instance _ GetInstance[];    SELECT ticks FROM      veryShortWait => him.dontWait _ TRUE;      veryLongWait => Process.DisableTimeout[@him.inputReady];      ENDCASE => Process.SetTimeout[@him.inputReady, ticks];    MakeLocal[      him, local, remote, mode, id ! UNWIND => PupPktStreamDestroy[@him.me]];    RETURN[@him.me];    END;  PupPktStreamDestroy: PUBLIC PROCEDURE [ps: PupPktStream] =    BEGIN    krock: Instance = LOOPHOLE[1234];    offset: INTEGER = @krock.me - LOOPHOLE[krock, POINTER];    him: Instance _ LOOPHOLE[ps - offset];    DestroyLocal[him];    FreeInstance[him];    END;  SetMaxAllocation: PUBLIC PROCEDURE [n: CARDINAL] =    BEGIN    myMaxAllocate _ n;    myPathMaxAllocate _ MIN[defaultPupsToAllocate, n];    END;  SetMaxBufferSize: PUBLIC PROCEDURE [n: CARDINAL] =    BEGIN myMaxBufferSize _ 2*MIN[n, DataWordsPerPupBuffer[]]; END;  SetPinging: PUBLIC PROCEDURE [ping: BOOLEAN] = BEGIN myPing _ ping; END;  InitializeEverything: PROCEDURE [him: Instance] =    BEGIN    him.state _ idle;    him.c _ NIL;    him.dontWait _ FALSE;    him.dataBytesPerPup _ 2*DataWordsPerPupBuffer[];    him.outIntPending _ FALSE;    him.outEnd _ 0;    him.probeCounter _ 0;    him.ping _ myPing;    him.myMaxAllocate _ myMaxAllocate;    him.pathMaxAllocate _ myPathMaxAllocate;    him.hisMaxAllocate _ 0;    him.throttle _ 0;    him.unackedPups _ 0;    him.allocatedPups _ 0;    him.clumpsSinceBump _ 0;    him.sentBuffer _ NIL;    him.pleaseDie _ FALSE;    him.sameNet _ FALSE;    him.sendAck _ FALSE;    him.aDataOut _ FALSE;    him.retransmitPulses _ initialRetransmitPulses;    him.whyClosed _ localClose;    him.text _ NIL;    him.next _ NIL;    BufferDefs.QueueInitialize[@him.inputQueue];    BufferDefs.QueueInitialize[@him.sentQueue];    BEGIN OPEN Process;    InitializeCondition[@him.stateChange, MsecToTicks[1000]];    InitializeCondition[@him.retransmitterReady, MsecToTicks[100]];    InitializeCondition[@him.inputReady, MsecToTicks[5000]];    InitializeCondition[@him.waitingForInterrupt, MsecToTicks[5000]];    DisableTimeout[@him.waitingForInterrupt];    CommUtilDefs.EnableAborts[@him.waitingForInterrupt];    InitializeMonitor[@him.lock];    END;    IF myMaxBufferSize # 0 THEN him.dataBytesPerPup _ myMaxBufferSize;    END;  DestroyLocal: PROCEDURE [him: Instance] =    BEGIN OPEN him;    DestroyLocalLocked[him];    JOIN retransmitterFork;    PupSocketKick[socket];    JOIN slurpFork;    -- IF sentBuffer#NIL THEN ReturnFreePupBuffer[sentBuffer];    BufferDefs.QueueCleanup[@inputQueue];    BufferDefs.QueueCleanup[@sentQueue];    PupSocketDestroy[socket];    IF text # NIL THEN Storage.FreeString[text];    END;  free.next _ NIL;  END.