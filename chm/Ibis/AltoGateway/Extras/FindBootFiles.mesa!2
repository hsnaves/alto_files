-- File: FindBootFiles.mesa,  Last Edit: HGM  March 25, 1981  5:51 PM-- Please don't forget to update the herald....DIRECTORY  InlineDefs USING [BcplLongNumber, BcplToMesaLongNumber],  Process USING [Detach, Yield],  Storage USING [Node, String, Free, FreeString, CopyString],  String USING [AppendString, AppendNumber, EquivalentString],  StringDefs USING [BcplSTRING],  System USING [GreenwichMeanTime],  Time USING [AppendCurrent],  Event USING [Item, Reason, AddNotifier],  Format USING [], -- Needed by Put.Number and Put.Date  FormSW USING [    ClientItemsProcType, ProcType, AllocateItemDescriptor, newLine, CommandItem,    StringItem, NumberItem],  MsgSW USING [Post],  Put USING [Char, CR, Date, Text, Line, Number, LongDecimal, LongNumber],  Tool USING [    Create, MakeSWsProc, UnusedLogName, MakeMsgSW, MakeFormSW, MakeFileSW,    AddThisSW],  ToolWindow USING [TransitionProcType, DisplayProcType, CreateSubwindow],  Window USING [Handle, Box, DisplayData, DisplayInvert, DisplayWhite],  PupDefs USING [    PupPackageMake, PupPackageDestroy, GetFreePupBuffer, ReturnFreePupBuffer,    PupBuffer, PupSocket, PupSocketDestroy, PupSocketMake,    defaultNumberOfNetworks, GetHopsToNetwork, SecondsToTocks,    SetPupContentsWords, GetPupContentsBytes, AppendPupAddress, AppendHostName,    AppendErrorPup, GetPupAddress, PupNameTrouble],  PupTypes USING [PupAddress, fillInSocketID, miscSrvSoc];FindBootFiles: PROGRAM  IMPORTS    InlineDefs, Process, Storage, String, Time, Event, FormSW, MsgSW, Put, Tool,    ToolWindow, Window, PupDefs =  BEGIN OPEN PupDefs, PupTypes;  herald: STRING = "Find BootFiles of March 25, 1981";  tool, msg, form, boxes, log: Window.Handle;  eventItem: Event.Item _ [eventMask: 177777B, eventProc: Broom];  defaultMaxHops: CARDINAL = 3;  pleaseStop: BOOLEAN _ FALSE;  running: BOOLEAN _ FALSE;  indicator: {left, right, off} _ off;  first: BootFile _ NIL;  maxHops: CARDINAL _ defaultMaxHops;  where: PupAddress _ [[0], [0], PupTypes.miscSrvSoc];  target: STRING _ NIL;  BootFile: TYPE = POINTER TO BootFileInfo;  BootFileInfo: TYPE = RECORD [    next: BootFile,    number: WORD,    where: PupTypes.PupAddress,    date: System.GreenwichMeanTime,    name: STRING];  ScanCircle: FormSW.ProcType =    BEGIN    IF running THEN      BEGIN MsgSW.Post[msg, "Somebody is already running..."L]; RETURN; END;    running _ TRUE;    Process.Detach[FORK DoWorld[]];    END;  ScanTarget: FormSW.ProcType =    BEGIN    IF running THEN      BEGIN MsgSW.Post[msg, "Somebody is already running..."L]; RETURN; END;    WriteCR[];    WriteCurrentDateAndTime[];    WriteString["  Finding boot files on "L];    IF ~FindPath[] THEN RETURN;    running _ TRUE;    Process.Detach[FORK DoOne[]];    END;  Stop: FormSW.ProcType = BEGIN Off[]; END;  Off: PROCEDURE =    BEGIN    IF ~running THEN RETURN;    pleaseStop _ TRUE;    WHILE running DO Process.Yield[]; ENDLOOP;    pleaseStop _ FALSE;    END;  FindPath: PROCEDURE RETURNS [BOOLEAN] =    BEGIN    WriteString[target];    WriteChar['=];    GetPupAddress[      @where, target !      PupNameTrouble =>	BEGIN MsgSW.Post[msg, e]; WriteLine[e]; GOTO Trouble; END];    PrintPupAddress[where];    WriteLine["."L];    RETURN[TRUE];    EXITS Trouble => RETURN[FALSE];    END;  DoWorld: PROCEDURE =    BEGIN    first: BOOLEAN _ TRUE;    SetupBoxes[];    FOR net: CARDINAL IN [1..PupDefs.defaultNumberOfNetworks) DO      IF GetHopsToNetwork[[net]] > maxHops THEN LOOP;      where _ [[net], [0], miscSrvSoc];      IF first THEN Put.Text[log, "Searching network "] ELSE Put.Text[log, ", "];      Put.Number[log, net, [8, FALSE, TRUE, 0]];      SearchOne[];      first _ FALSE;      ENDLOOP;    Put.CR[log];    SetDownBoxes[];    PrintBootFileList[];    DeleteList[];    running _ FALSE;    END;  DoOne: PROCEDURE =    BEGIN    SetupBoxes[];    SearchOne[];    SetDownBoxes[];    PrintBootFileList[];    DeleteList[];    running _ FALSE;    END;  SearchOne: PROCEDURE =    BEGIN    packetNumber: CARDINAL _ GetNextSequenceNumber[];    soc: PupSocket _ PupSocketMake[fillInSocketID, where, SecondsToTocks[2]];    FOR i: CARDINAL IN [0..10) UNTIL pleaseStop DO      b: PupBuffer _ GetFreePupBuffer[];      b.pupID.a _ b.pupID.b _ packetNumber;      b.pupType _ bootDirReq;      SetPupContentsWords[b, 0];      soc.put[b];      UNTIL (b _ soc.get[]) = NIL DO	SELECT TRUE FROM	  ((b.pupType # bootDirReply) OR (b.pupID.a # packetNumber) OR	    (b.pupID.b # packetNumber)) =>	    BEGIN	    temp: STRING = [100];	    PupDefs.AppendErrorPup[temp, b];	    MsgSW.Post[msg, temp];	    END;	  ENDCASE => BEGIN FlipBoxes[]; LookAtBootDir[b]; END;	ReturnFreePupBuffer[b];	ENDLOOP;      IF b # NIL THEN ReturnFreePupBuffer[b];      ENDLOOP;    PupSocketDestroy[soc];    END;  LookAtBootDir: PUBLIC PROCEDURE [b: PupDefs.PupBuffer] =    BEGIN OPEN PupDefs;    word, size, end: CARDINAL;    end _ GetPupContentsBytes[b]/2;    word _ 0;    UNTIL word >= end DO      name: STRING = [256];      timeStamp: System.GreenwichMeanTime;      timeStampLocation: LONG POINTER TO InlineDefs.BcplLongNumber;      timeStampLocation _ LOOPHOLE[@b.pupWords[word + 1]];      timeStamp _ LOOPHOLE[InlineDefs.BcplToMesaLongNumber[timeStampLocation^]];      CopyBcplString[name, LOOPHOLE[@b.pupWords[word + 1 + 2]]];      AddToList[b.pupWords[word], b.source, timeStamp, name];      size _ ((1 + name.length) + 1)/2;      word _ word + size + 1 + 2;      ENDLOOP;    END;  CopyBcplString: PROCEDURE [    a: STRING, b: LONG POINTER TO StringDefs.BcplSTRING] =    BEGIN    a.length _ b.length;    FOR i: CARDINAL IN [0..b.length) DO a[i] _ b.char[i]; ENDLOOP;    END;  AddToList: PROCEDURE [    number: WORD, where: PupTypes.PupAddress, date: System.GreenwichMeanTime,    name: STRING] =    BEGIN    finger: BootFile _ NIL;    new: BootFile;    FOR bf: BootFile _ first, bf.next UNTIL bf = NIL DO      IF number = bf.number AND where = bf.where AND date = bf.date AND	String.EquivalentString[name, bf.name] THEN RETURN;      IF bf.number < number OR (bf.number = number AND bf.date < date) OR	(bf.number = number AND bf.date = date AND LessPupAddress[	  bf.where, where]) THEN finger _ bf;      ENDLOOP;    new _ Storage.Node[SIZE[BootFileInfo]];    new^ _      [next: NIL, number: number, where: where, date: date,	name: Storage.CopyString[name]];    SELECT TRUE FROM      first = NIL => first _ new; -- first      finger = NIL => BEGIN new.next _ first; first _ new; END; -- insert at front of list      ENDCASE => BEGIN new.next _ finger.next; finger.next _ new; END; -- middle or end    END;  LessPupAddress: PROCEDURE [a, b: PupAddress] RETURNS [BOOLEAN] =    BEGIN    IF a.net < b.net THEN RETURN[TRUE];    IF a.net > b.net THEN RETURN[FALSE];    IF a.host < b.host THEN RETURN[TRUE];    IF a.host > b.host THEN RETURN[FALSE];    IF a.socket.a < b.socket.a THEN RETURN[TRUE];    IF a.socket.a > b.socket.a THEN RETURN[FALSE];    IF a.socket.b < b.socket.b THEN RETURN[TRUE];    IF a.socket.b > b.socket.b THEN RETURN[FALSE];    RETURN[FALSE];    END;  DeleteList: PROCEDURE =    BEGIN    bf: BootFile _ first;    UNTIL bf = NIL DO      next: BootFile _ bf.next;      Storage.FreeString[bf.name];      Storage.Free[bf];      bf _ next;      ENDLOOP;    first _ NIL;    END;  PrintBootFileList: PROCEDURE =    BEGIN    bf: BootFile _ first;    UNTIL bf = NIL DO      temp: STRING = [40];      PupDefs.AppendHostName[temp, bf.where];      Put.Number[log, bf.number, [8, FALSE, TRUE, 6]];      Put.Text[log, "  "L];      Put.Date[log, bf.date, dateTime];      Put.Text[log, "  "L];      Put.Text[log, bf.name];      THROUGH [bf.name.length..25) DO Put.Char[log, ' ]; ENDLOOP;      Put.Text[log, temp];      FOR bf2: BootFile _ bf.next, bf2.next UNTIL bf2 = NIL DO	temp: STRING = [40];	IF bf.number # bf2.number OR bf.date # bf2.date OR	  ~String.EquivalentString[bf2.name, bf.name] THEN EXIT;	PupDefs.AppendHostName[temp, bf2.where];	Put.Text[log, ", "L];	Put.Text[log, temp];	bf _ bf2;	ENDLOOP;      Put.CR[log];      bf _ bf.next;      ENDLOOP;    END;  nextSequenceNumber: CARDINAL _ 123;  GetNextSequenceNumber: PROCEDURE RETURNS [CARDINAL] =    BEGIN RETURN[nextSequenceNumber _ nextSequenceNumber + 1]; END;  -- IO things  WriteChar: PROCEDURE [c: CHARACTER] = BEGIN Put.Char[log, c]; END;  WriteCR: PROCEDURE = BEGIN Put.CR[log]; END;  WriteString: PROCEDURE [s: STRING] = BEGIN Put.Text[log, s]; END;  WriteLine: PROCEDURE [s: STRING] = BEGIN Put.Line[log, s]; END;  WriteLongDecimal: PROCEDURE [n: LONG CARDINAL] =    BEGIN Put.LongDecimal[log, n]; END;  WriteDecimal: PROCEDURE [n: CARDINAL] = INLINE BEGIN WriteNumber[n, 10, 0]; END;  WriteOctal: PROCEDURE [n: CARDINAL] = INLINE BEGIN WriteNumber[n, 8, 0]; END;  WriteNumber: PROCEDURE [n, radix, width: CARDINAL] = INLINE    BEGIN    temp: STRING = [25];    String.AppendNumber[temp, n, radix];    THROUGH [temp.length..width) DO WriteChar[' ]; ENDLOOP;    WriteString[temp];    END;  D8: PROCEDURE [n: CARDINAL] = BEGIN WriteNumber[n, 10, 8]; END;  O3: PROCEDURE [n: CARDINAL] = BEGIN WriteNumber[n, 8, 3]; END;  O6: PROCEDURE [n: CARDINAL] = BEGIN WriteNumber[n, 8, 3]; END;  O9: PROCEDURE [n: CARDINAL] = BEGIN WriteNumber[n, 8, 9]; END;  WriteCurrentDateAndTime: PROCEDURE =    BEGIN time: STRING = [20]; Time.AppendCurrent[time]; WriteString[time]; END;  PrintPupAddress: PROCEDURE [a: PupAddress] =    BEGIN temp: STRING = [40]; AppendPupAddress[temp, a]; WriteString[temp]; END;  indicatorBox: Window.Box = [[25, 10], [16, 16]];  DisplayBoxes: ToolWindow.DisplayProcType =    BEGIN    pattern: ARRAY [0..1] OF ARRAY [0..8) OF WORD;    left: WORD = 177400B;    right: WORD = 000377B;    SELECT indicator FROM      left => pattern _ [ALL[left], ALL[right]];      right => pattern _ [ALL[right], ALL[left]];      off => pattern _ [ALL[0], ALL[0]];      ENDCASE;    Window.DisplayData[window, indicatorBox, @pattern, 1]    END;  SetupBoxes: PROCEDURE = BEGIN indicator _ left; DisplayBoxes[boxes]; END;  FlipBoxes: PROCEDURE =    BEGIN    SELECT indicator FROM      left => indicator _ right;      off, right => indicator _ left;      ENDCASE;    Window.DisplayInvert[boxes, indicatorBox];    END;  SetDownBoxes: PROCEDURE =    BEGIN indicator _ off; Window.DisplayWhite[boxes, indicatorBox]; END;  MakeBoxesSW: PROCEDURE [window: Window.Handle] =    BEGIN    boxes _ ToolWindow.CreateSubwindow[parent: window, display: DisplayBoxes];    boxes.box.dims.h _ 36;    Tool.AddThisSW[window: window, sw: boxes, swType: LOOPHOLE[0]];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    msg _ Tool.MakeMsgSW[window: window, lines: 5];    form _ Tool.MakeFormSW[window: window, formProc: MakeForm];    MakeBoxesSW[window];    Tool.UnusedLogName[logFileName, "FindBootFiles.log$"L];    log _ Tool.MakeFileSW[window: window, name: logFileName];    END;  MakeForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 5;    items _ FormSW.AllocateItemDescriptor[nParams];    items[0] _ FormSW.CommandItem[tag: "Stop"L, proc: Stop, place: FormSW.newLine];    items[1] _ FormSW.CommandItem[      tag: "ScanCircle"L, proc: ScanCircle, place: FormSW.newLine];    items[2] _ FormSW.NumberItem[      tag: "MaxHops"L, value: @maxHops, default: defaultMaxHops];    items[3] _ FormSW.CommandItem[      tag: "ScanTarget"L, proc: ScanTarget, place: FormSW.newLine];    items[4] _ FormSW.StringItem[tag: "Target"L, string: @target];    RETURN[items, TRUE];    END;  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>	BEGIN	target _ Storage.String[20];	String.AppendString[target, "ME"L];	PupDefs.PupPackageMake[];	END;      new = inactive =>	BEGIN	IF running THEN Off[];	PupDefs.PupPackageDestroy[];	Storage.FreeString[target];	END;      ENDCASE;    END;  Broom: PROCEDURE [why: Event.Reason] =    BEGIN    SELECT why FROM      makeImage, makeCheck =>	BEGIN IF running THEN Off[]; PupDefs.PupPackageDestroy[]; END;      startImage, restartCheck, continueCheck =>	BEGIN PupDefs.PupPackageMake[]; END;      ENDCASE => NULL;    END;  -- Main Body  tool _ Tool.Create[    name: herald, makeSWsProc: MakeSWs, clientTransition: ClientTransition];  Event.AddNotifier[@eventItem];  END.